define("sarike/timefly/0.0.1/timefly-debug", [ "sarike/bootstrap/2.3.2/bootstrap-debug", "$-debug", "jquery-plugin/form/3.44.0/form-debug", "gallery/backbone/1.0.0/backbone-debug", "gallery/underscore/1.4.4/underscore-debug", "./common/common-debug", "./libs/libs-debug", "sarike/jquery-ui/1.10.3/jquery-ui-debug", "sarike/jquery-noty/2.1.0/jquery-noty-debug", "./common/base/base-debug", "./editor/editor-debug", "./editor/templates/editor-debug.tpl", "sarike/jquery-validate/1.11.1/jquery-validate-debug", "./common/base/templates/common_empty-debug.tpl", "./common/base/templates/common_content-debug.tpl", "./common/base/templates/add_edit_todo-debug.tpl", "./common/base/templates/common_header-debug.tpl", "./common/box/box-debug", "./common/box/templates/user_item-debug.tpl", "./common/box/templates/user_list_box-debug.tpl", "./common/box/templates/about_box-debug.tpl", "./common/box/templates/user_profile_box-debug.tpl", "./common/box/templates/side_nav_box-debug.tpl", "sarike/moment-timezone/0.0.3/moment-timezone-debug", "sarike/moment/2.4.0/moment-debug", "sarike/markdown/0.6.0/markdown-debug", "./index/index-debug", "./index/templates/todo_item-debug.tpl", "./index/templates/index_content-debug.tpl", "./home/home-debug", "./home/templates/setting_form-debug.tpl", "./home/templates/password_reset_form-debug.tpl", "./home/templates/add_complete_modal-debug.tpl", "./home/templates/todo_item-debug.tpl" ], function(require, exports) {
    "use strict";
    require("sarike/bootstrap/2.3.2/bootstrap-debug");
    require("jquery-plugin/form/3.44.0/form-debug");
    var $ = require("$-debug"), Backbone = require("gallery/backbone/1.0.0/backbone-debug"), Common = require("./common/common-debug");
    exports.mm = require("sarike/moment-timezone/0.0.3/moment-timezone-debug");
    exports.md = require("sarike/markdown/0.6.0/markdown-debug");
    $.ajaxSetup({
        global: true,
        beforeSend: function() {
            $("#loading").fadeIn();
        },
        complete: function() {
            $("#loading").fadeOut();
        }
    });
    $(function() {
        //        $('#sidebar').affix();
        $.get("me", function(res) {
            var router = new Backbone.Router(), user = new Common.Models.BaseUser(res.data.user), context = {
                header: $("header"),
                sideBar: $("#sidebar"),
                content: $("#content"),
                footer: $("footer"),
                user: user,
                router: router
            };
            require("./index/index-debug").init(context);
            require("./home/home-debug").init(context);
            Backbone.history.start();
        });
    });
});

/* ===================================================
 * bootstrap-transition.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#transitions
 * ===================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */
define("sarike/bootstrap/2.3.2/bootstrap-debug", [ "$-debug" ], function(require) {
    var jQuery = require("$-debug");
    !function($) {
        "use strict";
        // jshint ;_;
        /* CSS TRANSITION SUPPORT (http://www.modernizr.com/)
   * ======================================================= */
        $(function() {
            $.support.transition = function() {
                var transitionEnd = function() {
                    var el = document.createElement("bootstrap"), transEndEventNames = {
                        WebkitTransition: "webkitTransitionEnd",
                        MozTransition: "transitionend",
                        OTransition: "oTransitionEnd otransitionend",
                        transition: "transitionend"
                    }, name;
                    for (name in transEndEventNames) {
                        if (el.style[name] !== undefined) {
                            return transEndEventNames[name];
                        }
                    }
                }();
                return transitionEnd && {
                    end: transitionEnd
                };
            }();
        });
    }(window.jQuery);
    /* ==========================================================
 * bootstrap-alert.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#alerts
 * ==========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */
    !function($) {
        "use strict";
        // jshint ;_;
        /* ALERT CLASS DEFINITION
  * ====================== */
        var dismiss = '[data-dismiss="alert"]', Alert = function(el) {
            $(el).on("click", dismiss, this.close);
        };
        Alert.prototype.close = function(e) {
            var $this = $(this), selector = $this.attr("data-target"), $parent;
            if (!selector) {
                selector = $this.attr("href");
                selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "");
            }
            $parent = $(selector);
            e && e.preventDefault();
            $parent.length || ($parent = $this.hasClass("alert") ? $this : $this.parent());
            $parent.trigger(e = $.Event("close"));
            if (e.isDefaultPrevented()) return;
            $parent.removeClass("in");
            function removeElement() {
                $parent.trigger("closed").remove();
            }
            $.support.transition && $parent.hasClass("fade") ? $parent.on($.support.transition.end, removeElement) : removeElement();
        };
        /* ALERT PLUGIN DEFINITION
  * ======================= */
        var old = $.fn.alert;
        $.fn.alert = function(option) {
            return this.each(function() {
                var $this = $(this), data = $this.data("alert");
                if (!data) $this.data("alert", data = new Alert(this));
                if (typeof option == "string") data[option].call($this);
            });
        };
        $.fn.alert.Constructor = Alert;
        /* ALERT NO CONFLICT
  * ================= */
        $.fn.alert.noConflict = function() {
            $.fn.alert = old;
            return this;
        };
        /* ALERT DATA-API
  * ============== */
        $(document).on("click.alert.data-api", dismiss, Alert.prototype.close);
    }(window.jQuery);
    /* ============================================================
 * bootstrap-button.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#buttons
 * ============================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */
    !function($) {
        "use strict";
        // jshint ;_;
        /* BUTTON PUBLIC CLASS DEFINITION
  * ============================== */
        var Button = function(element, options) {
            this.$element = $(element);
            this.options = $.extend({}, $.fn.button.defaults, options);
        };
        Button.prototype.setState = function(state) {
            var d = "disabled", $el = this.$element, data = $el.data(), val = $el.is("input") ? "val" : "html";
            state = state + "Text";
            data.resetText || $el.data("resetText", $el[val]());
            $el[val](data[state] || this.options[state]);
            // push to event loop to allow forms to submit
            setTimeout(function() {
                state == "loadingText" ? $el.addClass(d).attr(d, d) : $el.removeClass(d).removeAttr(d);
            }, 0);
        };
        Button.prototype.toggle = function() {
            var $parent = this.$element.closest('[data-toggle="buttons-radio"]');
            $parent && $parent.find(".active").removeClass("active");
            this.$element.toggleClass("active");
        };
        /* BUTTON PLUGIN DEFINITION
  * ======================== */
        var old = $.fn.button;
        $.fn.button = function(option) {
            return this.each(function() {
                var $this = $(this), data = $this.data("button"), options = typeof option == "object" && option;
                if (!data) $this.data("button", data = new Button(this, options));
                if (option == "toggle") data.toggle(); else if (option) data.setState(option);
            });
        };
        $.fn.button.defaults = {
            loadingText: "loading..."
        };
        $.fn.button.Constructor = Button;
        /* BUTTON NO CONFLICT
  * ================== */
        $.fn.button.noConflict = function() {
            $.fn.button = old;
            return this;
        };
        /* BUTTON DATA-API
  * =============== */
        $(document).on("click.button.data-api", "[data-toggle^=button]", function(e) {
            var $btn = $(e.target);
            if (!$btn.hasClass("btn")) $btn = $btn.closest(".btn");
            $btn.button("toggle");
        });
    }(window.jQuery);
    /* ==========================================================
 * bootstrap-carousel.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#carousel
 * ==========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */
    !function($) {
        "use strict";
        // jshint ;_;
        /* CAROUSEL CLASS DEFINITION
  * ========================= */
        var Carousel = function(element, options) {
            this.$element = $(element);
            this.$indicators = this.$element.find(".carousel-indicators");
            this.options = options;
            this.options.pause == "hover" && this.$element.on("mouseenter", $.proxy(this.pause, this)).on("mouseleave", $.proxy(this.cycle, this));
        };
        Carousel.prototype = {
            cycle: function(e) {
                if (!e) this.paused = false;
                if (this.interval) clearInterval(this.interval);
                this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
                return this;
            },
            getActiveIndex: function() {
                this.$active = this.$element.find(".item.active");
                this.$items = this.$active.parent().children();
                return this.$items.index(this.$active);
            },
            to: function(pos) {
                var activeIndex = this.getActiveIndex(), that = this;
                if (pos > this.$items.length - 1 || pos < 0) return;
                if (this.sliding) {
                    return this.$element.one("slid", function() {
                        that.to(pos);
                    });
                }
                if (activeIndex == pos) {
                    return this.pause().cycle();
                }
                return this.slide(pos > activeIndex ? "next" : "prev", $(this.$items[pos]));
            },
            pause: function(e) {
                if (!e) this.paused = true;
                if (this.$element.find(".next, .prev").length && $.support.transition.end) {
                    this.$element.trigger($.support.transition.end);
                    this.cycle(true);
                }
                clearInterval(this.interval);
                this.interval = null;
                return this;
            },
            next: function() {
                if (this.sliding) return;
                return this.slide("next");
            },
            prev: function() {
                if (this.sliding) return;
                return this.slide("prev");
            },
            slide: function(type, next) {
                var $active = this.$element.find(".item.active"), $next = next || $active[type](), isCycling = this.interval, direction = type == "next" ? "left" : "right", fallback = type == "next" ? "first" : "last", that = this, e;
                this.sliding = true;
                isCycling && this.pause();
                $next = $next.length ? $next : this.$element.find(".item")[fallback]();
                e = $.Event("slide", {
                    relatedTarget: $next[0],
                    direction: direction
                });
                if ($next.hasClass("active")) return;
                if (this.$indicators.length) {
                    this.$indicators.find(".active").removeClass("active");
                    this.$element.one("slid", function() {
                        var $nextIndicator = $(that.$indicators.children()[that.getActiveIndex()]);
                        $nextIndicator && $nextIndicator.addClass("active");
                    });
                }
                if ($.support.transition && this.$element.hasClass("slide")) {
                    this.$element.trigger(e);
                    if (e.isDefaultPrevented()) return;
                    $next.addClass(type);
                    $next[0].offsetWidth;
                    // force reflow
                    $active.addClass(direction);
                    $next.addClass(direction);
                    this.$element.one($.support.transition.end, function() {
                        $next.removeClass([ type, direction ].join(" ")).addClass("active");
                        $active.removeClass([ "active", direction ].join(" "));
                        that.sliding = false;
                        setTimeout(function() {
                            that.$element.trigger("slid");
                        }, 0);
                    });
                } else {
                    this.$element.trigger(e);
                    if (e.isDefaultPrevented()) return;
                    $active.removeClass("active");
                    $next.addClass("active");
                    this.sliding = false;
                    this.$element.trigger("slid");
                }
                isCycling && this.cycle();
                return this;
            }
        };
        /* CAROUSEL PLUGIN DEFINITION
  * ========================== */
        var old = $.fn.carousel;
        $.fn.carousel = function(option) {
            return this.each(function() {
                var $this = $(this), data = $this.data("carousel"), options = $.extend({}, $.fn.carousel.defaults, typeof option == "object" && option), action = typeof option == "string" ? option : options.slide;
                if (!data) $this.data("carousel", data = new Carousel(this, options));
                if (typeof option == "number") data.to(option); else if (action) data[action](); else if (options.interval) data.pause().cycle();
            });
        };
        $.fn.carousel.defaults = {
            interval: 5e3,
            pause: "hover"
        };
        $.fn.carousel.Constructor = Carousel;
        /* CAROUSEL NO CONFLICT
  * ==================== */
        $.fn.carousel.noConflict = function() {
            $.fn.carousel = old;
            return this;
        };
        /* CAROUSEL DATA-API
  * ================= */
        $(document).on("click.carousel.data-api", "[data-slide], [data-slide-to]", function(e) {
            var $this = $(this), href, $target = $($this.attr("data-target") || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "")), options = $.extend({}, $target.data(), $this.data()), slideIndex;
            $target.carousel(options);
            if (slideIndex = $this.attr("data-slide-to")) {
                $target.data("carousel").pause().to(slideIndex).cycle();
            }
            e.preventDefault();
        });
    }(window.jQuery);
    /* =============================================================
 * bootstrap-collapse.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#collapse
 * =============================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */
    !function($) {
        "use strict";
        // jshint ;_;
        /* COLLAPSE PUBLIC CLASS DEFINITION
  * ================================ */
        var Collapse = function(element, options) {
            this.$element = $(element);
            this.options = $.extend({}, $.fn.collapse.defaults, options);
            if (this.options.parent) {
                this.$parent = $(this.options.parent);
            }
            this.options.toggle && this.toggle();
        };
        Collapse.prototype = {
            constructor: Collapse,
            dimension: function() {
                var hasWidth = this.$element.hasClass("width");
                return hasWidth ? "width" : "height";
            },
            show: function() {
                var dimension, scroll, actives, hasData;
                if (this.transitioning || this.$element.hasClass("in")) return;
                dimension = this.dimension();
                scroll = $.camelCase([ "scroll", dimension ].join("-"));
                actives = this.$parent && this.$parent.find("> .accordion-group > .in");
                if (actives && actives.length) {
                    hasData = actives.data("collapse");
                    if (hasData && hasData.transitioning) return;
                    actives.collapse("hide");
                    hasData || actives.data("collapse", null);
                }
                this.$element[dimension](0);
                this.transition("addClass", $.Event("show"), "shown");
                $.support.transition && this.$element[dimension](this.$element[0][scroll]);
            },
            hide: function() {
                var dimension;
                if (this.transitioning || !this.$element.hasClass("in")) return;
                dimension = this.dimension();
                this.reset(this.$element[dimension]());
                this.transition("removeClass", $.Event("hide"), "hidden");
                this.$element[dimension](0);
            },
            reset: function(size) {
                var dimension = this.dimension();
                this.$element.removeClass("collapse")[dimension](size || "auto")[0].offsetWidth;
                this.$element[size !== null ? "addClass" : "removeClass"]("collapse");
                return this;
            },
            transition: function(method, startEvent, completeEvent) {
                var that = this, complete = function() {
                    if (startEvent.type == "show") that.reset();
                    that.transitioning = 0;
                    that.$element.trigger(completeEvent);
                };
                this.$element.trigger(startEvent);
                if (startEvent.isDefaultPrevented()) return;
                this.transitioning = 1;
                this.$element[method]("in");
                $.support.transition && this.$element.hasClass("collapse") ? this.$element.one($.support.transition.end, complete) : complete();
            },
            toggle: function() {
                this[this.$element.hasClass("in") ? "hide" : "show"]();
            }
        };
        /* COLLAPSE PLUGIN DEFINITION
  * ========================== */
        var old = $.fn.collapse;
        $.fn.collapse = function(option) {
            return this.each(function() {
                var $this = $(this), data = $this.data("collapse"), options = $.extend({}, $.fn.collapse.defaults, $this.data(), typeof option == "object" && option);
                if (!data) $this.data("collapse", data = new Collapse(this, options));
                if (typeof option == "string") data[option]();
            });
        };
        $.fn.collapse.defaults = {
            toggle: true
        };
        $.fn.collapse.Constructor = Collapse;
        /* COLLAPSE NO CONFLICT
  * ==================== */
        $.fn.collapse.noConflict = function() {
            $.fn.collapse = old;
            return this;
        };
        /* COLLAPSE DATA-API
  * ================= */
        $(document).on("click.collapse.data-api", "[data-toggle=collapse]", function(e) {
            var $this = $(this), href, target = $this.attr("data-target") || e.preventDefault() || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, ""), option = $(target).data("collapse") ? "toggle" : $this.data();
            $this[$(target).hasClass("in") ? "addClass" : "removeClass"]("collapsed");
            $(target).collapse(option);
        });
    }(window.jQuery);
    /* ============================================================
 * bootstrap-dropdown.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#dropdowns
 * ============================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */
    !function($) {
        "use strict";
        // jshint ;_;
        /* DROPDOWN CLASS DEFINITION
  * ========================= */
        var toggle = "[data-toggle=dropdown]", Dropdown = function(element) {
            var $el = $(element).on("click.dropdown.data-api", this.toggle);
            $("html").on("click.dropdown.data-api", function() {
                $el.parent().removeClass("open");
            });
        };
        Dropdown.prototype = {
            constructor: Dropdown,
            toggle: function(e) {
                var $this = $(this), $parent, isActive;
                if ($this.is(".disabled, :disabled")) return;
                $parent = getParent($this);
                isActive = $parent.hasClass("open");
                clearMenus();
                if (!isActive) {
                    if ("ontouchstart" in document.documentElement) {
                        // if mobile we we use a backdrop because click events don't delegate
                        $('<div class="dropdown-backdrop"/>').insertBefore($(this)).on("click", clearMenus);
                    }
                    $parent.toggleClass("open");
                }
                $this.focus();
                return false;
            },
            keydown: function(e) {
                var $this, $items, $active, $parent, isActive, index;
                if (!/(38|40|27)/.test(e.keyCode)) return;
                $this = $(this);
                e.preventDefault();
                e.stopPropagation();
                if ($this.is(".disabled, :disabled")) return;
                $parent = getParent($this);
                isActive = $parent.hasClass("open");
                if (!isActive || isActive && e.keyCode == 27) {
                    if (e.which == 27) $parent.find(toggle).focus();
                    return $this.click();
                }
                $items = $("[role=menu] li:not(.divider):visible a", $parent);
                if (!$items.length) return;
                index = $items.index($items.filter(":focus"));
                if (e.keyCode == 38 && index > 0) index--;
                // up
                if (e.keyCode == 40 && index < $items.length - 1) index++;
                // down
                if (!~index) index = 0;
                $items.eq(index).focus();
            }
        };
        function clearMenus() {
            $(".dropdown-backdrop").remove();
            $(toggle).each(function() {
                getParent($(this)).removeClass("open");
            });
        }
        function getParent($this) {
            var selector = $this.attr("data-target"), $parent;
            if (!selector) {
                selector = $this.attr("href");
                selector = selector && /#/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, "");
            }
            $parent = selector && $(selector);
            if (!$parent || !$parent.length) $parent = $this.parent();
            return $parent;
        }
        /* DROPDOWN PLUGIN DEFINITION
   * ========================== */
        var old = $.fn.dropdown;
        $.fn.dropdown = function(option) {
            return this.each(function() {
                var $this = $(this), data = $this.data("dropdown");
                if (!data) $this.data("dropdown", data = new Dropdown(this));
                if (typeof option == "string") data[option].call($this);
            });
        };
        $.fn.dropdown.Constructor = Dropdown;
        /* DROPDOWN NO CONFLICT
  * ==================== */
        $.fn.dropdown.noConflict = function() {
            $.fn.dropdown = old;
            return this;
        };
        /* APPLY TO STANDARD DROPDOWN ELEMENTS
   * =================================== */
        $(document).on("click.dropdown.data-api", clearMenus).on("click.dropdown.data-api", ".dropdown form", function(e) {
            e.stopPropagation();
        }).on("click.dropdown.data-api", toggle, Dropdown.prototype.toggle).on("keydown.dropdown.data-api", toggle + ", [role=menu]", Dropdown.prototype.keydown);
    }(window.jQuery);
    /* =========================================================
 * bootstrap-modal.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#modals
 * =========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */
    !function($) {
        "use strict";
        // jshint ;_;
        /* MODAL CLASS DEFINITION
  * ====================== */
        var Modal = function(element, options) {
            this.options = options;
            this.$element = $(element).delegate('[data-dismiss="modal"]', "click.dismiss.modal", $.proxy(this.hide, this));
            this.options.remote && this.$element.find(".modal-body").load(this.options.remote);
        };
        Modal.prototype = {
            constructor: Modal,
            toggle: function() {
                return this[!this.isShown ? "show" : "hide"]();
            },
            show: function() {
                var that = this, e = $.Event("show");
                this.$element.trigger(e);
                if (this.isShown || e.isDefaultPrevented()) return;
                this.isShown = true;
                this.escape();
                this.backdrop(function() {
                    var transition = $.support.transition && that.$element.hasClass("fade");
                    if (!that.$element.parent().length) {
                        that.$element.appendTo(document.body);
                    }
                    that.$element.show();
                    if (transition) {
                        that.$element[0].offsetWidth;
                    }
                    that.$element.addClass("in").attr("aria-hidden", false);
                    that.enforceFocus();
                    transition ? that.$element.one($.support.transition.end, function() {
                        that.$element.focus().trigger("shown");
                    }) : that.$element.focus().trigger("shown");
                });
            },
            hide: function(e) {
                e && e.preventDefault();
                var that = this;
                e = $.Event("hide");
                this.$element.trigger(e);
                if (!this.isShown || e.isDefaultPrevented()) return;
                this.isShown = false;
                this.escape();
                $(document).off("focusin.modal");
                this.$element.removeClass("in").attr("aria-hidden", true);
                $.support.transition && this.$element.hasClass("fade") ? this.hideWithTransition() : this.hideModal();
            },
            enforceFocus: function() {
                var that = this;
                $(document).on("focusin.modal", function(e) {
                    if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {
                        that.$element.focus();
                    }
                });
            },
            escape: function() {
                var that = this;
                if (this.isShown && this.options.keyboard) {
                    this.$element.on("keyup.dismiss.modal", function(e) {
                        e.which == 27 && that.hide();
                    });
                } else if (!this.isShown) {
                    this.$element.off("keyup.dismiss.modal");
                }
            },
            hideWithTransition: function() {
                var that = this, timeout = setTimeout(function() {
                    that.$element.off($.support.transition.end);
                    that.hideModal();
                }, 500);
                this.$element.one($.support.transition.end, function() {
                    clearTimeout(timeout);
                    that.hideModal();
                });
            },
            hideModal: function() {
                var that = this;
                this.$element.hide();
                this.backdrop(function() {
                    that.removeBackdrop();
                    that.$element.trigger("hidden");
                });
            },
            removeBackdrop: function() {
                this.$backdrop && this.$backdrop.remove();
                this.$backdrop = null;
            },
            backdrop: function(callback) {
                var that = this, animate = this.$element.hasClass("fade") ? "fade" : "";
                if (this.isShown && this.options.backdrop) {
                    var doAnimate = $.support.transition && animate;
                    this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />').appendTo(document.body);
                    this.$backdrop.click(this.options.backdrop == "static" ? $.proxy(this.$element[0].focus, this.$element[0]) : $.proxy(this.hide, this));
                    if (doAnimate) this.$backdrop[0].offsetWidth;
                    // force reflow
                    this.$backdrop.addClass("in");
                    if (!callback) return;
                    doAnimate ? this.$backdrop.one($.support.transition.end, callback) : callback();
                } else if (!this.isShown && this.$backdrop) {
                    this.$backdrop.removeClass("in");
                    $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one($.support.transition.end, callback) : callback();
                } else if (callback) {
                    callback();
                }
            }
        };
        /* MODAL PLUGIN DEFINITION
  * ======================= */
        var old = $.fn.modal;
        $.fn.modal = function(option) {
            return this.each(function() {
                var $this = $(this), data = $this.data("modal"), options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == "object" && option);
                if (!data) $this.data("modal", data = new Modal(this, options));
                if (typeof option == "string") data[option](); else if (options.show) data.show();
            });
        };
        $.fn.modal.defaults = {
            backdrop: true,
            keyboard: true,
            show: true
        };
        $.fn.modal.Constructor = Modal;
        /* MODAL NO CONFLICT
  * ================= */
        $.fn.modal.noConflict = function() {
            $.fn.modal = old;
            return this;
        };
        /* MODAL DATA-API
  * ============== */
        $(document).on("click.modal.data-api", '[data-toggle="modal"]', function(e) {
            var $this = $(this), href = $this.attr("href"), $target = $($this.attr("data-target") || href && href.replace(/.*(?=#[^\s]+$)/, "")), option = $target.data("modal") ? "toggle" : $.extend({
                remote: !/#/.test(href) && href
            }, $target.data(), $this.data());
            e.preventDefault();
            $target.modal(option).one("hide", function() {
                $this.focus();
            });
        });
    }(window.jQuery);
    /* ===========================================================
 * bootstrap-tooltip.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#tooltips
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ===========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */
    !function($) {
        "use strict";
        // jshint ;_;
        /* TOOLTIP PUBLIC CLASS DEFINITION
  * =============================== */
        var Tooltip = function(element, options) {
            this.init("tooltip", element, options);
        };
        Tooltip.prototype = {
            constructor: Tooltip,
            init: function(type, element, options) {
                var eventIn, eventOut, triggers, trigger, i;
                this.type = type;
                this.$element = $(element);
                this.options = this.getOptions(options);
                this.enabled = true;
                triggers = this.options.trigger.split(" ");
                for (i = triggers.length; i--; ) {
                    trigger = triggers[i];
                    if (trigger == "click") {
                        this.$element.on("click." + this.type, this.options.selector, $.proxy(this.toggle, this));
                    } else if (trigger != "manual") {
                        eventIn = trigger == "hover" ? "mouseenter" : "focus";
                        eventOut = trigger == "hover" ? "mouseleave" : "blur";
                        this.$element.on(eventIn + "." + this.type, this.options.selector, $.proxy(this.enter, this));
                        this.$element.on(eventOut + "." + this.type, this.options.selector, $.proxy(this.leave, this));
                    }
                }
                this.options.selector ? this._options = $.extend({}, this.options, {
                    trigger: "manual",
                    selector: ""
                }) : this.fixTitle();
            },
            getOptions: function(options) {
                options = $.extend({}, $.fn[this.type].defaults, this.$element.data(), options);
                if (options.delay && typeof options.delay == "number") {
                    options.delay = {
                        show: options.delay,
                        hide: options.delay
                    };
                }
                return options;
            },
            enter: function(e) {
                var defaults = $.fn[this.type].defaults, options = {}, self;
                this._options && $.each(this._options, function(key, value) {
                    if (defaults[key] != value) options[key] = value;
                }, this);
                self = $(e.currentTarget)[this.type](options).data(this.type);
                if (!self.options.delay || !self.options.delay.show) return self.show();
                clearTimeout(this.timeout);
                self.hoverState = "in";
                this.timeout = setTimeout(function() {
                    if (self.hoverState == "in") self.show();
                }, self.options.delay.show);
            },
            leave: function(e) {
                var self = $(e.currentTarget)[this.type](this._options).data(this.type);
                if (this.timeout) clearTimeout(this.timeout);
                if (!self.options.delay || !self.options.delay.hide) return self.hide();
                self.hoverState = "out";
                this.timeout = setTimeout(function() {
                    if (self.hoverState == "out") self.hide();
                }, self.options.delay.hide);
            },
            show: function() {
                var $tip, pos, actualWidth, actualHeight, placement, tp, e = $.Event("show");
                if (this.hasContent() && this.enabled) {
                    this.$element.trigger(e);
                    if (e.isDefaultPrevented()) return;
                    $tip = this.tip();
                    this.setContent();
                    if (this.options.animation) {
                        $tip.addClass("fade");
                    }
                    placement = typeof this.options.placement == "function" ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
                    $tip.detach().css({
                        top: 0,
                        left: 0,
                        display: "block"
                    });
                    this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
                    pos = this.getPosition();
                    actualWidth = $tip[0].offsetWidth;
                    actualHeight = $tip[0].offsetHeight;
                    switch (placement) {
                      case "bottom":
                        tp = {
                            top: pos.top + pos.height,
                            left: pos.left + pos.width / 2 - actualWidth / 2
                        };
                        break;

                      case "top":
                        tp = {
                            top: pos.top - actualHeight,
                            left: pos.left + pos.width / 2 - actualWidth / 2
                        };
                        break;

                      case "left":
                        tp = {
                            top: pos.top + pos.height / 2 - actualHeight / 2,
                            left: pos.left - actualWidth
                        };
                        break;

                      case "right":
                        tp = {
                            top: pos.top + pos.height / 2 - actualHeight / 2,
                            left: pos.left + pos.width
                        };
                        break;
                    }
                    this.applyPlacement(tp, placement);
                    this.$element.trigger("shown");
                }
            },
            applyPlacement: function(offset, placement) {
                var $tip = this.tip(), width = $tip[0].offsetWidth, height = $tip[0].offsetHeight, actualWidth, actualHeight, delta, replace;
                $tip.offset(offset).addClass(placement).addClass("in");
                actualWidth = $tip[0].offsetWidth;
                actualHeight = $tip[0].offsetHeight;
                if (placement == "top" && actualHeight != height) {
                    offset.top = offset.top + height - actualHeight;
                    replace = true;
                }
                if (placement == "bottom" || placement == "top") {
                    delta = 0;
                    if (offset.left < 0) {
                        delta = offset.left * -2;
                        offset.left = 0;
                        $tip.offset(offset);
                        actualWidth = $tip[0].offsetWidth;
                        actualHeight = $tip[0].offsetHeight;
                    }
                    this.replaceArrow(delta - width + actualWidth, actualWidth, "left");
                } else {
                    this.replaceArrow(actualHeight - height, actualHeight, "top");
                }
                if (replace) $tip.offset(offset);
            },
            replaceArrow: function(delta, dimension, position) {
                this.arrow().css(position, delta ? 50 * (1 - delta / dimension) + "%" : "");
            },
            setContent: function() {
                var $tip = this.tip(), title = this.getTitle();
                $tip.find(".tooltip-inner")[this.options.html ? "html" : "text"](title);
                $tip.removeClass("fade in top bottom left right");
            },
            hide: function() {
                var that = this, $tip = this.tip(), e = $.Event("hide");
                this.$element.trigger(e);
                if (e.isDefaultPrevented()) return;
                $tip.removeClass("in");
                function removeWithAnimation() {
                    var timeout = setTimeout(function() {
                        $tip.off($.support.transition.end).detach();
                    }, 500);
                    $tip.one($.support.transition.end, function() {
                        clearTimeout(timeout);
                        $tip.detach();
                    });
                }
                $.support.transition && this.$tip.hasClass("fade") ? removeWithAnimation() : $tip.detach();
                this.$element.trigger("hidden");
                return this;
            },
            fixTitle: function() {
                var $e = this.$element;
                if ($e.attr("title") || typeof $e.attr("data-original-title") != "string") {
                    $e.attr("data-original-title", $e.attr("title") || "").attr("title", "");
                }
            },
            hasContent: function() {
                return this.getTitle();
            },
            getPosition: function() {
                var el = this.$element[0];
                return $.extend({}, typeof el.getBoundingClientRect == "function" ? el.getBoundingClientRect() : {
                    width: el.offsetWidth,
                    height: el.offsetHeight
                }, this.$element.offset());
            },
            getTitle: function() {
                var title, $e = this.$element, o = this.options;
                title = $e.attr("data-original-title") || (typeof o.title == "function" ? o.title.call($e[0]) : o.title);
                return title;
            },
            tip: function() {
                return this.$tip = this.$tip || $(this.options.template);
            },
            arrow: function() {
                return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");
            },
            validate: function() {
                if (!this.$element[0].parentNode) {
                    this.hide();
                    this.$element = null;
                    this.options = null;
                }
            },
            enable: function() {
                this.enabled = true;
            },
            disable: function() {
                this.enabled = false;
            },
            toggleEnabled: function() {
                this.enabled = !this.enabled;
            },
            toggle: function(e) {
                var self = e ? $(e.currentTarget)[this.type](this._options).data(this.type) : this;
                self.tip().hasClass("in") ? self.hide() : self.show();
            },
            destroy: function() {
                this.hide().$element.off("." + this.type).removeData(this.type);
            }
        };
        /* TOOLTIP PLUGIN DEFINITION
  * ========================= */
        var old = $.fn.tooltip;
        $.fn.tooltip = function(option) {
            return this.each(function() {
                var $this = $(this), data = $this.data("tooltip"), options = typeof option == "object" && option;
                if (!data) $this.data("tooltip", data = new Tooltip(this, options));
                if (typeof option == "string") data[option]();
            });
        };
        $.fn.tooltip.Constructor = Tooltip;
        $.fn.tooltip.defaults = {
            animation: true,
            placement: "top",
            selector: false,
            template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
            trigger: "hover focus",
            title: "",
            delay: 0,
            html: false,
            container: false
        };
        /* TOOLTIP NO CONFLICT
  * =================== */
        $.fn.tooltip.noConflict = function() {
            $.fn.tooltip = old;
            return this;
        };
    }(window.jQuery);
    /* ===========================================================
 * bootstrap-popover.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#popovers
 * ===========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =========================================================== */
    !function($) {
        "use strict";
        // jshint ;_;
        /* POPOVER PUBLIC CLASS DEFINITION
  * =============================== */
        var Popover = function(element, options) {
            this.init("popover", element, options);
        };
        /* NOTE: POPOVER EXTENDS BOOTSTRAP-TOOLTIP.js
     ========================================== */
        Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype, {
            constructor: Popover,
            setContent: function() {
                var $tip = this.tip(), title = this.getTitle(), content = this.getContent();
                $tip.find(".popover-title")[this.options.html ? "html" : "text"](title);
                $tip.find(".popover-content")[this.options.html ? "html" : "text"](content);
                $tip.removeClass("fade top bottom left right in");
            },
            hasContent: function() {
                return this.getTitle() || this.getContent();
            },
            getContent: function() {
                var content, $e = this.$element, o = this.options;
                content = (typeof o.content == "function" ? o.content.call($e[0]) : o.content) || $e.attr("data-content");
                return content;
            },
            tip: function() {
                if (!this.$tip) {
                    this.$tip = $(this.options.template);
                }
                return this.$tip;
            },
            destroy: function() {
                this.hide().$element.off("." + this.type).removeData(this.type);
            }
        });
        /* POPOVER PLUGIN DEFINITION
  * ======================= */
        var old = $.fn.popover;
        $.fn.popover = function(option) {
            return this.each(function() {
                var $this = $(this), data = $this.data("popover"), options = typeof option == "object" && option;
                if (!data) $this.data("popover", data = new Popover(this, options));
                if (typeof option == "string") data[option]();
            });
        };
        $.fn.popover.Constructor = Popover;
        $.fn.popover.defaults = $.extend({}, $.fn.tooltip.defaults, {
            placement: "right",
            trigger: "click",
            content: "",
            template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
        });
        /* POPOVER NO CONFLICT
  * =================== */
        $.fn.popover.noConflict = function() {
            $.fn.popover = old;
            return this;
        };
    }(window.jQuery);
    /* =============================================================
 * bootstrap-scrollspy.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#scrollspy
 * =============================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================== */
    !function($) {
        "use strict";
        // jshint ;_;
        /* SCROLLSPY CLASS DEFINITION
  * ========================== */
        function ScrollSpy(element, options) {
            var process = $.proxy(this.process, this), $element = $(element).is("body") ? $(window) : $(element), href;
            this.options = $.extend({}, $.fn.scrollspy.defaults, options);
            this.$scrollElement = $element.on("scroll.scroll-spy.data-api", process);
            this.selector = (this.options.target || (href = $(element).attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "") || "") + " .nav li > a";
            this.$body = $("body");
            this.refresh();
            this.process();
        }
        ScrollSpy.prototype = {
            constructor: ScrollSpy,
            refresh: function() {
                var self = this, $targets;
                this.offsets = $([]);
                this.targets = $([]);
                $targets = this.$body.find(this.selector).map(function() {
                    var $el = $(this), href = $el.data("target") || $el.attr("href"), $href = /^#\w/.test(href) && $(href);
                    return $href && $href.length && [ [ $href.position().top + (!$.isWindow(self.$scrollElement.get(0)) && self.$scrollElement.scrollTop()), href ] ] || null;
                }).sort(function(a, b) {
                    return a[0] - b[0];
                }).each(function() {
                    self.offsets.push(this[0]);
                    self.targets.push(this[1]);
                });
            },
            process: function() {
                var scrollTop = this.$scrollElement.scrollTop() + this.options.offset, scrollHeight = this.$scrollElement[0].scrollHeight || this.$body[0].scrollHeight, maxScroll = scrollHeight - this.$scrollElement.height(), offsets = this.offsets, targets = this.targets, activeTarget = this.activeTarget, i;
                if (scrollTop >= maxScroll) {
                    return activeTarget != (i = targets.last()[0]) && this.activate(i);
                }
                for (i = offsets.length; i--; ) {
                    activeTarget != targets[i] && scrollTop >= offsets[i] && (!offsets[i + 1] || scrollTop <= offsets[i + 1]) && this.activate(targets[i]);
                }
            },
            activate: function(target) {
                var active, selector;
                this.activeTarget = target;
                $(this.selector).parent(".active").removeClass("active");
                selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]';
                active = $(selector).parent("li").addClass("active");
                if (active.parent(".dropdown-menu").length) {
                    active = active.closest("li.dropdown").addClass("active");
                }
                active.trigger("activate");
            }
        };
        /* SCROLLSPY PLUGIN DEFINITION
  * =========================== */
        var old = $.fn.scrollspy;
        $.fn.scrollspy = function(option) {
            return this.each(function() {
                var $this = $(this), data = $this.data("scrollspy"), options = typeof option == "object" && option;
                if (!data) $this.data("scrollspy", data = new ScrollSpy(this, options));
                if (typeof option == "string") data[option]();
            });
        };
        $.fn.scrollspy.Constructor = ScrollSpy;
        $.fn.scrollspy.defaults = {
            offset: 10
        };
        /* SCROLLSPY NO CONFLICT
  * ===================== */
        $.fn.scrollspy.noConflict = function() {
            $.fn.scrollspy = old;
            return this;
        };
        /* SCROLLSPY DATA-API
  * ================== */
        $(window).on("load", function() {
            $('[data-spy="scroll"]').each(function() {
                var $spy = $(this);
                $spy.scrollspy($spy.data());
            });
        });
    }(window.jQuery);
    /* ========================================================
 * bootstrap-tab.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#tabs
 * ========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================== */
    !function($) {
        "use strict";
        // jshint ;_;
        /* TAB CLASS DEFINITION
  * ==================== */
        var Tab = function(element) {
            this.element = $(element);
        };
        Tab.prototype = {
            constructor: Tab,
            show: function() {
                var $this = this.element, $ul = $this.closest("ul:not(.dropdown-menu)"), selector = $this.attr("data-target"), previous, $target, e;
                if (!selector) {
                    selector = $this.attr("href");
                    selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "");
                }
                if ($this.parent("li").hasClass("active")) return;
                previous = $ul.find(".active:last a")[0];
                e = $.Event("show", {
                    relatedTarget: previous
                });
                $this.trigger(e);
                if (e.isDefaultPrevented()) return;
                $target = $(selector);
                this.activate($this.parent("li"), $ul);
                this.activate($target, $target.parent(), function() {
                    $this.trigger({
                        type: "shown",
                        relatedTarget: previous
                    });
                });
            },
            activate: function(element, container, callback) {
                var $active = container.find("> .active"), transition = callback && $.support.transition && $active.hasClass("fade");
                function next() {
                    $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active");
                    element.addClass("active");
                    if (transition) {
                        element[0].offsetWidth;
                        // reflow for transition
                        element.addClass("in");
                    } else {
                        element.removeClass("fade");
                    }
                    if (element.parent(".dropdown-menu")) {
                        element.closest("li.dropdown").addClass("active");
                    }
                    callback && callback();
                }
                transition ? $active.one($.support.transition.end, next) : next();
                $active.removeClass("in");
            }
        };
        /* TAB PLUGIN DEFINITION
  * ===================== */
        var old = $.fn.tab;
        $.fn.tab = function(option) {
            return this.each(function() {
                var $this = $(this), data = $this.data("tab");
                if (!data) $this.data("tab", data = new Tab(this));
                if (typeof option == "string") data[option]();
            });
        };
        $.fn.tab.Constructor = Tab;
        /* TAB NO CONFLICT
  * =============== */
        $.fn.tab.noConflict = function() {
            $.fn.tab = old;
            return this;
        };
        /* TAB DATA-API
  * ============ */
        $(document).on("click.tab.data-api", '[data-toggle="tab"], [data-toggle="pill"]', function(e) {
            e.preventDefault();
            $(this).tab("show");
        });
    }(window.jQuery);
    /* =============================================================
 * bootstrap-typeahead.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#typeahead
 * =============================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */
    !function($) {
        "use strict";
        // jshint ;_;
        /* TYPEAHEAD PUBLIC CLASS DEFINITION
  * ================================= */
        var Typeahead = function(element, options) {
            this.$element = $(element);
            this.options = $.extend({}, $.fn.typeahead.defaults, options);
            this.matcher = this.options.matcher || this.matcher;
            this.sorter = this.options.sorter || this.sorter;
            this.highlighter = this.options.highlighter || this.highlighter;
            this.updater = this.options.updater || this.updater;
            this.source = this.options.source;
            this.$menu = $(this.options.menu);
            this.shown = false;
            this.listen();
        };
        Typeahead.prototype = {
            constructor: Typeahead,
            select: function() {
                var val = this.$menu.find(".active").attr("data-value");
                this.$element.val(this.updater(val)).change();
                return this.hide();
            },
            updater: function(item) {
                return item;
            },
            show: function() {
                var pos = $.extend({}, this.$element.position(), {
                    height: this.$element[0].offsetHeight
                });
                this.$menu.insertAfter(this.$element).css({
                    top: pos.top + pos.height,
                    left: pos.left
                }).show();
                this.shown = true;
                return this;
            },
            hide: function() {
                this.$menu.hide();
                this.shown = false;
                return this;
            },
            lookup: function(event) {
                var items;
                this.query = this.$element.val();
                if (!this.query || this.query.length < this.options.minLength) {
                    return this.shown ? this.hide() : this;
                }
                items = $.isFunction(this.source) ? this.source(this.query, $.proxy(this.process, this)) : this.source;
                return items ? this.process(items) : this;
            },
            process: function(items) {
                var that = this;
                items = $.grep(items, function(item) {
                    return that.matcher(item);
                });
                items = this.sorter(items);
                if (!items.length) {
                    return this.shown ? this.hide() : this;
                }
                return this.render(items.slice(0, this.options.items)).show();
            },
            matcher: function(item) {
                return ~item.toLowerCase().indexOf(this.query.toLowerCase());
            },
            sorter: function(items) {
                var beginswith = [], caseSensitive = [], caseInsensitive = [], item;
                while (item = items.shift()) {
                    if (!item.toLowerCase().indexOf(this.query.toLowerCase())) beginswith.push(item); else if (~item.indexOf(this.query)) caseSensitive.push(item); else caseInsensitive.push(item);
                }
                return beginswith.concat(caseSensitive, caseInsensitive);
            },
            highlighter: function(item) {
                var query = this.query.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
                return item.replace(new RegExp("(" + query + ")", "ig"), function($1, match) {
                    return "<strong>" + match + "</strong>";
                });
            },
            render: function(items) {
                var that = this;
                items = $(items).map(function(i, item) {
                    i = $(that.options.item).attr("data-value", item);
                    i.find("a").html(that.highlighter(item));
                    return i[0];
                });
                items.first().addClass("active");
                this.$menu.html(items);
                return this;
            },
            next: function(event) {
                var active = this.$menu.find(".active").removeClass("active"), next = active.next();
                if (!next.length) {
                    next = $(this.$menu.find("li")[0]);
                }
                next.addClass("active");
            },
            prev: function(event) {
                var active = this.$menu.find(".active").removeClass("active"), prev = active.prev();
                if (!prev.length) {
                    prev = this.$menu.find("li").last();
                }
                prev.addClass("active");
            },
            listen: function() {
                this.$element.on("focus", $.proxy(this.focus, this)).on("blur", $.proxy(this.blur, this)).on("keypress", $.proxy(this.keypress, this)).on("keyup", $.proxy(this.keyup, this));
                if (this.eventSupported("keydown")) {
                    this.$element.on("keydown", $.proxy(this.keydown, this));
                }
                this.$menu.on("click", $.proxy(this.click, this)).on("mouseenter", "li", $.proxy(this.mouseenter, this)).on("mouseleave", "li", $.proxy(this.mouseleave, this));
            },
            eventSupported: function(eventName) {
                var isSupported = eventName in this.$element;
                if (!isSupported) {
                    this.$element.setAttribute(eventName, "return;");
                    isSupported = typeof this.$element[eventName] === "function";
                }
                return isSupported;
            },
            move: function(e) {
                if (!this.shown) return;
                switch (e.keyCode) {
                  case 9:
                  // tab
                    case 13:
                  // enter
                    case 27:
                    // escape
                    e.preventDefault();
                    break;

                  case 38:
                    // up arrow
                    e.preventDefault();
                    this.prev();
                    break;

                  case 40:
                    // down arrow
                    e.preventDefault();
                    this.next();
                    break;
                }
                e.stopPropagation();
            },
            keydown: function(e) {
                this.suppressKeyPressRepeat = ~$.inArray(e.keyCode, [ 40, 38, 9, 13, 27 ]);
                this.move(e);
            },
            keypress: function(e) {
                if (this.suppressKeyPressRepeat) return;
                this.move(e);
            },
            keyup: function(e) {
                switch (e.keyCode) {
                  case 40:
                  // down arrow
                    case 38:
                  // up arrow
                    case 16:
                  // shift
                    case 17:
                  // ctrl
                    case 18:
                    // alt
                    break;

                  case 9:
                  // tab
                    case 13:
                    // enter
                    if (!this.shown) return;
                    this.select();
                    break;

                  case 27:
                    // escape
                    if (!this.shown) return;
                    this.hide();
                    break;

                  default:
                    this.lookup();
                }
                e.stopPropagation();
                e.preventDefault();
            },
            focus: function(e) {
                this.focused = true;
            },
            blur: function(e) {
                this.focused = false;
                if (!this.mousedover && this.shown) this.hide();
            },
            click: function(e) {
                e.stopPropagation();
                e.preventDefault();
                this.select();
                this.$element.focus();
            },
            mouseenter: function(e) {
                this.mousedover = true;
                this.$menu.find(".active").removeClass("active");
                $(e.currentTarget).addClass("active");
            },
            mouseleave: function(e) {
                this.mousedover = false;
                if (!this.focused && this.shown) this.hide();
            }
        };
        /* TYPEAHEAD PLUGIN DEFINITION
   * =========================== */
        var old = $.fn.typeahead;
        $.fn.typeahead = function(option) {
            return this.each(function() {
                var $this = $(this), data = $this.data("typeahead"), options = typeof option == "object" && option;
                if (!data) $this.data("typeahead", data = new Typeahead(this, options));
                if (typeof option == "string") data[option]();
            });
        };
        $.fn.typeahead.defaults = {
            source: [],
            items: 8,
            menu: '<ul class="typeahead dropdown-menu"></ul>',
            item: '<li><a href="#"></a></li>',
            minLength: 1
        };
        $.fn.typeahead.Constructor = Typeahead;
        /* TYPEAHEAD NO CONFLICT
  * =================== */
        $.fn.typeahead.noConflict = function() {
            $.fn.typeahead = old;
            return this;
        };
        /* TYPEAHEAD DATA-API
  * ================== */
        $(document).on("focus.typeahead.data-api", '[data-provide="typeahead"]', function(e) {
            var $this = $(this);
            if ($this.data("typeahead")) return;
            $this.typeahead($this.data());
        });
    }(window.jQuery);
    /* ==========================================================
 * bootstrap-affix.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#affix
 * ==========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */
    !function($) {
        "use strict";
        // jshint ;_;
        /* AFFIX CLASS DEFINITION
  * ====================== */
        var Affix = function(element, options) {
            this.options = $.extend({}, $.fn.affix.defaults, options);
            this.$window = $(window).on("scroll.affix.data-api", $.proxy(this.checkPosition, this)).on("click.affix.data-api", $.proxy(function() {
                setTimeout($.proxy(this.checkPosition, this), 1);
            }, this));
            this.$element = $(element);
            this.checkPosition();
        };
        Affix.prototype.checkPosition = function() {
            if (!this.$element.is(":visible")) return;
            var scrollHeight = $(document).height(), scrollTop = this.$window.scrollTop(), position = this.$element.offset(), offset = this.options.offset, offsetBottom = offset.bottom, offsetTop = offset.top, reset = "affix affix-top affix-bottom", affix;
            if (typeof offset != "object") offsetBottom = offsetTop = offset;
            if (typeof offsetTop == "function") offsetTop = offset.top();
            if (typeof offsetBottom == "function") offsetBottom = offset.bottom();
            affix = this.unpin != null && scrollTop + this.unpin <= position.top ? false : offsetBottom != null && position.top + this.$element.height() >= scrollHeight - offsetBottom ? "bottom" : offsetTop != null && scrollTop <= offsetTop ? "top" : false;
            if (this.affixed === affix) return;
            this.affixed = affix;
            this.unpin = affix == "bottom" ? position.top - scrollTop : null;
            this.$element.removeClass(reset).addClass("affix" + (affix ? "-" + affix : ""));
        };
        /* AFFIX PLUGIN DEFINITION
  * ======================= */
        var old = $.fn.affix;
        $.fn.affix = function(option) {
            return this.each(function() {
                var $this = $(this), data = $this.data("affix"), options = typeof option == "object" && option;
                if (!data) $this.data("affix", data = new Affix(this, options));
                if (typeof option == "string") data[option]();
            });
        };
        $.fn.affix.Constructor = Affix;
        $.fn.affix.defaults = {
            offset: 0
        };
        /* AFFIX NO CONFLICT
  * ================= */
        $.fn.affix.noConflict = function() {
            $.fn.affix = old;
            return this;
        };
        /* AFFIX DATA-API
  * ============== */
        $(window).on("load", function() {
            $('[data-spy="affix"]').each(function() {
                var $spy = $(this), data = $spy.data();
                data.offset = data.offset || {};
                data.offsetBottom && (data.offset.bottom = data.offsetBottom);
                data.offsetTop && (data.offset.top = data.offsetTop);
                $spy.affix(data);
            });
        });
    }(window.jQuery);
});

define("jquery-plugin/form/3.44.0/form-debug", [ "$-debug" ], function(require) {
    var jQuery = require("$-debug");
    (function($) {
        "use strict";
        /*
        Usage Note:
        -----------
        Do not use both ajaxSubmit and ajaxForm on the same form.  These
        functions are mutually exclusive.  Use ajaxSubmit if you want
        to bind your own submit handler to the form.  For example,

        $(document).ready(function() {
            $('#myForm').on('submit', function(e) {
                e.preventDefault(); // <-- important
                $(this).ajaxSubmit({
                    target: '#output'
                });
            });
        });

        Use ajaxForm when you want the plugin to manage all the event binding
        for you.  For example,

        $(document).ready(function() {
            $('#myForm').ajaxForm({
                target: '#output'
            });
        });

        You can also use ajaxForm with delegation (requires jQuery v1.7+), so the
        form does not have to exist when you invoke ajaxForm:

        $('#myForm').ajaxForm({
            delegation: true,
            target: '#output'
        });

        When using ajaxForm, the ajaxSubmit function will be invoked for you
        at the appropriate time.
    */
        /**
     * Feature detection
     */
        var feature = {};
        feature.fileapi = $("<input type='file'/>").get(0).files !== undefined;
        feature.formdata = window.FormData !== undefined;
        var hasProp = !!$.fn.prop;
        // attr2 uses prop when it can but checks the return type for
        // an expected string.  this accounts for the case where a form 
        // contains inputs with names like "action" or "method"; in those
        // cases "prop" returns the element
        $.fn.attr2 = function() {
            if (!hasProp) return this.attr.apply(this, arguments);
            var val = this.prop.apply(this, arguments);
            if (val && val.jquery || typeof val === "string") return val;
            return this.attr.apply(this, arguments);
        };
        /**
     * ajaxSubmit() provides a mechanism for immediately submitting
     * an HTML form using AJAX.
     */
        $.fn.ajaxSubmit = function(options) {
            /*jshint scripturl:true */
            // fast fail if nothing selected (http://dev.jquery.com/ticket/2752)
            if (!this.length) {
                log("ajaxSubmit: skipping submit process - no element selected");
                return this;
            }
            var method, action, url, $form = this;
            if (typeof options == "function") {
                options = {
                    success: options
                };
            } else if (options === undefined) {
                options = {};
            }
            method = options.type || this.attr2("method");
            action = options.url || this.attr2("action");
            url = typeof action === "string" ? $.trim(action) : "";
            url = url || window.location.href || "";
            if (url) {
                // clean url (don't include hash vaue)
                url = (url.match(/^([^#]+)/) || [])[1];
            }
            options = $.extend(true, {
                url: url,
                success: $.ajaxSettings.success,
                type: method || $.ajaxSettings.type,
                iframeSrc: /^https/i.test(window.location.href || "") ? "javascript:false" : "about:blank"
            }, options);
            // hook for manipulating the form data before it is extracted;
            // convenient for use with rich editors like tinyMCE or FCKEditor
            var veto = {};
            this.trigger("form-pre-serialize", [ this, options, veto ]);
            if (veto.veto) {
                log("ajaxSubmit: submit vetoed via form-pre-serialize trigger");
                return this;
            }
            // provide opportunity to alter form data before it is serialized
            if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {
                log("ajaxSubmit: submit aborted via beforeSerialize callback");
                return this;
            }
            var traditional = options.traditional;
            if (traditional === undefined) {
                traditional = $.ajaxSettings.traditional;
            }
            var elements = [];
            var qx, a = this.formToArray(options.semantic, elements);
            if (options.data) {
                options.extraData = options.data;
                qx = $.param(options.data, traditional);
            }
            // give pre-submit callback an opportunity to abort the submit
            if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {
                log("ajaxSubmit: submit aborted via beforeSubmit callback");
                return this;
            }
            // fire vetoable 'validate' event
            this.trigger("form-submit-validate", [ a, this, options, veto ]);
            if (veto.veto) {
                log("ajaxSubmit: submit vetoed via form-submit-validate trigger");
                return this;
            }
            var q = $.param(a, traditional);
            if (qx) {
                q = q ? q + "&" + qx : qx;
            }
            if (options.type.toUpperCase() == "GET") {
                options.url += (options.url.indexOf("?") >= 0 ? "&" : "?") + q;
                options.data = null;
            } else {
                options.data = q;
            }
            var callbacks = [];
            if (options.resetForm) {
                callbacks.push(function() {
                    $form.resetForm();
                });
            }
            if (options.clearForm) {
                callbacks.push(function() {
                    $form.clearForm(options.includeHidden);
                });
            }
            // perform a load on the target only if dataType is not provided
            if (!options.dataType && options.target) {
                var oldSuccess = options.success || function() {};
                callbacks.push(function(data) {
                    var fn = options.replaceTarget ? "replaceWith" : "html";
                    $(options.target)[fn](data).each(oldSuccess, arguments);
                });
            } else if (options.success) {
                callbacks.push(options.success);
            }
            options.success = function(data, status, xhr) {
                // jQuery 1.4+ passes xhr as 3rd arg
                var context = options.context || this;
                // jQuery 1.4+ supports scope context
                for (var i = 0, max = callbacks.length; i < max; i++) {
                    callbacks[i].apply(context, [ data, status, xhr || $form, $form ]);
                }
            };
            if (options.error) {
                var oldError = options.error;
                options.error = function(xhr, status, error) {
                    var context = options.context || this;
                    oldError.apply(context, [ xhr, status, error, $form ]);
                };
            }
            if (options.complete) {
                var oldComplete = options.complete;
                options.complete = function(xhr, status) {
                    var context = options.context || this;
                    oldComplete.apply(context, [ xhr, status, $form ]);
                };
            }
            // are there files to upload?
            // [value] (issue #113), also see comment:
            // https://github.com/malsup/form/commit/588306aedba1de01388032d5f42a60159eea9228#commitcomment-2180219
            var fileInputs = $("input[type=file]:enabled", this).filter(function() {
                return $(this).val() !== "";
            });
            var hasFileInputs = fileInputs.length > 0;
            var mp = "multipart/form-data";
            var multipart = $form.attr("enctype") == mp || $form.attr("encoding") == mp;
            var fileAPI = feature.fileapi && feature.formdata;
            log("fileAPI :" + fileAPI);
            var shouldUseFrame = (hasFileInputs || multipart) && !fileAPI;
            var jqxhr;
            // options.iframe allows user to force iframe mode
            // 06-NOV-09: now defaulting to iframe mode if file input is detected
            if (options.iframe !== false && (options.iframe || shouldUseFrame)) {
                // hack to fix Safari hang (thanks to Tim Molendijk for this)
                // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
                if (options.closeKeepAlive) {
                    $.get(options.closeKeepAlive, function() {
                        jqxhr = fileUploadIframe(a);
                    });
                } else {
                    jqxhr = fileUploadIframe(a);
                }
            } else if ((hasFileInputs || multipart) && fileAPI) {
                jqxhr = fileUploadXhr(a);
            } else {
                jqxhr = $.ajax(options);
            }
            $form.removeData("jqxhr").data("jqxhr", jqxhr);
            // clear element array
            for (var k = 0; k < elements.length; k++) elements[k] = null;
            // fire 'notify' event
            this.trigger("form-submit-notify", [ this, options ]);
            return this;
            // utility fn for deep serialization
            function deepSerialize(extraData) {
                var serialized = $.param(extraData, options.traditional).split("&");
                var len = serialized.length;
                var result = [];
                var i, part;
                for (i = 0; i < len; i++) {
                    // #252; undo param space replacement
                    serialized[i] = serialized[i].replace(/\+/g, " ");
                    part = serialized[i].split("=");
                    // #278; use array instead of object storage, favoring array serializations
                    result.push([ decodeURIComponent(part[0]), decodeURIComponent(part[1]) ]);
                }
                return result;
            }
            // XMLHttpRequest Level 2 file uploads (big hat tip to francois2metz)
            function fileUploadXhr(a) {
                var formdata = new FormData();
                for (var i = 0; i < a.length; i++) {
                    formdata.append(a[i].name, a[i].value);
                }
                if (options.extraData) {
                    var serializedData = deepSerialize(options.extraData);
                    for (i = 0; i < serializedData.length; i++) if (serializedData[i]) formdata.append(serializedData[i][0], serializedData[i][1]);
                }
                options.data = null;
                var s = $.extend(true, {}, $.ajaxSettings, options, {
                    contentType: false,
                    processData: false,
                    cache: false,
                    type: method || "POST"
                });
                if (options.uploadProgress) {
                    // workaround because jqXHR does not expose upload property
                    s.xhr = function() {
                        var xhr = $.ajaxSettings.xhr();
                        if (xhr.upload) {
                            xhr.upload.addEventListener("progress", function(event) {
                                var percent = 0;
                                var position = event.loaded || event.position;
                                /*event.position is deprecated*/
                                var total = event.total;
                                if (event.lengthComputable) {
                                    percent = Math.ceil(position / total * 100);
                                }
                                options.uploadProgress(event, position, total, percent);
                            }, false);
                        }
                        return xhr;
                    };
                }
                s.data = null;
                var beforeSend = s.beforeSend;
                s.beforeSend = function(xhr, o) {
                    o.data = formdata;
                    if (beforeSend) beforeSend.call(this, xhr, o);
                };
                return $.ajax(s);
            }
            // private function for handling file uploads (hat tip to YAHOO!)
            function fileUploadIframe(a) {
                var form = $form[0], el, i, s, g, id, $io, io, xhr, sub, n, timedOut, timeoutHandle;
                var deferred = $.Deferred();
                // #341
                deferred.abort = function(status) {
                    xhr.abort(status);
                };
                if (a) {
                    // ensure that every serialized input is still enabled
                    for (i = 0; i < elements.length; i++) {
                        el = $(elements[i]);
                        if (hasProp) el.prop("disabled", false); else el.removeAttr("disabled");
                    }
                }
                s = $.extend(true, {}, $.ajaxSettings, options);
                s.context = s.context || s;
                id = "jqFormIO" + new Date().getTime();
                if (s.iframeTarget) {
                    $io = $(s.iframeTarget);
                    n = $io.attr2("name");
                    if (!n) $io.attr2("name", id); else id = n;
                } else {
                    $io = $('<iframe name="' + id + '" src="' + s.iframeSrc + '" />');
                    $io.css({
                        position: "absolute",
                        top: "-1000px",
                        left: "-1000px"
                    });
                }
                io = $io[0];
                xhr = {
                    // mock object
                    aborted: 0,
                    responseText: null,
                    responseXML: null,
                    status: 0,
                    statusText: "n/a",
                    getAllResponseHeaders: function() {},
                    getResponseHeader: function() {},
                    setRequestHeader: function() {},
                    abort: function(status) {
                        var e = status === "timeout" ? "timeout" : "aborted";
                        log("aborting upload... " + e);
                        this.aborted = 1;
                        try {
                            // #214, #257
                            if (io.contentWindow.document.execCommand) {
                                io.contentWindow.document.execCommand("Stop");
                            }
                        } catch (ignore) {}
                        $io.attr("src", s.iframeSrc);
                        // abort op in progress
                        xhr.error = e;
                        if (s.error) s.error.call(s.context, xhr, e, status);
                        if (g) $.event.trigger("ajaxError", [ xhr, s, e ]);
                        if (s.complete) s.complete.call(s.context, xhr, e);
                    }
                };
                g = s.global;
                // trigger ajax global events so that activity/block indicators work like normal
                if (g && 0 === $.active++) {
                    $.event.trigger("ajaxStart");
                }
                if (g) {
                    $.event.trigger("ajaxSend", [ xhr, s ]);
                }
                if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {
                    if (s.global) {
                        $.active--;
                    }
                    deferred.reject();
                    return deferred;
                }
                if (xhr.aborted) {
                    deferred.reject();
                    return deferred;
                }
                // add submitting element to data if we know it
                sub = form.clk;
                if (sub) {
                    n = sub.name;
                    if (n && !sub.disabled) {
                        s.extraData = s.extraData || {};
                        s.extraData[n] = sub.value;
                        if (sub.type == "image") {
                            s.extraData[n + ".x"] = form.clk_x;
                            s.extraData[n + ".y"] = form.clk_y;
                        }
                    }
                }
                var CLIENT_TIMEOUT_ABORT = 1;
                var SERVER_ABORT = 2;
                function getDoc(frame) {
                    /* it looks like contentWindow or contentDocument do not
                 * carry the protocol property in ie8, when running under ssl
                 * frame.document is the only valid response document, since
                 * the protocol is know but not on the other two objects. strange?
                 * "Same origin policy" http://en.wikipedia.org/wiki/Same_origin_policy
                 */
                    var doc = null;
                    // IE8 cascading access check
                    try {
                        if (frame.contentWindow) {
                            doc = frame.contentWindow.document;
                        }
                    } catch (err) {
                        // IE8 access denied under ssl & missing protocol
                        log("cannot get iframe.contentWindow document: " + err);
                    }
                    if (doc) {
                        // successful getting content
                        return doc;
                    }
                    try {
                        // simply checking may throw in ie8 under ssl or mismatched protocol
                        doc = frame.contentDocument ? frame.contentDocument : frame.document;
                    } catch (err) {
                        // last attempt
                        log("cannot get iframe.contentDocument: " + err);
                        doc = frame.document;
                    }
                    return doc;
                }
                // Rails CSRF hack (thanks to Yvan Barthelemy)
                var csrf_token = $("meta[name=csrf-token]").attr("content");
                var csrf_param = $("meta[name=csrf-param]").attr("content");
                if (csrf_param && csrf_token) {
                    s.extraData = s.extraData || {};
                    s.extraData[csrf_param] = csrf_token;
                }
                // take a breath so that pending repaints get some cpu time before the upload starts
                function doSubmit() {
                    // make sure form attrs are set
                    var t = $form.attr2("target"), a = $form.attr2("action");
                    // update form attrs in IE friendly way
                    form.setAttribute("target", id);
                    if (!method || /post/i.test(method)) {
                        form.setAttribute("method", "POST");
                    }
                    if (a != s.url) {
                        form.setAttribute("action", s.url);
                    }
                    // ie borks in some cases when setting encoding
                    if (!s.skipEncodingOverride && (!method || /post/i.test(method))) {
                        $form.attr({
                            encoding: "multipart/form-data",
                            enctype: "multipart/form-data"
                        });
                    }
                    // support timout
                    if (s.timeout) {
                        timeoutHandle = setTimeout(function() {
                            timedOut = true;
                            cb(CLIENT_TIMEOUT_ABORT);
                        }, s.timeout);
                    }
                    // look for server aborts
                    function checkState() {
                        try {
                            var state = getDoc(io).readyState;
                            log("state = " + state);
                            if (state && state.toLowerCase() == "uninitialized") setTimeout(checkState, 50);
                        } catch (e) {
                            log("Server abort: ", e, " (", e.name, ")");
                            cb(SERVER_ABORT);
                            if (timeoutHandle) clearTimeout(timeoutHandle);
                            timeoutHandle = undefined;
                        }
                    }
                    // add "extra" data to form if provided in options
                    var extraInputs = [];
                    try {
                        if (s.extraData) {
                            for (var n in s.extraData) {
                                if (s.extraData.hasOwnProperty(n)) {
                                    // if using the $.param format that allows for multiple values with the same name
                                    if ($.isPlainObject(s.extraData[n]) && s.extraData[n].hasOwnProperty("name") && s.extraData[n].hasOwnProperty("value")) {
                                        extraInputs.push($('<input type="hidden" name="' + s.extraData[n].name + '">').val(s.extraData[n].value).appendTo(form)[0]);
                                    } else {
                                        extraInputs.push($('<input type="hidden" name="' + n + '">').val(s.extraData[n]).appendTo(form)[0]);
                                    }
                                }
                            }
                        }
                        if (!s.iframeTarget) {
                            // add iframe to doc and submit the form
                            $io.appendTo("body");
                        }
                        if (io.attachEvent) io.attachEvent("onload", cb); else io.addEventListener("load", cb, false);
                        setTimeout(checkState, 15);
                        try {
                            form.submit();
                        } catch (err) {
                            // just in case form has element with name/id of 'submit'
                            var submitFn = document.createElement("form").submit;
                            submitFn.apply(form);
                        }
                    } finally {
                        // reset attrs and remove "extra" input elements
                        form.setAttribute("action", a);
                        if (t) {
                            form.setAttribute("target", t);
                        } else {
                            $form.removeAttr("target");
                        }
                        $(extraInputs).remove();
                    }
                }
                if (s.forceSync) {
                    doSubmit();
                } else {
                    setTimeout(doSubmit, 10);
                }
                var data, doc, domCheckCount = 50, callbackProcessed;
                function cb(e) {
                    if (xhr.aborted || callbackProcessed) {
                        return;
                    }
                    doc = getDoc(io);
                    if (!doc) {
                        log("cannot access response document");
                        e = SERVER_ABORT;
                    }
                    if (e === CLIENT_TIMEOUT_ABORT && xhr) {
                        xhr.abort("timeout");
                        deferred.reject(xhr, "timeout");
                        return;
                    } else if (e == SERVER_ABORT && xhr) {
                        xhr.abort("server abort");
                        deferred.reject(xhr, "error", "server abort");
                        return;
                    }
                    if (!doc || doc.location.href == s.iframeSrc) {
                        // response not received yet
                        if (!timedOut) return;
                    }
                    if (io.detachEvent) io.detachEvent("onload", cb); else io.removeEventListener("load", cb, false);
                    var status = "success", errMsg;
                    try {
                        if (timedOut) {
                            throw "timeout";
                        }
                        var isXml = s.dataType == "xml" || doc.XMLDocument || $.isXMLDoc(doc);
                        log("isXml=" + isXml);
                        if (!isXml && window.opera && (doc.body === null || !doc.body.innerHTML)) {
                            if (--domCheckCount) {
                                // in some browsers (Opera) the iframe DOM is not always traversable when
                                // the onload callback fires, so we loop a bit to accommodate
                                log("requeing onLoad callback, DOM not available");
                                setTimeout(cb, 250);
                                return;
                            }
                        }
                        //log('response detected');
                        var docRoot = doc.body ? doc.body : doc.documentElement;
                        xhr.responseText = docRoot ? docRoot.innerHTML : null;
                        xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;
                        if (isXml) s.dataType = "xml";
                        xhr.getResponseHeader = function(header) {
                            var headers = {
                                "content-type": s.dataType
                            };
                            return headers[header.toLowerCase()];
                        };
                        // support for XHR 'status' & 'statusText' emulation :
                        if (docRoot) {
                            xhr.status = Number(docRoot.getAttribute("status")) || xhr.status;
                            xhr.statusText = docRoot.getAttribute("statusText") || xhr.statusText;
                        }
                        var dt = (s.dataType || "").toLowerCase();
                        var scr = /(json|script|text)/.test(dt);
                        if (scr || s.textarea) {
                            // see if user embedded response in textarea
                            var ta = doc.getElementsByTagName("textarea")[0];
                            if (ta) {
                                xhr.responseText = ta.value;
                                // support for XHR 'status' & 'statusText' emulation :
                                xhr.status = Number(ta.getAttribute("status")) || xhr.status;
                                xhr.statusText = ta.getAttribute("statusText") || xhr.statusText;
                            } else if (scr) {
                                // account for browsers injecting pre around json response
                                var pre = doc.getElementsByTagName("pre")[0];
                                var b = doc.getElementsByTagName("body")[0];
                                if (pre) {
                                    xhr.responseText = pre.textContent ? pre.textContent : pre.innerText;
                                } else if (b) {
                                    xhr.responseText = b.textContent ? b.textContent : b.innerText;
                                }
                            }
                        } else if (dt == "xml" && !xhr.responseXML && xhr.responseText) {
                            xhr.responseXML = toXml(xhr.responseText);
                        }
                        try {
                            data = httpData(xhr, dt, s);
                        } catch (err) {
                            status = "parsererror";
                            xhr.error = errMsg = err || status;
                        }
                    } catch (err) {
                        log("error caught: ", err);
                        status = "error";
                        xhr.error = errMsg = err || status;
                    }
                    if (xhr.aborted) {
                        log("upload aborted");
                        status = null;
                    }
                    if (xhr.status) {
                        // we've set xhr.status
                        status = xhr.status >= 200 && xhr.status < 300 || xhr.status === 304 ? "success" : "error";
                    }
                    // ordering of these callbacks/triggers is odd, but that's how $.ajax does it
                    if (status === "success") {
                        if (s.success) s.success.call(s.context, data, "success", xhr);
                        deferred.resolve(xhr.responseText, "success", xhr);
                        if (g) $.event.trigger("ajaxSuccess", [ xhr, s ]);
                    } else if (status) {
                        if (errMsg === undefined) errMsg = xhr.statusText;
                        if (s.error) s.error.call(s.context, xhr, status, errMsg);
                        deferred.reject(xhr, "error", errMsg);
                        if (g) $.event.trigger("ajaxError", [ xhr, s, errMsg ]);
                    }
                    if (g) $.event.trigger("ajaxComplete", [ xhr, s ]);
                    if (g && !--$.active) {
                        $.event.trigger("ajaxStop");
                    }
                    if (s.complete) s.complete.call(s.context, xhr, status);
                    callbackProcessed = true;
                    if (s.timeout) clearTimeout(timeoutHandle);
                    // clean up
                    setTimeout(function() {
                        if (!s.iframeTarget) $io.remove(); else //adding else to clean up existing iframe response.
                        $io.attr("src", s.iframeSrc);
                        xhr.responseXML = null;
                    }, 100);
                }
                var toXml = $.parseXML || function(s, doc) {
                    // use parseXML if available (jQuery 1.5+)
                    if (window.ActiveXObject) {
                        doc = new ActiveXObject("Microsoft.XMLDOM");
                        doc.async = "false";
                        doc.loadXML(s);
                    } else {
                        doc = new DOMParser().parseFromString(s, "text/xml");
                    }
                    return doc && doc.documentElement && doc.documentElement.nodeName != "parsererror" ? doc : null;
                };
                var parseJSON = $.parseJSON || function(s) {
                    /*jslint evil:true */
                    return window["eval"]("(" + s + ")");
                };
                var httpData = function(xhr, type, s) {
                    // mostly lifted from jq1.4.4
                    var ct = xhr.getResponseHeader("content-type") || "", xml = type === "xml" || !type && ct.indexOf("xml") >= 0, data = xml ? xhr.responseXML : xhr.responseText;
                    if (xml && data.documentElement.nodeName === "parsererror") {
                        if ($.error) $.error("parsererror");
                    }
                    if (s && s.dataFilter) {
                        data = s.dataFilter(data, type);
                    }
                    if (typeof data === "string") {
                        if (type === "json" || !type && ct.indexOf("json") >= 0) {
                            data = parseJSON(data);
                        } else if (type === "script" || !type && ct.indexOf("javascript") >= 0) {
                            $.globalEval(data);
                        }
                    }
                    return data;
                };
                return deferred;
            }
        };
        /**
     * ajaxForm() provides a mechanism for fully automating form submission.
     *
     * The advantages of using this method instead of ajaxSubmit() are:
     *
     * 1: This method will include coordinates for <input type="image" /> elements (if the element
     *    is used to submit the form).
     * 2. This method will include the submit element's name/value data (for the element that was
     *    used to submit the form).
     * 3. This method binds the submit() method to the form for you.
     *
     * The options argument for ajaxForm works exactly as it does for ajaxSubmit.  ajaxForm merely
     * passes the options argument along after properly binding events for submit elements and
     * the form itself.
     */
        $.fn.ajaxForm = function(options) {
            options = options || {};
            options.delegation = options.delegation && $.isFunction($.fn.on);
            // in jQuery 1.3+ we can fix mistakes with the ready state
            if (!options.delegation && this.length === 0) {
                var o = {
                    s: this.selector,
                    c: this.context
                };
                if (!$.isReady && o.s) {
                    log("DOM not ready, queuing ajaxForm");
                    $(function() {
                        $(o.s, o.c).ajaxForm(options);
                    });
                    return this;
                }
                // is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()
                log("terminating; zero elements found by selector" + ($.isReady ? "" : " (DOM not ready)"));
                return this;
            }
            if (options.delegation) {
                $(document).off("submit.form-plugin", this.selector, doAjaxSubmit).off("click.form-plugin", this.selector, captureSubmittingElement).on("submit.form-plugin", this.selector, options, doAjaxSubmit).on("click.form-plugin", this.selector, options, captureSubmittingElement);
                return this;
            }
            return this.ajaxFormUnbind().bind("submit.form-plugin", options, doAjaxSubmit).bind("click.form-plugin", options, captureSubmittingElement);
        };
        // private event handlers
        function doAjaxSubmit(e) {
            /*jshint validthis:true */
            var options = e.data;
            if (!e.isDefaultPrevented()) {
                // if event has been canceled, don't proceed
                e.preventDefault();
                $(e.target).ajaxSubmit(options);
            }
        }
        function captureSubmittingElement(e) {
            /*jshint validthis:true */
            var target = e.target;
            var $el = $(target);
            if (!$el.is("[type=submit],[type=image]")) {
                // is this a child element of the submit el?  (ex: a span within a button)
                var t = $el.closest("[type=submit]");
                if (t.length === 0) {
                    return;
                }
                target = t[0];
            }
            var form = this;
            form.clk = target;
            if (target.type == "image") {
                if (e.offsetX !== undefined) {
                    form.clk_x = e.offsetX;
                    form.clk_y = e.offsetY;
                } else if (typeof $.fn.offset == "function") {
                    var offset = $el.offset();
                    form.clk_x = e.pageX - offset.left;
                    form.clk_y = e.pageY - offset.top;
                } else {
                    form.clk_x = e.pageX - target.offsetLeft;
                    form.clk_y = e.pageY - target.offsetTop;
                }
            }
            // clear form vars
            setTimeout(function() {
                form.clk = form.clk_x = form.clk_y = null;
            }, 100);
        }
        // ajaxFormUnbind unbinds the event handlers that were bound by ajaxForm
        $.fn.ajaxFormUnbind = function() {
            return this.unbind("submit.form-plugin click.form-plugin");
        };
        /**
     * formToArray() gathers form element data into an array of objects that can
     * be passed to any of the following ajax functions: $.get, $.post, or load.
     * Each object in the array has both a 'name' and 'value' property.  An example of
     * an array for a simple login form might be:
     *
     * [ { name: 'username', value: 'jresig' }, { name: 'password', value: 'secret' } ]
     *
     * It is this array that is passed to pre-submit callback functions provided to the
     * ajaxSubmit() and ajaxForm() methods.
     */
        $.fn.formToArray = function(semantic, elements) {
            var a = [];
            if (this.length === 0) {
                return a;
            }
            var form = this[0];
            var els = semantic ? form.getElementsByTagName("*") : form.elements;
            if (!els) {
                return a;
            }
            var i, j, n, v, el, max, jmax;
            for (i = 0, max = els.length; i < max; i++) {
                el = els[i];
                n = el.name;
                if (!n || el.disabled) {
                    continue;
                }
                if (semantic && form.clk && el.type == "image") {
                    // handle image inputs on the fly when semantic == true
                    if (form.clk == el) {
                        a.push({
                            name: n,
                            value: $(el).val(),
                            type: el.type
                        });
                        a.push({
                            name: n + ".x",
                            value: form.clk_x
                        }, {
                            name: n + ".y",
                            value: form.clk_y
                        });
                    }
                    continue;
                }
                v = $.fieldValue(el, true);
                if (v && v.constructor == Array) {
                    if (elements) elements.push(el);
                    for (j = 0, jmax = v.length; j < jmax; j++) {
                        a.push({
                            name: n,
                            value: v[j]
                        });
                    }
                } else if (feature.fileapi && el.type == "file") {
                    if (elements) elements.push(el);
                    var files = el.files;
                    if (files.length) {
                        for (j = 0; j < files.length; j++) {
                            a.push({
                                name: n,
                                value: files[j],
                                type: el.type
                            });
                        }
                    } else {
                        // #180
                        a.push({
                            name: n,
                            value: "",
                            type: el.type
                        });
                    }
                } else if (v !== null && typeof v != "undefined") {
                    if (elements) elements.push(el);
                    a.push({
                        name: n,
                        value: v,
                        type: el.type,
                        required: el.required
                    });
                }
            }
            if (!semantic && form.clk) {
                // input type=='image' are not found in elements array! handle it here
                var $input = $(form.clk), input = $input[0];
                n = input.name;
                if (n && !input.disabled && input.type == "image") {
                    a.push({
                        name: n,
                        value: $input.val()
                    });
                    a.push({
                        name: n + ".x",
                        value: form.clk_x
                    }, {
                        name: n + ".y",
                        value: form.clk_y
                    });
                }
            }
            return a;
        };
        /**
     * Serializes form data into a 'submittable' string. This method will return a string
     * in the format: name1=value1&amp;name2=value2
     */
        $.fn.formSerialize = function(semantic) {
            //hand off to jQuery.param for proper encoding
            return $.param(this.formToArray(semantic));
        };
        /**
     * Serializes all field elements in the jQuery object into a query string.
     * This method will return a string in the format: name1=value1&amp;name2=value2
     */
        $.fn.fieldSerialize = function(successful) {
            var a = [];
            this.each(function() {
                var n = this.name;
                if (!n) {
                    return;
                }
                var v = $.fieldValue(this, successful);
                if (v && v.constructor == Array) {
                    for (var i = 0, max = v.length; i < max; i++) {
                        a.push({
                            name: n,
                            value: v[i]
                        });
                    }
                } else if (v !== null && typeof v != "undefined") {
                    a.push({
                        name: this.name,
                        value: v
                    });
                }
            });
            //hand off to jQuery.param for proper encoding
            return $.param(a);
        };
        /**
     * Returns the value(s) of the element in the matched set.  For example, consider the following form:
     *
     *  <form><fieldset>
     *      <input name="A" type="text" />
     *      <input name="A" type="text" />
     *      <input name="B" type="checkbox" value="B1" />
     *      <input name="B" type="checkbox" value="B2"/>
     *      <input name="C" type="radio" value="C1" />
     *      <input name="C" type="radio" value="C2" />
     *  </fieldset></form>
     *
     *  var v = $('input[type=text]').fieldValue();
     *  // if no values are entered into the text inputs
     *  v == ['','']
     *  // if values entered into the text inputs are 'foo' and 'bar'
     *  v == ['foo','bar']
     *
     *  var v = $('input[type=checkbox]').fieldValue();
     *  // if neither checkbox is checked
     *  v === undefined
     *  // if both checkboxes are checked
     *  v == ['B1', 'B2']
     *
     *  var v = $('input[type=radio]').fieldValue();
     *  // if neither radio is checked
     *  v === undefined
     *  // if first radio is checked
     *  v == ['C1']
     *
     * The successful argument controls whether or not the field element must be 'successful'
     * (per http://www.w3.org/TR/html4/interact/forms.html#successful-controls).
     * The default value of the successful argument is true.  If this value is false the value(s)
     * for each element is returned.
     *
     * Note: This method *always* returns an array.  If no valid value can be determined the
     *    array will be empty, otherwise it will contain one or more values.
     */
        $.fn.fieldValue = function(successful) {
            for (var val = [], i = 0, max = this.length; i < max; i++) {
                var el = this[i];
                var v = $.fieldValue(el, successful);
                if (v === null || typeof v == "undefined" || v.constructor == Array && !v.length) {
                    continue;
                }
                if (v.constructor == Array) $.merge(val, v); else val.push(v);
            }
            return val;
        };
        /**
     * Returns the value of the field element.
     */
        $.fieldValue = function(el, successful) {
            var n = el.name, t = el.type, tag = el.tagName.toLowerCase();
            if (successful === undefined) {
                successful = true;
            }
            if (successful && (!n || el.disabled || t == "reset" || t == "button" || (t == "checkbox" || t == "radio") && !el.checked || (t == "submit" || t == "image") && el.form && el.form.clk != el || tag == "select" && el.selectedIndex == -1)) {
                return null;
            }
            if (tag == "select") {
                var index = el.selectedIndex;
                if (index < 0) {
                    return null;
                }
                var a = [], ops = el.options;
                var one = t == "select-one";
                var max = one ? index + 1 : ops.length;
                for (var i = one ? index : 0; i < max; i++) {
                    var op = ops[i];
                    if (op.selected) {
                        var v = op.value;
                        if (!v) {
                            // extra pain for IE...
                            v = op.attributes && op.attributes["value"] && !op.attributes["value"].specified ? op.text : op.value;
                        }
                        if (one) {
                            return v;
                        }
                        a.push(v);
                    }
                }
                return a;
            }
            return $(el).val();
        };
        /**
     * Clears the form data.  Takes the following actions on the form's input fields:
     *  - input text fields will have their 'value' property set to the empty string
     *  - select elements will have their 'selectedIndex' property set to -1
     *  - checkbox and radio inputs will have their 'checked' property set to false
     *  - inputs of type submit, button, reset, and hidden will *not* be effected
     *  - button elements will *not* be effected
     */
        $.fn.clearForm = function(includeHidden) {
            return this.each(function() {
                $("input,select,textarea", this).clearFields(includeHidden);
            });
        };
        /**
     * Clears the selected form elements.
     */
        $.fn.clearFields = $.fn.clearInputs = function(includeHidden) {
            var re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i;
            // 'hidden' is not in this list
            return this.each(function() {
                var t = this.type, tag = this.tagName.toLowerCase();
                if (re.test(t) || tag == "textarea") {
                    this.value = "";
                } else if (t == "checkbox" || t == "radio") {
                    this.checked = false;
                } else if (tag == "select") {
                    this.selectedIndex = -1;
                } else if (t == "file") {
                    if (/MSIE/.test(navigator.userAgent)) {
                        $(this).replaceWith($(this).clone(true));
                    } else {
                        $(this).val("");
                    }
                } else if (includeHidden) {
                    // includeHidden can be the value true, or it can be a selector string
                    // indicating a special test; for example:
                    //  $('#myForm').clearForm('.special:hidden')
                    // the above would clean hidden inputs that have the class of 'special'
                    if (includeHidden === true && /hidden/.test(t) || typeof includeHidden == "string" && $(this).is(includeHidden)) this.value = "";
                }
            });
        };
        /**
     * Resets the form data.  Causes all form elements to be reset to their original value.
     */
        $.fn.resetForm = function() {
            return this.each(function() {
                // guard against an input with the name of 'reset'
                // note that IE reports the reset function as an 'object'
                if (typeof this.reset == "function" || typeof this.reset == "object" && !this.reset.nodeType) {
                    this.reset();
                }
            });
        };
        /**
     * Enables or disables any matching elements.
     */
        $.fn.enable = function(b) {
            if (b === undefined) {
                b = true;
            }
            return this.each(function() {
                this.disabled = !b;
            });
        };
        /**
     * Checks/unchecks any matching checkboxes or radio buttons and
     * selects/deselects and matching option elements.
     */
        $.fn.selected = function(select) {
            if (select === undefined) {
                select = true;
            }
            return this.each(function() {
                var t = this.type;
                if (t == "checkbox" || t == "radio") {
                    this.checked = select;
                } else if (this.tagName.toLowerCase() == "option") {
                    var $sel = $(this).parent("select");
                    if (select && $sel[0] && $sel[0].type == "select-one") {
                        // deselect all other options
                        $sel.find("option").selected(false);
                    }
                    this.selected = select;
                }
            });
        };
        // expose debug var
        $.fn.ajaxSubmit.debug = false;
        // helper fn for console logging
        function log() {
            if (!$.fn.ajaxSubmit.debug) return;
            var msg = "[jquery.form] " + Array.prototype.join.call(arguments, "");
            if (window.console && window.console.log) {
                window.console.log(msg);
            } else if (window.opera && window.opera.postError) {
                window.opera.postError(msg);
            }
        }
    })(typeof jQuery != "undefined" ? jQuery : window.Zepto);
});

define("gallery/backbone/1.0.0/backbone-debug", [ "gallery/underscore/1.4.4/underscore", "$" ], function(require, exports) {
    var previousUnderscore = this._;
    var previousJQuery = this.jQuery;
    this._ = require("gallery/underscore/1.4.4/underscore");
    this.jQuery = require("$");
    //     Backbone.js 1.0.0
    //     (c) 2010-2013 Jeremy Ashkenas, DocumentCloud Inc.
    //     Backbone may be freely distributed under the MIT license.
    //     For all details and documentation:
    //     http://backbonejs.org
    (function() {
        // Initial Setup
        // -------------
        // Save a reference to the global object (`window` in the browser, `exports`
        // on the server).
        var root = this;
        // Save the previous value of the `Backbone` variable, so that it can be
        // restored later on, if `noConflict` is used.
        var previousBackbone = root.Backbone;
        // Create local references to array methods we'll want to use later.
        var array = [];
        var push = array.push;
        var slice = array.slice;
        var splice = array.splice;
        // The top-level namespace. All public Backbone classes and modules will
        // be attached to this. Exported for both the browser and the server.
        var Backbone;
        if (typeof exports !== "undefined") {
            Backbone = exports;
        } else {
            Backbone = root.Backbone = {};
        }
        // Current version of the library. Keep in sync with `package.json`.
        Backbone.VERSION = "1.0.0";
        // Require Underscore, if we're on the server, and it's not already present.
        var _ = root._;
        if (!_ && typeof require !== "undefined") _ = require("gallery/underscore/1.4.4/underscore");
        // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
        // the `$` variable.
        Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;
        // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
        // to its previous owner. Returns a reference to this Backbone object.
        Backbone.noConflict = function() {
            root.Backbone = previousBackbone;
            return this;
        };
        // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
        // will fake `"PUT"` and `"DELETE"` requests via the `_method` parameter and
        // set a `X-Http-Method-Override` header.
        Backbone.emulateHTTP = false;
        // Turn on `emulateJSON` to support legacy servers that can't deal with direct
        // `application/json` requests ... will encode the body as
        // `application/x-www-form-urlencoded` instead and will send the model in a
        // form param named `model`.
        Backbone.emulateJSON = false;
        // Backbone.Events
        // ---------------
        // A module that can be mixed in to *any object* in order to provide it with
        // custom events. You may bind with `on` or remove with `off` callback
        // functions to an event; `trigger`-ing an event fires all callbacks in
        // succession.
        //
        //     var object = {};
        //     _.extend(object, Backbone.Events);
        //     object.on('expand', function(){ alert('expanded'); });
        //     object.trigger('expand');
        //
        var Events = Backbone.Events = {
            // Bind an event to a `callback` function. Passing `"all"` will bind
            // the callback to all events fired.
            on: function(name, callback, context) {
                if (!eventsApi(this, "on", name, [ callback, context ]) || !callback) return this;
                this._events || (this._events = {});
                var events = this._events[name] || (this._events[name] = []);
                events.push({
                    callback: callback,
                    context: context,
                    ctx: context || this
                });
                return this;
            },
            // Bind an event to only be triggered a single time. After the first time
            // the callback is invoked, it will be removed.
            once: function(name, callback, context) {
                if (!eventsApi(this, "once", name, [ callback, context ]) || !callback) return this;
                var self = this;
                var once = _.once(function() {
                    self.off(name, once);
                    callback.apply(this, arguments);
                });
                once._callback = callback;
                return this.on(name, once, context);
            },
            // Remove one or many callbacks. If `context` is null, removes all
            // callbacks with that function. If `callback` is null, removes all
            // callbacks for the event. If `name` is null, removes all bound
            // callbacks for all events.
            off: function(name, callback, context) {
                var retain, ev, events, names, i, l, j, k;
                if (!this._events || !eventsApi(this, "off", name, [ callback, context ])) return this;
                if (!name && !callback && !context) {
                    this._events = {};
                    return this;
                }
                names = name ? [ name ] : _.keys(this._events);
                for (i = 0, l = names.length; i < l; i++) {
                    name = names[i];
                    if (events = this._events[name]) {
                        this._events[name] = retain = [];
                        if (callback || context) {
                            for (j = 0, k = events.length; j < k; j++) {
                                ev = events[j];
                                if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {
                                    retain.push(ev);
                                }
                            }
                        }
                        if (!retain.length) delete this._events[name];
                    }
                }
                return this;
            },
            // Trigger one or many events, firing all bound callbacks. Callbacks are
            // passed the same arguments as `trigger` is, apart from the event name
            // (unless you're listening on `"all"`, which will cause your callback to
            // receive the true name of the event as the first argument).
            trigger: function(name) {
                if (!this._events) return this;
                var args = slice.call(arguments, 1);
                if (!eventsApi(this, "trigger", name, args)) return this;
                var events = this._events[name];
                var allEvents = this._events.all;
                if (events) triggerEvents(events, args);
                if (allEvents) triggerEvents(allEvents, arguments);
                return this;
            },
            // Tell this object to stop listening to either specific events ... or
            // to every object it's currently listening to.
            stopListening: function(obj, name, callback) {
                var listeners = this._listeners;
                if (!listeners) return this;
                var deleteListener = !name && !callback;
                if (typeof name === "object") callback = this;
                if (obj) (listeners = {})[obj._listenerId] = obj;
                for (var id in listeners) {
                    listeners[id].off(name, callback, this);
                    if (deleteListener) delete this._listeners[id];
                }
                return this;
            }
        };
        // Regular expression used to split event strings.
        var eventSplitter = /\s+/;
        // Implement fancy features of the Events API such as multiple event
        // names `"change blur"` and jQuery-style event maps `{change: action}`
        // in terms of the existing API.
        var eventsApi = function(obj, action, name, rest) {
            if (!name) return true;
            // Handle event maps.
            if (typeof name === "object") {
                for (var key in name) {
                    obj[action].apply(obj, [ key, name[key] ].concat(rest));
                }
                return false;
            }
            // Handle space separated event names.
            if (eventSplitter.test(name)) {
                var names = name.split(eventSplitter);
                for (var i = 0, l = names.length; i < l; i++) {
                    obj[action].apply(obj, [ names[i] ].concat(rest));
                }
                return false;
            }
            return true;
        };
        // A difficult-to-believe, but optimized internal dispatch function for
        // triggering events. Tries to keep the usual cases speedy (most internal
        // Backbone events have 3 arguments).
        var triggerEvents = function(events, args) {
            var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
            switch (args.length) {
              case 0:
                while (++i < l) (ev = events[i]).callback.call(ev.ctx);
                return;

              case 1:
                while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1);
                return;

              case 2:
                while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2);
                return;

              case 3:
                while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
                return;

              default:
                while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
            }
        };
        var listenMethods = {
            listenTo: "on",
            listenToOnce: "once"
        };
        // Inversion-of-control versions of `on` and `once`. Tell *this* object to
        // listen to an event in another object ... keeping track of what it's
        // listening to.
        _.each(listenMethods, function(implementation, method) {
            Events[method] = function(obj, name, callback) {
                var listeners = this._listeners || (this._listeners = {});
                var id = obj._listenerId || (obj._listenerId = _.uniqueId("l"));
                listeners[id] = obj;
                if (typeof name === "object") callback = this;
                obj[implementation](name, callback, this);
                return this;
            };
        });
        // Aliases for backwards compatibility.
        Events.bind = Events.on;
        Events.unbind = Events.off;
        // Allow the `Backbone` object to serve as a global event bus, for folks who
        // want global "pubsub" in a convenient place.
        _.extend(Backbone, Events);
        // Backbone.Model
        // --------------
        // Backbone **Models** are the basic data object in the framework --
        // frequently representing a row in a table in a database on your server.
        // A discrete chunk of data and a bunch of useful, related methods for
        // performing computations and transformations on that data.
        // Create a new model with the specified attributes. A client id (`cid`)
        // is automatically generated and assigned for you.
        var Model = Backbone.Model = function(attributes, options) {
            var defaults;
            var attrs = attributes || {};
            options || (options = {});
            this.cid = _.uniqueId("c");
            this.attributes = {};
            _.extend(this, _.pick(options, modelOptions));
            if (options.parse) attrs = this.parse(attrs, options) || {};
            if (defaults = _.result(this, "defaults")) {
                attrs = _.defaults({}, attrs, defaults);
            }
            this.set(attrs, options);
            this.changed = {};
            this.initialize.apply(this, arguments);
        };
        // A list of options to be attached directly to the model, if provided.
        var modelOptions = [ "url", "urlRoot", "collection" ];
        // Attach all inheritable methods to the Model prototype.
        _.extend(Model.prototype, Events, {
            // A hash of attributes whose current and previous value differ.
            changed: null,
            // The value returned during the last failed validation.
            validationError: null,
            // The default name for the JSON `id` attribute is `"id"`. MongoDB and
            // CouchDB users may want to set this to `"_id"`.
            idAttribute: "id",
            // Initialize is an empty function by default. Override it with your own
            // initialization logic.
            initialize: function() {},
            // Return a copy of the model's `attributes` object.
            toJSON: function(options) {
                return _.clone(this.attributes);
            },
            // Proxy `Backbone.sync` by default -- but override this if you need
            // custom syncing semantics for *this* particular model.
            sync: function() {
                return Backbone.sync.apply(this, arguments);
            },
            // Get the value of an attribute.
            get: function(attr) {
                return this.attributes[attr];
            },
            // Get the HTML-escaped value of an attribute.
            escape: function(attr) {
                return _.escape(this.get(attr));
            },
            // Returns `true` if the attribute contains a value that is not null
            // or undefined.
            has: function(attr) {
                return this.get(attr) != null;
            },
            // Set a hash of model attributes on the object, firing `"change"`. This is
            // the core primitive operation of a model, updating the data and notifying
            // anyone who needs to know about the change in state. The heart of the beast.
            set: function(key, val, options) {
                var attr, attrs, unset, changes, silent, changing, prev, current;
                if (key == null) return this;
                // Handle both `"key", value` and `{key: value}` -style arguments.
                if (typeof key === "object") {
                    attrs = key;
                    options = val;
                } else {
                    (attrs = {})[key] = val;
                }
                options || (options = {});
                // Run validation.
                if (!this._validate(attrs, options)) return false;
                // Extract attributes and options.
                unset = options.unset;
                silent = options.silent;
                changes = [];
                changing = this._changing;
                this._changing = true;
                if (!changing) {
                    this._previousAttributes = _.clone(this.attributes);
                    this.changed = {};
                }
                current = this.attributes, prev = this._previousAttributes;
                // Check for changes of `id`.
                if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];
                // For each `set` attribute, update or delete the current value.
                for (attr in attrs) {
                    val = attrs[attr];
                    if (!_.isEqual(current[attr], val)) changes.push(attr);
                    if (!_.isEqual(prev[attr], val)) {
                        this.changed[attr] = val;
                    } else {
                        delete this.changed[attr];
                    }
                    unset ? delete current[attr] : current[attr] = val;
                }
                // Trigger all relevant attribute changes.
                if (!silent) {
                    if (changes.length) this._pending = true;
                    for (var i = 0, l = changes.length; i < l; i++) {
                        this.trigger("change:" + changes[i], this, current[changes[i]], options);
                    }
                }
                // You might be wondering why there's a `while` loop here. Changes can
                // be recursively nested within `"change"` events.
                if (changing) return this;
                if (!silent) {
                    while (this._pending) {
                        this._pending = false;
                        this.trigger("change", this, options);
                    }
                }
                this._pending = false;
                this._changing = false;
                return this;
            },
            // Remove an attribute from the model, firing `"change"`. `unset` is a noop
            // if the attribute doesn't exist.
            unset: function(attr, options) {
                return this.set(attr, void 0, _.extend({}, options, {
                    unset: true
                }));
            },
            // Clear all attributes on the model, firing `"change"`.
            clear: function(options) {
                var attrs = {};
                for (var key in this.attributes) attrs[key] = void 0;
                return this.set(attrs, _.extend({}, options, {
                    unset: true
                }));
            },
            // Determine if the model has changed since the last `"change"` event.
            // If you specify an attribute name, determine if that attribute has changed.
            hasChanged: function(attr) {
                if (attr == null) return !_.isEmpty(this.changed);
                return _.has(this.changed, attr);
            },
            // Return an object containing all the attributes that have changed, or
            // false if there are no changed attributes. Useful for determining what
            // parts of a view need to be updated and/or what attributes need to be
            // persisted to the server. Unset attributes will be set to undefined.
            // You can also pass an attributes object to diff against the model,
            // determining if there *would be* a change.
            changedAttributes: function(diff) {
                if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
                var val, changed = false;
                var old = this._changing ? this._previousAttributes : this.attributes;
                for (var attr in diff) {
                    if (_.isEqual(old[attr], val = diff[attr])) continue;
                    (changed || (changed = {}))[attr] = val;
                }
                return changed;
            },
            // Get the previous value of an attribute, recorded at the time the last
            // `"change"` event was fired.
            previous: function(attr) {
                if (attr == null || !this._previousAttributes) return null;
                return this._previousAttributes[attr];
            },
            // Get all of the attributes of the model at the time of the previous
            // `"change"` event.
            previousAttributes: function() {
                return _.clone(this._previousAttributes);
            },
            // Fetch the model from the server. If the server's representation of the
            // model differs from its current attributes, they will be overridden,
            // triggering a `"change"` event.
            fetch: function(options) {
                options = options ? _.clone(options) : {};
                if (options.parse === void 0) options.parse = true;
                var model = this;
                var success = options.success;
                options.success = function(resp) {
                    if (!model.set(model.parse(resp, options), options)) return false;
                    if (success) success(model, resp, options);
                    model.trigger("sync", model, resp, options);
                };
                wrapError(this, options);
                return this.sync("read", this, options);
            },
            // Set a hash of model attributes, and sync the model to the server.
            // If the server returns an attributes hash that differs, the model's
            // state will be `set` again.
            save: function(key, val, options) {
                var attrs, method, xhr, attributes = this.attributes;
                // Handle both `"key", value` and `{key: value}` -style arguments.
                if (key == null || typeof key === "object") {
                    attrs = key;
                    options = val;
                } else {
                    (attrs = {})[key] = val;
                }
                // If we're not waiting and attributes exist, save acts as `set(attr).save(null, opts)`.
                if (attrs && (!options || !options.wait) && !this.set(attrs, options)) return false;
                options = _.extend({
                    validate: true
                }, options);
                // Do not persist invalid models.
                if (!this._validate(attrs, options)) return false;
                // Set temporary attributes if `{wait: true}`.
                if (attrs && options.wait) {
                    this.attributes = _.extend({}, attributes, attrs);
                }
                // After a successful server-side save, the client is (optionally)
                // updated with the server-side state.
                if (options.parse === void 0) options.parse = true;
                var model = this;
                var success = options.success;
                options.success = function(resp) {
                    // Ensure attributes are restored during synchronous saves.
                    model.attributes = attributes;
                    var serverAttrs = model.parse(resp, options);
                    if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
                    if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
                        return false;
                    }
                    if (success) success(model, resp, options);
                    model.trigger("sync", model, resp, options);
                };
                wrapError(this, options);
                method = this.isNew() ? "create" : options.patch ? "patch" : "update";
                if (method === "patch") options.attrs = attrs;
                xhr = this.sync(method, this, options);
                // Restore attributes.
                if (attrs && options.wait) this.attributes = attributes;
                return xhr;
            },
            // Destroy this model on the server if it was already persisted.
            // Optimistically removes the model from its collection, if it has one.
            // If `wait: true` is passed, waits for the server to respond before removal.
            destroy: function(options) {
                options = options ? _.clone(options) : {};
                var model = this;
                var success = options.success;
                var destroy = function() {
                    model.trigger("destroy", model, model.collection, options);
                };
                options.success = function(resp) {
                    if (options.wait || model.isNew()) destroy();
                    if (success) success(model, resp, options);
                    if (!model.isNew()) model.trigger("sync", model, resp, options);
                };
                if (this.isNew()) {
                    options.success();
                    return false;
                }
                wrapError(this, options);
                var xhr = this.sync("delete", this, options);
                if (!options.wait) destroy();
                return xhr;
            },
            // Default URL for the model's representation on the server -- if you're
            // using Backbone's restful methods, override this to change the endpoint
            // that will be called.
            url: function() {
                var base = _.result(this, "urlRoot") || _.result(this.collection, "url") || urlError();
                if (this.isNew()) return base;
                return base + (base.charAt(base.length - 1) === "/" ? "" : "/") + encodeURIComponent(this.id);
            },
            // **parse** converts a response into the hash of attributes to be `set` on
            // the model. The default implementation is just to pass the response along.
            parse: function(resp, options) {
                return resp;
            },
            // Create a new model with identical attributes to this one.
            clone: function() {
                return new this.constructor(this.attributes);
            },
            // A model is new if it has never been saved to the server, and lacks an id.
            isNew: function() {
                return this.id == null;
            },
            // Check if the model is currently in a valid state.
            isValid: function(options) {
                return this._validate({}, _.extend(options || {}, {
                    validate: true
                }));
            },
            // Run validation against the next complete set of model attributes,
            // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
            _validate: function(attrs, options) {
                if (!options.validate || !this.validate) return true;
                attrs = _.extend({}, this.attributes, attrs);
                var error = this.validationError = this.validate(attrs, options) || null;
                if (!error) return true;
                this.trigger("invalid", this, error, _.extend(options || {}, {
                    validationError: error
                }));
                return false;
            }
        });
        // Underscore methods that we want to implement on the Model.
        var modelMethods = [ "keys", "values", "pairs", "invert", "pick", "omit" ];
        // Mix in each Underscore method as a proxy to `Model#attributes`.
        _.each(modelMethods, function(method) {
            Model.prototype[method] = function() {
                var args = slice.call(arguments);
                args.unshift(this.attributes);
                return _[method].apply(_, args);
            };
        });
        // Backbone.Collection
        // -------------------
        // If models tend to represent a single row of data, a Backbone Collection is
        // more analagous to a table full of data ... or a small slice or page of that
        // table, or a collection of rows that belong together for a particular reason
        // -- all of the messages in this particular folder, all of the documents
        // belonging to this particular author, and so on. Collections maintain
        // indexes of their models, both in order, and for lookup by `id`.
        // Create a new **Collection**, perhaps to contain a specific type of `model`.
        // If a `comparator` is specified, the Collection will maintain
        // its models in sort order, as they're added and removed.
        var Collection = Backbone.Collection = function(models, options) {
            options || (options = {});
            if (options.url) this.url = options.url;
            if (options.model) this.model = options.model;
            if (options.comparator !== void 0) this.comparator = options.comparator;
            this._reset();
            this.initialize.apply(this, arguments);
            if (models) this.reset(models, _.extend({
                silent: true
            }, options));
        };
        // Default options for `Collection#set`.
        var setOptions = {
            add: true,
            remove: true,
            merge: true
        };
        var addOptions = {
            add: true,
            merge: false,
            remove: false
        };
        // Define the Collection's inheritable methods.
        _.extend(Collection.prototype, Events, {
            // The default model for a collection is just a **Backbone.Model**.
            // This should be overridden in most cases.
            model: Model,
            // Initialize is an empty function by default. Override it with your own
            // initialization logic.
            initialize: function() {},
            // The JSON representation of a Collection is an array of the
            // models' attributes.
            toJSON: function(options) {
                return this.map(function(model) {
                    return model.toJSON(options);
                });
            },
            // Proxy `Backbone.sync` by default.
            sync: function() {
                return Backbone.sync.apply(this, arguments);
            },
            // Add a model, or list of models to the set.
            add: function(models, options) {
                return this.set(models, _.defaults(options || {}, addOptions));
            },
            // Remove a model, or a list of models from the set.
            remove: function(models, options) {
                models = _.isArray(models) ? models.slice() : [ models ];
                options || (options = {});
                var i, l, index, model;
                for (i = 0, l = models.length; i < l; i++) {
                    model = this.get(models[i]);
                    if (!model) continue;
                    delete this._byId[model.id];
                    delete this._byId[model.cid];
                    index = this.indexOf(model);
                    this.models.splice(index, 1);
                    this.length--;
                    if (!options.silent) {
                        options.index = index;
                        model.trigger("remove", model, this, options);
                    }
                    this._removeReference(model);
                }
                return this;
            },
            // Update a collection by `set`-ing a new list of models, adding new ones,
            // removing models that are no longer present, and merging models that
            // already exist in the collection, as necessary. Similar to **Model#set**,
            // the core operation for updating the data contained by the collection.
            set: function(models, options) {
                options = _.defaults(options || {}, setOptions);
                if (options.parse) models = this.parse(models, options);
                if (!_.isArray(models)) models = models ? [ models ] : [];
                var i, l, model, attrs, existing, sort;
                var at = options.at;
                var sortable = this.comparator && at == null && options.sort !== false;
                var sortAttr = _.isString(this.comparator) ? this.comparator : null;
                var toAdd = [], toRemove = [], modelMap = {};
                // Turn bare objects into model references, and prevent invalid models
                // from being added.
                for (i = 0, l = models.length; i < l; i++) {
                    if (!(model = this._prepareModel(models[i], options))) continue;
                    // If a duplicate is found, prevent it from being added and
                    // optionally merge it into the existing model.
                    if (existing = this.get(model)) {
                        if (options.remove) modelMap[existing.cid] = true;
                        if (options.merge) {
                            existing.set(model.attributes, options);
                            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
                        }
                    } else if (options.add) {
                        toAdd.push(model);
                        // Listen to added models' events, and index models for lookup by
                        // `id` and by `cid`.
                        model.on("all", this._onModelEvent, this);
                        this._byId[model.cid] = model;
                        if (model.id != null) this._byId[model.id] = model;
                    }
                }
                // Remove nonexistent models if appropriate.
                if (options.remove) {
                    for (i = 0, l = this.length; i < l; ++i) {
                        if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
                    }
                    if (toRemove.length) this.remove(toRemove, options);
                }
                // See if sorting is needed, update `length` and splice in new models.
                if (toAdd.length) {
                    if (sortable) sort = true;
                    this.length += toAdd.length;
                    if (at != null) {
                        splice.apply(this.models, [ at, 0 ].concat(toAdd));
                    } else {
                        push.apply(this.models, toAdd);
                    }
                }
                // Silently sort the collection if appropriate.
                if (sort) this.sort({
                    silent: true
                });
                if (options.silent) return this;
                // Trigger `add` events.
                for (i = 0, l = toAdd.length; i < l; i++) {
                    (model = toAdd[i]).trigger("add", model, this, options);
                }
                // Trigger `sort` if the collection was sorted.
                if (sort) this.trigger("sort", this, options);
                return this;
            },
            // When you have more items than you want to add or remove individually,
            // you can reset the entire set with a new list of models, without firing
            // any granular `add` or `remove` events. Fires `reset` when finished.
            // Useful for bulk operations and optimizations.
            reset: function(models, options) {
                options || (options = {});
                for (var i = 0, l = this.models.length; i < l; i++) {
                    this._removeReference(this.models[i]);
                }
                options.previousModels = this.models;
                this._reset();
                this.add(models, _.extend({
                    silent: true
                }, options));
                if (!options.silent) this.trigger("reset", this, options);
                return this;
            },
            // Add a model to the end of the collection.
            push: function(model, options) {
                model = this._prepareModel(model, options);
                this.add(model, _.extend({
                    at: this.length
                }, options));
                return model;
            },
            // Remove a model from the end of the collection.
            pop: function(options) {
                var model = this.at(this.length - 1);
                this.remove(model, options);
                return model;
            },
            // Add a model to the beginning of the collection.
            unshift: function(model, options) {
                model = this._prepareModel(model, options);
                this.add(model, _.extend({
                    at: 0
                }, options));
                return model;
            },
            // Remove a model from the beginning of the collection.
            shift: function(options) {
                var model = this.at(0);
                this.remove(model, options);
                return model;
            },
            // Slice out a sub-array of models from the collection.
            slice: function(begin, end) {
                return this.models.slice(begin, end);
            },
            // Get a model from the set by id.
            get: function(obj) {
                if (obj == null) return void 0;
                return this._byId[obj.id != null ? obj.id : obj.cid || obj];
            },
            // Get the model at the given index.
            at: function(index) {
                return this.models[index];
            },
            // Return models with matching attributes. Useful for simple cases of
            // `filter`.
            where: function(attrs, first) {
                if (_.isEmpty(attrs)) return first ? void 0 : [];
                return this[first ? "find" : "filter"](function(model) {
                    for (var key in attrs) {
                        if (attrs[key] !== model.get(key)) return false;
                    }
                    return true;
                });
            },
            // Return the first model with matching attributes. Useful for simple cases
            // of `find`.
            findWhere: function(attrs) {
                return this.where(attrs, true);
            },
            // Force the collection to re-sort itself. You don't need to call this under
            // normal circumstances, as the set will maintain sort order as each item
            // is added.
            sort: function(options) {
                if (!this.comparator) throw new Error("Cannot sort a set without a comparator");
                options || (options = {});
                // Run sort based on type of `comparator`.
                if (_.isString(this.comparator) || this.comparator.length === 1) {
                    this.models = this.sortBy(this.comparator, this);
                } else {
                    this.models.sort(_.bind(this.comparator, this));
                }
                if (!options.silent) this.trigger("sort", this, options);
                return this;
            },
            // Figure out the smallest index at which a model should be inserted so as
            // to maintain order.
            sortedIndex: function(model, value, context) {
                value || (value = this.comparator);
                var iterator = _.isFunction(value) ? value : function(model) {
                    return model.get(value);
                };
                return _.sortedIndex(this.models, model, iterator, context);
            },
            // Pluck an attribute from each model in the collection.
            pluck: function(attr) {
                return _.invoke(this.models, "get", attr);
            },
            // Fetch the default set of models for this collection, resetting the
            // collection when they arrive. If `reset: true` is passed, the response
            // data will be passed through the `reset` method instead of `set`.
            fetch: function(options) {
                options = options ? _.clone(options) : {};
                if (options.parse === void 0) options.parse = true;
                var success = options.success;
                var collection = this;
                options.success = function(resp) {
                    var method = options.reset ? "reset" : "set";
                    collection[method](resp, options);
                    if (success) success(collection, resp, options);
                    collection.trigger("sync", collection, resp, options);
                };
                wrapError(this, options);
                return this.sync("read", this, options);
            },
            // Create a new instance of a model in this collection. Add the model to the
            // collection immediately, unless `wait: true` is passed, in which case we
            // wait for the server to agree.
            create: function(model, options) {
                options = options ? _.clone(options) : {};
                if (!(model = this._prepareModel(model, options))) return false;
                if (!options.wait) this.add(model, options);
                var collection = this;
                var success = options.success;
                options.success = function(resp) {
                    if (options.wait) collection.add(model, options);
                    if (success) success(model, resp, options);
                };
                model.save(null, options);
                return model;
            },
            // **parse** converts a response into a list of models to be added to the
            // collection. The default implementation is just to pass it through.
            parse: function(resp, options) {
                return resp;
            },
            // Create a new collection with an identical list of models as this one.
            clone: function() {
                return new this.constructor(this.models);
            },
            // Private method to reset all internal state. Called when the collection
            // is first initialized or reset.
            _reset: function() {
                this.length = 0;
                this.models = [];
                this._byId = {};
            },
            // Prepare a hash of attributes (or other model) to be added to this
            // collection.
            _prepareModel: function(attrs, options) {
                if (attrs instanceof Model) {
                    if (!attrs.collection) attrs.collection = this;
                    return attrs;
                }
                options || (options = {});
                options.collection = this;
                var model = new this.model(attrs, options);
                if (!model._validate(attrs, options)) {
                    this.trigger("invalid", this, attrs, options);
                    return false;
                }
                return model;
            },
            // Internal method to sever a model's ties to a collection.
            _removeReference: function(model) {
                if (this === model.collection) delete model.collection;
                model.off("all", this._onModelEvent, this);
            },
            // Internal method called every time a model in the set fires an event.
            // Sets need to update their indexes when models change ids. All other
            // events simply proxy through. "add" and "remove" events that originate
            // in other collections are ignored.
            _onModelEvent: function(event, model, collection, options) {
                if ((event === "add" || event === "remove") && collection !== this) return;
                if (event === "destroy") this.remove(model, options);
                if (model && event === "change:" + model.idAttribute) {
                    delete this._byId[model.previous(model.idAttribute)];
                    if (model.id != null) this._byId[model.id] = model;
                }
                this.trigger.apply(this, arguments);
            }
        });
        // Underscore methods that we want to implement on the Collection.
        // 90% of the core usefulness of Backbone Collections is actually implemented
        // right here:
        var methods = [ "forEach", "each", "map", "collect", "reduce", "foldl", "inject", "reduceRight", "foldr", "find", "detect", "filter", "select", "reject", "every", "all", "some", "any", "include", "contains", "invoke", "max", "min", "toArray", "size", "first", "head", "take", "initial", "rest", "tail", "drop", "last", "without", "indexOf", "shuffle", "lastIndexOf", "isEmpty", "chain" ];
        // Mix in each Underscore method as a proxy to `Collection#models`.
        _.each(methods, function(method) {
            Collection.prototype[method] = function() {
                var args = slice.call(arguments);
                args.unshift(this.models);
                return _[method].apply(_, args);
            };
        });
        // Underscore methods that take a property name as an argument.
        var attributeMethods = [ "groupBy", "countBy", "sortBy" ];
        // Use attributes instead of properties.
        _.each(attributeMethods, function(method) {
            Collection.prototype[method] = function(value, context) {
                var iterator = _.isFunction(value) ? value : function(model) {
                    return model.get(value);
                };
                return _[method](this.models, iterator, context);
            };
        });
        // Backbone.View
        // -------------
        // Backbone Views are almost more convention than they are actual code. A View
        // is simply a JavaScript object that represents a logical chunk of UI in the
        // DOM. This might be a single item, an entire list, a sidebar or panel, or
        // even the surrounding frame which wraps your whole app. Defining a chunk of
        // UI as a **View** allows you to define your DOM events declaratively, without
        // having to worry about render order ... and makes it easy for the view to
        // react to specific changes in the state of your models.
        // Creating a Backbone.View creates its initial element outside of the DOM,
        // if an existing element is not provided...
        var View = Backbone.View = function(options) {
            this.cid = _.uniqueId("view");
            this._configure(options || {});
            this._ensureElement();
            this.initialize.apply(this, arguments);
            this.delegateEvents();
        };
        // Cached regex to split keys for `delegate`.
        var delegateEventSplitter = /^(\S+)\s*(.*)$/;
        // List of view options to be merged as properties.
        var viewOptions = [ "model", "collection", "el", "id", "attributes", "className", "tagName", "events" ];
        // Set up all inheritable **Backbone.View** properties and methods.
        _.extend(View.prototype, Events, {
            // The default `tagName` of a View's element is `"div"`.
            tagName: "div",
            // jQuery delegate for element lookup, scoped to DOM elements within the
            // current view. This should be prefered to global lookups where possible.
            $: function(selector) {
                return this.$el.find(selector);
            },
            // Initialize is an empty function by default. Override it with your own
            // initialization logic.
            initialize: function() {},
            // **render** is the core function that your view should override, in order
            // to populate its element (`this.el`), with the appropriate HTML. The
            // convention is for **render** to always return `this`.
            render: function() {
                return this;
            },
            // Remove this view by taking the element out of the DOM, and removing any
            // applicable Backbone.Events listeners.
            remove: function() {
                this.$el.remove();
                this.stopListening();
                return this;
            },
            // Change the view's element (`this.el` property), including event
            // re-delegation.
            setElement: function(element, delegate) {
                if (this.$el) this.undelegateEvents();
                this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
                this.el = this.$el[0];
                if (delegate !== false) this.delegateEvents();
                return this;
            },
            // Set callbacks, where `this.events` is a hash of
            //
            // *{"event selector": "callback"}*
            //
            //     {
            //       'mousedown .title':  'edit',
            //       'click .button':     'save'
            //       'click .open':       function(e) { ... }
            //     }
            //
            // pairs. Callbacks will be bound to the view, with `this` set properly.
            // Uses event delegation for efficiency.
            // Omitting the selector binds the event to `this.el`.
            // This only works for delegate-able events: not `focus`, `blur`, and
            // not `change`, `submit`, and `reset` in Internet Explorer.
            delegateEvents: function(events) {
                if (!(events || (events = _.result(this, "events")))) return this;
                this.undelegateEvents();
                for (var key in events) {
                    var method = events[key];
                    if (!_.isFunction(method)) method = this[events[key]];
                    if (!method) continue;
                    var match = key.match(delegateEventSplitter);
                    var eventName = match[1], selector = match[2];
                    method = _.bind(method, this);
                    eventName += ".delegateEvents" + this.cid;
                    if (selector === "") {
                        this.$el.on(eventName, method);
                    } else {
                        this.$el.on(eventName, selector, method);
                    }
                }
                return this;
            },
            // Clears all callbacks previously bound to the view with `delegateEvents`.
            // You usually don't need to use this, but may wish to if you have multiple
            // Backbone views attached to the same DOM element.
            undelegateEvents: function() {
                this.$el.off(".delegateEvents" + this.cid);
                return this;
            },
            // Performs the initial configuration of a View with a set of options.
            // Keys with special meaning *(e.g. model, collection, id, className)* are
            // attached directly to the view.  See `viewOptions` for an exhaustive
            // list.
            _configure: function(options) {
                if (this.options) options = _.extend({}, _.result(this, "options"), options);
                _.extend(this, _.pick(options, viewOptions));
                this.options = options;
            },
            // Ensure that the View has a DOM element to render into.
            // If `this.el` is a string, pass it through `$()`, take the first
            // matching element, and re-assign it to `el`. Otherwise, create
            // an element from the `id`, `className` and `tagName` properties.
            _ensureElement: function() {
                if (!this.el) {
                    var attrs = _.extend({}, _.result(this, "attributes"));
                    if (this.id) attrs.id = _.result(this, "id");
                    if (this.className) attrs["class"] = _.result(this, "className");
                    var $el = Backbone.$("<" + _.result(this, "tagName") + ">").attr(attrs);
                    this.setElement($el, false);
                } else {
                    this.setElement(_.result(this, "el"), false);
                }
            }
        });
        // Backbone.sync
        // -------------
        // Override this function to change the manner in which Backbone persists
        // models to the server. You will be passed the type of request, and the
        // model in question. By default, makes a RESTful Ajax request
        // to the model's `url()`. Some possible customizations could be:
        //
        // * Use `setTimeout` to batch rapid-fire updates into a single request.
        // * Send up the models as XML instead of JSON.
        // * Persist models via WebSockets instead of Ajax.
        //
        // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
        // as `POST`, with a `_method` parameter containing the true HTTP method,
        // as well as all requests with the body as `application/x-www-form-urlencoded`
        // instead of `application/json` with the model in a param named `model`.
        // Useful when interfacing with server-side languages like **PHP** that make
        // it difficult to read the body of `PUT` requests.
        Backbone.sync = function(method, model, options) {
            var type = methodMap[method];
            // Default options, unless specified.
            _.defaults(options || (options = {}), {
                emulateHTTP: Backbone.emulateHTTP,
                emulateJSON: Backbone.emulateJSON
            });
            // Default JSON-request options.
            var params = {
                type: type,
                dataType: "json"
            };
            // Ensure that we have a URL.
            if (!options.url) {
                params.url = _.result(model, "url") || urlError();
            }
            // Ensure that we have the appropriate request data.
            if (options.data == null && model && (method === "create" || method === "update" || method === "patch")) {
                params.contentType = "application/json";
                params.data = JSON.stringify(options.attrs || model.toJSON(options));
            }
            // For older servers, emulate JSON by encoding the request into an HTML-form.
            if (options.emulateJSON) {
                params.contentType = "application/x-www-form-urlencoded";
                params.data = params.data ? {
                    model: params.data
                } : {};
            }
            // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
            // And an `X-HTTP-Method-Override` header.
            if (options.emulateHTTP && (type === "PUT" || type === "DELETE" || type === "PATCH")) {
                params.type = "POST";
                if (options.emulateJSON) params.data._method = type;
                var beforeSend = options.beforeSend;
                options.beforeSend = function(xhr) {
                    xhr.setRequestHeader("X-HTTP-Method-Override", type);
                    if (beforeSend) return beforeSend.apply(this, arguments);
                };
            }
            // Don't process data on a non-GET request.
            if (params.type !== "GET" && !options.emulateJSON) {
                params.processData = false;
            }
            // If we're sending a `PATCH` request, and we're in an old Internet Explorer
            // that still has ActiveX enabled by default, override jQuery to use that
            // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
            if (params.type === "PATCH" && window.ActiveXObject && !(window.external && window.external.msActiveXFilteringEnabled)) {
                params.xhr = function() {
                    return new ActiveXObject("Microsoft.XMLHTTP");
                };
            }
            // Make the request, allowing the user to override any Ajax options.
            var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
            model.trigger("request", model, xhr, options);
            return xhr;
        };
        // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
        var methodMap = {
            create: "POST",
            update: "PUT",
            patch: "PATCH",
            "delete": "DELETE",
            read: "GET"
        };
        // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
        // Override this if you'd like to use a different library.
        Backbone.ajax = function() {
            return Backbone.$.ajax.apply(Backbone.$, arguments);
        };
        // Backbone.Router
        // ---------------
        // Routers map faux-URLs to actions, and fire events when routes are
        // matched. Creating a new one sets its `routes` hash, if not set statically.
        var Router = Backbone.Router = function(options) {
            options || (options = {});
            if (options.routes) this.routes = options.routes;
            this._bindRoutes();
            this.initialize.apply(this, arguments);
        };
        // Cached regular expressions for matching named param parts and splatted
        // parts of route strings.
        var optionalParam = /\((.*?)\)/g;
        var namedParam = /(\(\?)?:\w+/g;
        var splatParam = /\*\w+/g;
        var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
        // Set up all inheritable **Backbone.Router** properties and methods.
        _.extend(Router.prototype, Events, {
            // Initialize is an empty function by default. Override it with your own
            // initialization logic.
            initialize: function() {},
            // Manually bind a single named route to a callback. For example:
            //
            //     this.route('search/:query/p:num', 'search', function(query, num) {
            //       ...
            //     });
            //
            route: function(route, name, callback) {
                if (!_.isRegExp(route)) route = this._routeToRegExp(route);
                if (_.isFunction(name)) {
                    callback = name;
                    name = "";
                }
                if (!callback) callback = this[name];
                var router = this;
                Backbone.history.route(route, function(fragment) {
                    var args = router._extractParameters(route, fragment);
                    callback && callback.apply(router, args);
                    router.trigger.apply(router, [ "route:" + name ].concat(args));
                    router.trigger("route", name, args);
                    Backbone.history.trigger("route", router, name, args);
                });
                return this;
            },
            // Simple proxy to `Backbone.history` to save a fragment into the history.
            navigate: function(fragment, options) {
                Backbone.history.navigate(fragment, options);
                return this;
            },
            // Bind all defined routes to `Backbone.history`. We have to reverse the
            // order of the routes here to support behavior where the most general
            // routes can be defined at the bottom of the route map.
            _bindRoutes: function() {
                if (!this.routes) return;
                this.routes = _.result(this, "routes");
                var route, routes = _.keys(this.routes);
                while ((route = routes.pop()) != null) {
                    this.route(route, this.routes[route]);
                }
            },
            // Convert a route string into a regular expression, suitable for matching
            // against the current location hash.
            _routeToRegExp: function(route) {
                route = route.replace(escapeRegExp, "\\$&").replace(optionalParam, "(?:$1)?").replace(namedParam, function(match, optional) {
                    return optional ? match : "([^/]+)";
                }).replace(splatParam, "(.*?)");
                return new RegExp("^" + route + "$");
            },
            // Given a route, and a URL fragment that it matches, return the array of
            // extracted decoded parameters. Empty or unmatched parameters will be
            // treated as `null` to normalize cross-browser behavior.
            _extractParameters: function(route, fragment) {
                var params = route.exec(fragment).slice(1);
                return _.map(params, function(param) {
                    return param ? decodeURIComponent(param) : null;
                });
            }
        });
        // Backbone.History
        // ----------------
        // Handles cross-browser history management, based on either
        // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
        // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
        // and URL fragments. If the browser supports neither (old IE, natch),
        // falls back to polling.
        var History = Backbone.History = function() {
            this.handlers = [];
            _.bindAll(this, "checkUrl");
            // Ensure that `History` can be used outside of the browser.
            if (typeof window !== "undefined") {
                this.location = window.location;
                this.history = window.history;
            }
        };
        // Cached regex for stripping a leading hash/slash and trailing space.
        var routeStripper = /^[#\/]|\s+$/g;
        // Cached regex for stripping leading and trailing slashes.
        var rootStripper = /^\/+|\/+$/g;
        // Cached regex for detecting MSIE.
        var isExplorer = /msie [\w.]+/;
        // Cached regex for removing a trailing slash.
        var trailingSlash = /\/$/;
        // Has the history handling already been started?
        History.started = false;
        // Set up all inheritable **Backbone.History** properties and methods.
        _.extend(History.prototype, Events, {
            // The default interval to poll for hash changes, if necessary, is
            // twenty times a second.
            interval: 50,
            // Gets the true hash value. Cannot use location.hash directly due to bug
            // in Firefox where location.hash will always be decoded.
            getHash: function(window) {
                var match = (window || this).location.href.match(/#(.*)$/);
                return match ? match[1] : "";
            },
            // Get the cross-browser normalized URL fragment, either from the URL,
            // the hash, or the override.
            getFragment: function(fragment, forcePushState) {
                if (fragment == null) {
                    if (this._hasPushState || !this._wantsHashChange || forcePushState) {
                        fragment = this.location.pathname;
                        var root = this.root.replace(trailingSlash, "");
                        if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);
                    } else {
                        fragment = this.getHash();
                    }
                }
                return fragment.replace(routeStripper, "");
            },
            // Start the hash change handling, returning `true` if the current URL matches
            // an existing route, and `false` otherwise.
            start: function(options) {
                if (History.started) throw new Error("Backbone.history has already been started");
                History.started = true;
                // Figure out the initial configuration. Do we need an iframe?
                // Is pushState desired ... is it available?
                this.options = _.extend({}, {
                    root: "/"
                }, this.options, options);
                this.root = this.options.root;
                this._wantsHashChange = this.options.hashChange !== false;
                this._wantsPushState = !!this.options.pushState;
                this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);
                var fragment = this.getFragment();
                var docMode = document.documentMode;
                var oldIE = isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7);
                // Normalize root to always include a leading and trailing slash.
                this.root = ("/" + this.root + "/").replace(rootStripper, "/");
                if (oldIE && this._wantsHashChange) {
                    this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo("body")[0].contentWindow;
                    this.navigate(fragment);
                }
                // Depending on whether we're using pushState or hashes, and whether
                // 'onhashchange' is supported, determine how we check the URL state.
                if (this._hasPushState) {
                    Backbone.$(window).on("popstate", this.checkUrl);
                } else if (this._wantsHashChange && "onhashchange" in window && !oldIE) {
                    Backbone.$(window).on("hashchange", this.checkUrl);
                } else if (this._wantsHashChange) {
                    this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
                }
                // Determine if we need to change the base url, for a pushState link
                // opened by a non-pushState browser.
                this.fragment = fragment;
                var loc = this.location;
                var atRoot = loc.pathname.replace(/[^\/]$/, "$&/") === this.root;
                // If we've started off with a route from a `pushState`-enabled browser,
                // but we're currently in a browser that doesn't support it...
                if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {
                    this.fragment = this.getFragment(null, true);
                    this.location.replace(this.root + this.location.search + "#" + this.fragment);
                    // Return immediately as browser will do redirect to new url
                    return true;
                } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {
                    this.fragment = this.getHash().replace(routeStripper, "");
                    this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
                }
                if (!this.options.silent) return this.loadUrl();
            },
            // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
            // but possibly useful for unit testing Routers.
            stop: function() {
                Backbone.$(window).off("popstate", this.checkUrl).off("hashchange", this.checkUrl);
                clearInterval(this._checkUrlInterval);
                History.started = false;
            },
            // Add a route to be tested when the fragment changes. Routes added later
            // may override previous routes.
            route: function(route, callback) {
                this.handlers.unshift({
                    route: route,
                    callback: callback
                });
            },
            // Checks the current URL to see if it has changed, and if it has,
            // calls `loadUrl`, normalizing across the hidden iframe.
            checkUrl: function(e) {
                var current = this.getFragment();
                if (current === this.fragment && this.iframe) {
                    current = this.getFragment(this.getHash(this.iframe));
                }
                if (current === this.fragment) return false;
                if (this.iframe) this.navigate(current);
                this.loadUrl() || this.loadUrl(this.getHash());
            },
            // Attempt to load the current URL fragment. If a route succeeds with a
            // match, returns `true`. If no defined routes matches the fragment,
            // returns `false`.
            loadUrl: function(fragmentOverride) {
                var fragment = this.fragment = this.getFragment(fragmentOverride);
                var matched = _.any(this.handlers, function(handler) {
                    if (handler.route.test(fragment)) {
                        handler.callback(fragment);
                        return true;
                    }
                });
                return matched;
            },
            // Save a fragment into the hash history, or replace the URL state if the
            // 'replace' option is passed. You are responsible for properly URL-encoding
            // the fragment in advance.
            //
            // The options object can contain `trigger: true` if you wish to have the
            // route callback be fired (not usually desirable), or `replace: true`, if
            // you wish to modify the current URL without adding an entry to the history.
            navigate: function(fragment, options) {
                if (!History.started) return false;
                if (!options || options === true) options = {
                    trigger: options
                };
                fragment = this.getFragment(fragment || "");
                if (this.fragment === fragment) return;
                this.fragment = fragment;
                var url = this.root + fragment;
                // If pushState is available, we use it to set the fragment as a real URL.
                if (this._hasPushState) {
                    this.history[options.replace ? "replaceState" : "pushState"]({}, document.title, url);
                } else if (this._wantsHashChange) {
                    this._updateHash(this.location, fragment, options.replace);
                    if (this.iframe && fragment !== this.getFragment(this.getHash(this.iframe))) {
                        // Opening and closing the iframe tricks IE7 and earlier to push a
                        // history entry on hash-tag change.  When replace is true, we don't
                        // want this.
                        if (!options.replace) this.iframe.document.open().close();
                        this._updateHash(this.iframe.location, fragment, options.replace);
                    }
                } else {
                    return this.location.assign(url);
                }
                if (options.trigger) this.loadUrl(fragment);
            },
            // Update the hash location, either replacing the current entry, or adding
            // a new one to the browser history.
            _updateHash: function(location, fragment, replace) {
                if (replace) {
                    var href = location.href.replace(/(javascript:|#).*$/, "");
                    location.replace(href + "#" + fragment);
                } else {
                    // Some browsers require that `hash` contains a leading #.
                    location.hash = "#" + fragment;
                }
            }
        });
        // Create the default Backbone.history.
        Backbone.history = new History();
        // Helpers
        // -------
        // Helper function to correctly set up the prototype chain, for subclasses.
        // Similar to `goog.inherits`, but uses a hash of prototype properties and
        // class properties to be extended.
        var extend = function(protoProps, staticProps) {
            var parent = this;
            var child;
            // The constructor function for the new subclass is either defined by you
            // (the "constructor" property in your `extend` definition), or defaulted
            // by us to simply call the parent's constructor.
            if (protoProps && _.has(protoProps, "constructor")) {
                child = protoProps.constructor;
            } else {
                child = function() {
                    return parent.apply(this, arguments);
                };
            }
            // Add static properties to the constructor function, if supplied.
            _.extend(child, parent, staticProps);
            // Set the prototype chain to inherit from `parent`, without calling
            // `parent`'s constructor function.
            var Surrogate = function() {
                this.constructor = child;
            };
            Surrogate.prototype = parent.prototype;
            child.prototype = new Surrogate();
            // Add prototype properties (instance properties) to the subclass,
            // if supplied.
            if (protoProps) _.extend(child.prototype, protoProps);
            // Set a convenience property in case the parent's prototype is needed
            // later.
            child.__super__ = parent.prototype;
            return child;
        };
        // Set up inheritance for the model, collection, router, view and history.
        Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
        // Throw an error when a URL is needed, and none is supplied.
        var urlError = function() {
            throw new Error('A "url" property or function must be specified');
        };
        // Wrap an optional error callback with a fallback error event.
        var wrapError = function(model, options) {
            var error = options.error;
            options.error = function(resp) {
                if (error) error(model, resp, options);
                model.trigger("error", model, resp, options);
            };
        };
    }).call(this);
    this._ = previousUnderscore;
    this.jQuery = previousJQuery;
});

define("gallery/underscore/1.4.4/underscore-debug", [], function(require, exports, module) {
    //     Underscore.js 1.4.4
    //     http://underscorejs.org
    //     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
    //     Underscore may be freely distributed under the MIT license.
    (function() {
        // Baseline setup
        // --------------
        // Establish the root object, `window` in the browser, or `global` on the server.
        var root = this;
        // Save the previous value of the `_` variable.
        var previousUnderscore = root._;
        // Establish the object that gets returned to break out of a loop iteration.
        var breaker = {};
        // Save bytes in the minified (but not gzipped) version:
        var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
        // Create quick reference variables for speed access to core prototypes.
        var push = ArrayProto.push, slice = ArrayProto.slice, concat = ArrayProto.concat, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
        // All **ECMAScript 5** native function implementations that we hope to use
        // are declared here.
        var nativeForEach = ArrayProto.forEach, nativeMap = ArrayProto.map, nativeReduce = ArrayProto.reduce, nativeReduceRight = ArrayProto.reduceRight, nativeFilter = ArrayProto.filter, nativeEvery = ArrayProto.every, nativeSome = ArrayProto.some, nativeIndexOf = ArrayProto.indexOf, nativeLastIndexOf = ArrayProto.lastIndexOf, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind;
        // Create a safe reference to the Underscore object for use below.
        var _ = function(obj) {
            if (obj instanceof _) return obj;
            if (!(this instanceof _)) return new _(obj);
            this._wrapped = obj;
        };
        // Export the Underscore object for **Node.js**, with
        // backwards-compatibility for the old `require()` API. If we're in
        // the browser, add `_` as a global object via a string identifier,
        // for Closure Compiler "advanced" mode.
        if (typeof exports !== "undefined") {
            if (typeof module !== "undefined" && module.exports) {
                exports = module.exports = _;
            }
            exports._ = _;
        } else {
            root._ = _;
        }
        // Current version.
        _.VERSION = "1.4.4";
        // Collection Functions
        // --------------------
        // The cornerstone, an `each` implementation, aka `forEach`.
        // Handles objects with the built-in `forEach`, arrays, and raw objects.
        // Delegates to **ECMAScript 5**'s native `forEach` if available.
        var each = _.each = _.forEach = function(obj, iterator, context) {
            if (obj == null) return;
            if (nativeForEach && obj.forEach === nativeForEach) {
                obj.forEach(iterator, context);
            } else if (obj.length === +obj.length) {
                for (var i = 0, l = obj.length; i < l; i++) {
                    if (iterator.call(context, obj[i], i, obj) === breaker) return;
                }
            } else {
                for (var key in obj) {
                    if (_.has(obj, key)) {
                        if (iterator.call(context, obj[key], key, obj) === breaker) return;
                    }
                }
            }
        };
        // Return the results of applying the iterator to each element.
        // Delegates to **ECMAScript 5**'s native `map` if available.
        _.map = _.collect = function(obj, iterator, context) {
            var results = [];
            if (obj == null) return results;
            if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
            each(obj, function(value, index, list) {
                results[results.length] = iterator.call(context, value, index, list);
            });
            return results;
        };
        var reduceError = "Reduce of empty array with no initial value";
        // **Reduce** builds up a single result from a list of values, aka `inject`,
        // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
        _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
            var initial = arguments.length > 2;
            if (obj == null) obj = [];
            if (nativeReduce && obj.reduce === nativeReduce) {
                if (context) iterator = _.bind(iterator, context);
                return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
            }
            each(obj, function(value, index, list) {
                if (!initial) {
                    memo = value;
                    initial = true;
                } else {
                    memo = iterator.call(context, memo, value, index, list);
                }
            });
            if (!initial) throw new TypeError(reduceError);
            return memo;
        };
        // The right-associative version of reduce, also known as `foldr`.
        // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
        _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
            var initial = arguments.length > 2;
            if (obj == null) obj = [];
            if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
                if (context) iterator = _.bind(iterator, context);
                return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
            }
            var length = obj.length;
            if (length !== +length) {
                var keys = _.keys(obj);
                length = keys.length;
            }
            each(obj, function(value, index, list) {
                index = keys ? keys[--length] : --length;
                if (!initial) {
                    memo = obj[index];
                    initial = true;
                } else {
                    memo = iterator.call(context, memo, obj[index], index, list);
                }
            });
            if (!initial) throw new TypeError(reduceError);
            return memo;
        };
        // Return the first value which passes a truth test. Aliased as `detect`.
        _.find = _.detect = function(obj, iterator, context) {
            var result;
            any(obj, function(value, index, list) {
                if (iterator.call(context, value, index, list)) {
                    result = value;
                    return true;
                }
            });
            return result;
        };
        // Return all the elements that pass a truth test.
        // Delegates to **ECMAScript 5**'s native `filter` if available.
        // Aliased as `select`.
        _.filter = _.select = function(obj, iterator, context) {
            var results = [];
            if (obj == null) return results;
            if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
            each(obj, function(value, index, list) {
                if (iterator.call(context, value, index, list)) results[results.length] = value;
            });
            return results;
        };
        // Return all the elements for which a truth test fails.
        _.reject = function(obj, iterator, context) {
            return _.filter(obj, function(value, index, list) {
                return !iterator.call(context, value, index, list);
            }, context);
        };
        // Determine whether all of the elements match a truth test.
        // Delegates to **ECMAScript 5**'s native `every` if available.
        // Aliased as `all`.
        _.every = _.all = function(obj, iterator, context) {
            iterator || (iterator = _.identity);
            var result = true;
            if (obj == null) return result;
            if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
            each(obj, function(value, index, list) {
                if (!(result = result && iterator.call(context, value, index, list))) return breaker;
            });
            return !!result;
        };
        // Determine if at least one element in the object matches a truth test.
        // Delegates to **ECMAScript 5**'s native `some` if available.
        // Aliased as `any`.
        var any = _.some = _.any = function(obj, iterator, context) {
            iterator || (iterator = _.identity);
            var result = false;
            if (obj == null) return result;
            if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
            each(obj, function(value, index, list) {
                if (result || (result = iterator.call(context, value, index, list))) return breaker;
            });
            return !!result;
        };
        // Determine if the array or object contains a given value (using `===`).
        // Aliased as `include`.
        _.contains = _.include = function(obj, target) {
            if (obj == null) return false;
            if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
            return any(obj, function(value) {
                return value === target;
            });
        };
        // Invoke a method (with arguments) on every item in a collection.
        _.invoke = function(obj, method) {
            var args = slice.call(arguments, 2);
            var isFunc = _.isFunction(method);
            return _.map(obj, function(value) {
                return (isFunc ? method : value[method]).apply(value, args);
            });
        };
        // Convenience version of a common use case of `map`: fetching a property.
        _.pluck = function(obj, key) {
            return _.map(obj, function(value) {
                return value[key];
            });
        };
        // Convenience version of a common use case of `filter`: selecting only objects
        // containing specific `key:value` pairs.
        _.where = function(obj, attrs, first) {
            if (_.isEmpty(attrs)) return first ? null : [];
            return _[first ? "find" : "filter"](obj, function(value) {
                for (var key in attrs) {
                    if (attrs[key] !== value[key]) return false;
                }
                return true;
            });
        };
        // Convenience version of a common use case of `find`: getting the first object
        // containing specific `key:value` pairs.
        _.findWhere = function(obj, attrs) {
            return _.where(obj, attrs, true);
        };
        // Return the maximum element or (element-based computation).
        // Can't optimize arrays of integers longer than 65,535 elements.
        // See: https://bugs.webkit.org/show_bug.cgi?id=80797
        _.max = function(obj, iterator, context) {
            if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
                return Math.max.apply(Math, obj);
            }
            if (!iterator && _.isEmpty(obj)) return -Infinity;
            var result = {
                computed: -Infinity,
                value: -Infinity
            };
            each(obj, function(value, index, list) {
                var computed = iterator ? iterator.call(context, value, index, list) : value;
                computed >= result.computed && (result = {
                    value: value,
                    computed: computed
                });
            });
            return result.value;
        };
        // Return the minimum element (or element-based computation).
        _.min = function(obj, iterator, context) {
            if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
                return Math.min.apply(Math, obj);
            }
            if (!iterator && _.isEmpty(obj)) return Infinity;
            var result = {
                computed: Infinity,
                value: Infinity
            };
            each(obj, function(value, index, list) {
                var computed = iterator ? iterator.call(context, value, index, list) : value;
                computed < result.computed && (result = {
                    value: value,
                    computed: computed
                });
            });
            return result.value;
        };
        // Shuffle an array.
        _.shuffle = function(obj) {
            var rand;
            var index = 0;
            var shuffled = [];
            each(obj, function(value) {
                rand = _.random(index++);
                shuffled[index - 1] = shuffled[rand];
                shuffled[rand] = value;
            });
            return shuffled;
        };
        // An internal function to generate lookup iterators.
        var lookupIterator = function(value) {
            return _.isFunction(value) ? value : function(obj) {
                return obj[value];
            };
        };
        // Sort the object's values by a criterion produced by an iterator.
        _.sortBy = function(obj, value, context) {
            var iterator = lookupIterator(value);
            return _.pluck(_.map(obj, function(value, index, list) {
                return {
                    value: value,
                    index: index,
                    criteria: iterator.call(context, value, index, list)
                };
            }).sort(function(left, right) {
                var a = left.criteria;
                var b = right.criteria;
                if (a !== b) {
                    if (a > b || a === void 0) return 1;
                    if (a < b || b === void 0) return -1;
                }
                return left.index < right.index ? -1 : 1;
            }), "value");
        };
        // An internal function used for aggregate "group by" operations.
        var group = function(obj, value, context, behavior) {
            var result = {};
            var iterator = lookupIterator(value || _.identity);
            each(obj, function(value, index) {
                var key = iterator.call(context, value, index, obj);
                behavior(result, key, value);
            });
            return result;
        };
        // Groups the object's values by a criterion. Pass either a string attribute
        // to group by, or a function that returns the criterion.
        _.groupBy = function(obj, value, context) {
            return group(obj, value, context, function(result, key, value) {
                (_.has(result, key) ? result[key] : result[key] = []).push(value);
            });
        };
        // Counts instances of an object that group by a certain criterion. Pass
        // either a string attribute to count by, or a function that returns the
        // criterion.
        _.countBy = function(obj, value, context) {
            return group(obj, value, context, function(result, key) {
                if (!_.has(result, key)) result[key] = 0;
                result[key]++;
            });
        };
        // Use a comparator function to figure out the smallest index at which
        // an object should be inserted so as to maintain order. Uses binary search.
        _.sortedIndex = function(array, obj, iterator, context) {
            iterator = iterator == null ? _.identity : lookupIterator(iterator);
            var value = iterator.call(context, obj);
            var low = 0, high = array.length;
            while (low < high) {
                var mid = low + high >>> 1;
                iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
            }
            return low;
        };
        // Safely convert anything iterable into a real, live array.
        _.toArray = function(obj) {
            if (!obj) return [];
            if (_.isArray(obj)) return slice.call(obj);
            if (obj.length === +obj.length) return _.map(obj, _.identity);
            return _.values(obj);
        };
        // Return the number of elements in an object.
        _.size = function(obj) {
            if (obj == null) return 0;
            return obj.length === +obj.length ? obj.length : _.keys(obj).length;
        };
        // Array Functions
        // ---------------
        // Get the first element of an array. Passing **n** will return the first N
        // values in the array. Aliased as `head` and `take`. The **guard** check
        // allows it to work with `_.map`.
        _.first = _.head = _.take = function(array, n, guard) {
            if (array == null) return void 0;
            return n != null && !guard ? slice.call(array, 0, n) : array[0];
        };
        // Returns everything but the last entry of the array. Especially useful on
        // the arguments object. Passing **n** will return all the values in
        // the array, excluding the last N. The **guard** check allows it to work with
        // `_.map`.
        _.initial = function(array, n, guard) {
            return slice.call(array, 0, array.length - (n == null || guard ? 1 : n));
        };
        // Get the last element of an array. Passing **n** will return the last N
        // values in the array. The **guard** check allows it to work with `_.map`.
        _.last = function(array, n, guard) {
            if (array == null) return void 0;
            if (n != null && !guard) {
                return slice.call(array, Math.max(array.length - n, 0));
            } else {
                return array[array.length - 1];
            }
        };
        // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
        // Especially useful on the arguments object. Passing an **n** will return
        // the rest N values in the array. The **guard**
        // check allows it to work with `_.map`.
        _.rest = _.tail = _.drop = function(array, n, guard) {
            return slice.call(array, n == null || guard ? 1 : n);
        };
        // Trim out all falsy values from an array.
        _.compact = function(array) {
            return _.filter(array, _.identity);
        };
        // Internal implementation of a recursive `flatten` function.
        var flatten = function(input, shallow, output) {
            each(input, function(value) {
                if (_.isArray(value)) {
                    shallow ? push.apply(output, value) : flatten(value, shallow, output);
                } else {
                    output.push(value);
                }
            });
            return output;
        };
        // Return a completely flattened version of an array.
        _.flatten = function(array, shallow) {
            return flatten(array, shallow, []);
        };
        // Return a version of the array that does not contain the specified value(s).
        _.without = function(array) {
            return _.difference(array, slice.call(arguments, 1));
        };
        // Produce a duplicate-free version of the array. If the array has already
        // been sorted, you have the option of using a faster algorithm.
        // Aliased as `unique`.
        _.uniq = _.unique = function(array, isSorted, iterator, context) {
            if (_.isFunction(isSorted)) {
                context = iterator;
                iterator = isSorted;
                isSorted = false;
            }
            var initial = iterator ? _.map(array, iterator, context) : array;
            var results = [];
            var seen = [];
            each(initial, function(value, index) {
                if (isSorted ? !index || seen[seen.length - 1] !== value : !_.contains(seen, value)) {
                    seen.push(value);
                    results.push(array[index]);
                }
            });
            return results;
        };
        // Produce an array that contains the union: each distinct element from all of
        // the passed-in arrays.
        _.union = function() {
            return _.uniq(concat.apply(ArrayProto, arguments));
        };
        // Produce an array that contains every item shared between all the
        // passed-in arrays.
        _.intersection = function(array) {
            var rest = slice.call(arguments, 1);
            return _.filter(_.uniq(array), function(item) {
                return _.every(rest, function(other) {
                    return _.indexOf(other, item) >= 0;
                });
            });
        };
        // Take the difference between one array and a number of other arrays.
        // Only the elements present in just the first array will remain.
        _.difference = function(array) {
            var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
            return _.filter(array, function(value) {
                return !_.contains(rest, value);
            });
        };
        // Zip together multiple lists into a single array -- elements that share
        // an index go together.
        _.zip = function() {
            var args = slice.call(arguments);
            var length = _.max(_.pluck(args, "length"));
            var results = new Array(length);
            for (var i = 0; i < length; i++) {
                results[i] = _.pluck(args, "" + i);
            }
            return results;
        };
        // Converts lists into objects. Pass either a single array of `[key, value]`
        // pairs, or two parallel arrays of the same length -- one of keys, and one of
        // the corresponding values.
        _.object = function(list, values) {
            if (list == null) return {};
            var result = {};
            for (var i = 0, l = list.length; i < l; i++) {
                if (values) {
                    result[list[i]] = values[i];
                } else {
                    result[list[i][0]] = list[i][1];
                }
            }
            return result;
        };
        // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
        // we need this function. Return the position of the first occurrence of an
        // item in an array, or -1 if the item is not included in the array.
        // Delegates to **ECMAScript 5**'s native `indexOf` if available.
        // If the array is large and already in sort order, pass `true`
        // for **isSorted** to use binary search.
        _.indexOf = function(array, item, isSorted) {
            if (array == null) return -1;
            var i = 0, l = array.length;
            if (isSorted) {
                if (typeof isSorted == "number") {
                    i = isSorted < 0 ? Math.max(0, l + isSorted) : isSorted;
                } else {
                    i = _.sortedIndex(array, item);
                    return array[i] === item ? i : -1;
                }
            }
            if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
            for (;i < l; i++) if (array[i] === item) return i;
            return -1;
        };
        // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
        _.lastIndexOf = function(array, item, from) {
            if (array == null) return -1;
            var hasIndex = from != null;
            if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
                return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
            }
            var i = hasIndex ? from : array.length;
            while (i--) if (array[i] === item) return i;
            return -1;
        };
        // Generate an integer Array containing an arithmetic progression. A port of
        // the native Python `range()` function. See
        // [the Python documentation](http://docs.python.org/library/functions.html#range).
        _.range = function(start, stop, step) {
            if (arguments.length <= 1) {
                stop = start || 0;
                start = 0;
            }
            step = arguments[2] || 1;
            var len = Math.max(Math.ceil((stop - start) / step), 0);
            var idx = 0;
            var range = new Array(len);
            while (idx < len) {
                range[idx++] = start;
                start += step;
            }
            return range;
        };
        // Function (ahem) Functions
        // ------------------
        // Create a function bound to a given object (assigning `this`, and arguments,
        // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
        // available.
        _.bind = function(func, context) {
            if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
            var args = slice.call(arguments, 2);
            return function() {
                return func.apply(context, args.concat(slice.call(arguments)));
            };
        };
        // Partially apply a function by creating a version that has had some of its
        // arguments pre-filled, without changing its dynamic `this` context.
        _.partial = function(func) {
            var args = slice.call(arguments, 1);
            return function() {
                return func.apply(this, args.concat(slice.call(arguments)));
            };
        };
        // Bind all of an object's methods to that object. Useful for ensuring that
        // all callbacks defined on an object belong to it.
        _.bindAll = function(obj) {
            var funcs = slice.call(arguments, 1);
            if (funcs.length === 0) funcs = _.functions(obj);
            each(funcs, function(f) {
                obj[f] = _.bind(obj[f], obj);
            });
            return obj;
        };
        // Memoize an expensive function by storing its results.
        _.memoize = function(func, hasher) {
            var memo = {};
            hasher || (hasher = _.identity);
            return function() {
                var key = hasher.apply(this, arguments);
                return _.has(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments);
            };
        };
        // Delays a function for the given number of milliseconds, and then calls
        // it with the arguments supplied.
        _.delay = function(func, wait) {
            var args = slice.call(arguments, 2);
            return setTimeout(function() {
                return func.apply(null, args);
            }, wait);
        };
        // Defers a function, scheduling it to run after the current call stack has
        // cleared.
        _.defer = function(func) {
            return _.delay.apply(_, [ func, 1 ].concat(slice.call(arguments, 1)));
        };
        // Returns a function, that, when invoked, will only be triggered at most once
        // during a given window of time.
        _.throttle = function(func, wait) {
            var context, args, timeout, result;
            var previous = 0;
            var later = function() {
                previous = new Date();
                timeout = null;
                result = func.apply(context, args);
            };
            return function() {
                var now = new Date();
                var remaining = wait - (now - previous);
                context = this;
                args = arguments;
                if (remaining <= 0) {
                    clearTimeout(timeout);
                    timeout = null;
                    previous = now;
                    result = func.apply(context, args);
                } else if (!timeout) {
                    timeout = setTimeout(later, remaining);
                }
                return result;
            };
        };
        // Returns a function, that, as long as it continues to be invoked, will not
        // be triggered. The function will be called after it stops being called for
        // N milliseconds. If `immediate` is passed, trigger the function on the
        // leading edge, instead of the trailing.
        _.debounce = function(func, wait, immediate) {
            var timeout, result;
            return function() {
                var context = this, args = arguments;
                var later = function() {
                    timeout = null;
                    if (!immediate) result = func.apply(context, args);
                };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) result = func.apply(context, args);
                return result;
            };
        };
        // Returns a function that will be executed at most one time, no matter how
        // often you call it. Useful for lazy initialization.
        _.once = function(func) {
            var ran = false, memo;
            return function() {
                if (ran) return memo;
                ran = true;
                memo = func.apply(this, arguments);
                func = null;
                return memo;
            };
        };
        // Returns the first function passed as an argument to the second,
        // allowing you to adjust arguments, run code before and after, and
        // conditionally execute the original function.
        _.wrap = function(func, wrapper) {
            return function() {
                var args = [ func ];
                push.apply(args, arguments);
                return wrapper.apply(this, args);
            };
        };
        // Returns a function that is the composition of a list of functions, each
        // consuming the return value of the function that follows.
        _.compose = function() {
            var funcs = arguments;
            return function() {
                var args = arguments;
                for (var i = funcs.length - 1; i >= 0; i--) {
                    args = [ funcs[i].apply(this, args) ];
                }
                return args[0];
            };
        };
        // Returns a function that will only be executed after being called N times.
        _.after = function(times, func) {
            if (times <= 0) return func();
            return function() {
                if (--times < 1) {
                    return func.apply(this, arguments);
                }
            };
        };
        // Object Functions
        // ----------------
        // Retrieve the names of an object's properties.
        // Delegates to **ECMAScript 5**'s native `Object.keys`
        _.keys = nativeKeys || function(obj) {
            if (obj !== Object(obj)) throw new TypeError("Invalid object");
            var keys = [];
            for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
            return keys;
        };
        // Retrieve the values of an object's properties.
        _.values = function(obj) {
            var values = [];
            for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
            return values;
        };
        // Convert an object into a list of `[key, value]` pairs.
        _.pairs = function(obj) {
            var pairs = [];
            for (var key in obj) if (_.has(obj, key)) pairs.push([ key, obj[key] ]);
            return pairs;
        };
        // Invert the keys and values of an object. The values must be serializable.
        _.invert = function(obj) {
            var result = {};
            for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
            return result;
        };
        // Return a sorted list of the function names available on the object.
        // Aliased as `methods`
        _.functions = _.methods = function(obj) {
            var names = [];
            for (var key in obj) {
                if (_.isFunction(obj[key])) names.push(key);
            }
            return names.sort();
        };
        // Extend a given object with all the properties in passed-in object(s).
        _.extend = function(obj) {
            each(slice.call(arguments, 1), function(source) {
                if (source) {
                    for (var prop in source) {
                        obj[prop] = source[prop];
                    }
                }
            });
            return obj;
        };
        // Return a copy of the object only containing the whitelisted properties.
        _.pick = function(obj) {
            var copy = {};
            var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
            each(keys, function(key) {
                if (key in obj) copy[key] = obj[key];
            });
            return copy;
        };
        // Return a copy of the object without the blacklisted properties.
        _.omit = function(obj) {
            var copy = {};
            var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
            for (var key in obj) {
                if (!_.contains(keys, key)) copy[key] = obj[key];
            }
            return copy;
        };
        // Fill in a given object with default properties.
        _.defaults = function(obj) {
            each(slice.call(arguments, 1), function(source) {
                if (source) {
                    for (var prop in source) {
                        if (obj[prop] == null) obj[prop] = source[prop];
                    }
                }
            });
            return obj;
        };
        // Create a (shallow-cloned) duplicate of an object.
        _.clone = function(obj) {
            if (!_.isObject(obj)) return obj;
            return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
        };
        // Invokes interceptor with the obj, and then returns obj.
        // The primary purpose of this method is to "tap into" a method chain, in
        // order to perform operations on intermediate results within the chain.
        _.tap = function(obj, interceptor) {
            interceptor(obj);
            return obj;
        };
        // Internal recursive comparison function for `isEqual`.
        var eq = function(a, b, aStack, bStack) {
            // Identical objects are equal. `0 === -0`, but they aren't identical.
            // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
            if (a === b) return a !== 0 || 1 / a == 1 / b;
            // A strict comparison is necessary because `null == undefined`.
            if (a == null || b == null) return a === b;
            // Unwrap any wrapped objects.
            if (a instanceof _) a = a._wrapped;
            if (b instanceof _) b = b._wrapped;
            // Compare `[[Class]]` names.
            var className = toString.call(a);
            if (className != toString.call(b)) return false;
            switch (className) {
              // Strings, numbers, dates, and booleans are compared by value.
                case "[object String]":
                // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
                // equivalent to `new String("5")`.
                return a == String(b);

              case "[object Number]":
                // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
                // other numeric values.
                return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;

              case "[object Date]":
              case "[object Boolean]":
                // Coerce dates and booleans to numeric primitive values. Dates are compared by their
                // millisecond representations. Note that invalid dates with millisecond representations
                // of `NaN` are not equivalent.
                return +a == +b;

              // RegExps are compared by their source patterns and flags.
                case "[object RegExp]":
                return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
            }
            if (typeof a != "object" || typeof b != "object") return false;
            // Assume equality for cyclic structures. The algorithm for detecting cyclic
            // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
            var length = aStack.length;
            while (length--) {
                // Linear search. Performance is inversely proportional to the number of
                // unique nested structures.
                if (aStack[length] == a) return bStack[length] == b;
            }
            // Add the first object to the stack of traversed objects.
            aStack.push(a);
            bStack.push(b);
            var size = 0, result = true;
            // Recursively compare objects and arrays.
            if (className == "[object Array]") {
                // Compare array lengths to determine if a deep comparison is necessary.
                size = a.length;
                result = size == b.length;
                if (result) {
                    // Deep compare the contents, ignoring non-numeric properties.
                    while (size--) {
                        if (!(result = eq(a[size], b[size], aStack, bStack))) break;
                    }
                }
            } else {
                // Objects with different constructors are not equivalent, but `Object`s
                // from different frames are.
                var aCtor = a.constructor, bCtor = b.constructor;
                if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor)) {
                    return false;
                }
                // Deep compare objects.
                for (var key in a) {
                    if (_.has(a, key)) {
                        // Count the expected number of properties.
                        size++;
                        // Deep compare each member.
                        if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
                    }
                }
                // Ensure that both objects contain the same number of properties.
                if (result) {
                    for (key in b) {
                        if (_.has(b, key) && !size--) break;
                    }
                    result = !size;
                }
            }
            // Remove the first object from the stack of traversed objects.
            aStack.pop();
            bStack.pop();
            return result;
        };
        // Perform a deep comparison to check if two objects are equal.
        _.isEqual = function(a, b) {
            return eq(a, b, [], []);
        };
        // Is a given array, string, or object empty?
        // An "empty" object has no enumerable own-properties.
        _.isEmpty = function(obj) {
            if (obj == null) return true;
            if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
            for (var key in obj) if (_.has(obj, key)) return false;
            return true;
        };
        // Is a given value a DOM element?
        _.isElement = function(obj) {
            return !!(obj && obj.nodeType === 1);
        };
        // Is a given value an array?
        // Delegates to ECMA5's native Array.isArray
        _.isArray = nativeIsArray || function(obj) {
            return toString.call(obj) == "[object Array]";
        };
        // Is a given variable an object?
        _.isObject = function(obj) {
            return obj === Object(obj);
        };
        // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
        each([ "Arguments", "Function", "String", "Number", "Date", "RegExp" ], function(name) {
            _["is" + name] = function(obj) {
                return toString.call(obj) == "[object " + name + "]";
            };
        });
        // Define a fallback version of the method in browsers (ahem, IE), where
        // there isn't any inspectable "Arguments" type.
        if (!_.isArguments(arguments)) {
            _.isArguments = function(obj) {
                return !!(obj && _.has(obj, "callee"));
            };
        }
        // Optimize `isFunction` if appropriate.
        if (typeof /./ !== "function") {
            _.isFunction = function(obj) {
                return typeof obj === "function";
            };
        }
        // Is a given object a finite number?
        _.isFinite = function(obj) {
            return isFinite(obj) && !isNaN(parseFloat(obj));
        };
        // Is the given value `NaN`? (NaN is the only number which does not equal itself).
        _.isNaN = function(obj) {
            return _.isNumber(obj) && obj != +obj;
        };
        // Is a given value a boolean?
        _.isBoolean = function(obj) {
            return obj === true || obj === false || toString.call(obj) == "[object Boolean]";
        };
        // Is a given value equal to null?
        _.isNull = function(obj) {
            return obj === null;
        };
        // Is a given variable undefined?
        _.isUndefined = function(obj) {
            return obj === void 0;
        };
        // Shortcut function for checking if an object has a given property directly
        // on itself (in other words, not on a prototype).
        _.has = function(obj, key) {
            return hasOwnProperty.call(obj, key);
        };
        // Utility Functions
        // -----------------
        // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
        // previous owner. Returns a reference to the Underscore object.
        _.noConflict = function() {
            root._ = previousUnderscore;
            return this;
        };
        // Keep the identity function around for default iterators.
        _.identity = function(value) {
            return value;
        };
        // Run a function **n** times.
        _.times = function(n, iterator, context) {
            var accum = Array(n);
            for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
            return accum;
        };
        // Return a random integer between min and max (inclusive).
        _.random = function(min, max) {
            if (max == null) {
                max = min;
                min = 0;
            }
            return min + Math.floor(Math.random() * (max - min + 1));
        };
        // List of HTML entities for escaping.
        var entityMap = {
            escape: {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#x27;",
                "/": "&#x2F;"
            }
        };
        entityMap.unescape = _.invert(entityMap.escape);
        // Regexes containing the keys and values listed immediately above.
        var entityRegexes = {
            escape: new RegExp("[" + _.keys(entityMap.escape).join("") + "]", "g"),
            unescape: new RegExp("(" + _.keys(entityMap.unescape).join("|") + ")", "g")
        };
        // Functions for escaping and unescaping strings to/from HTML interpolation.
        _.each([ "escape", "unescape" ], function(method) {
            _[method] = function(string) {
                if (string == null) return "";
                return ("" + string).replace(entityRegexes[method], function(match) {
                    return entityMap[method][match];
                });
            };
        });
        // If the value of the named property is a function then invoke it;
        // otherwise, return it.
        _.result = function(object, property) {
            if (object == null) return null;
            var value = object[property];
            return _.isFunction(value) ? value.call(object) : value;
        };
        // Add your own custom functions to the Underscore object.
        _.mixin = function(obj) {
            each(_.functions(obj), function(name) {
                var func = _[name] = obj[name];
                _.prototype[name] = function() {
                    var args = [ this._wrapped ];
                    push.apply(args, arguments);
                    return result.call(this, func.apply(_, args));
                };
            });
        };
        // Generate a unique integer id (unique within the entire client session).
        // Useful for temporary DOM ids.
        var idCounter = 0;
        _.uniqueId = function(prefix) {
            var id = ++idCounter + "";
            return prefix ? prefix + id : id;
        };
        // By default, Underscore uses ERB-style template delimiters, change the
        // following template settings to use alternative delimiters.
        _.templateSettings = {
            evaluate: /<%([\s\S]+?)%>/g,
            interpolate: /<%=([\s\S]+?)%>/g,
            escape: /<%-([\s\S]+?)%>/g
        };
        // When customizing `templateSettings`, if you don't want to define an
        // interpolation, evaluation or escaping regex, we need one that is
        // guaranteed not to match.
        var noMatch = /(.)^/;
        // Certain characters need to be escaped so that they can be put into a
        // string literal.
        var escapes = {
            "'": "'",
            "\\": "\\",
            "\r": "r",
            "\n": "n",
            "	": "t",
            "\u2028": "u2028",
            "\u2029": "u2029"
        };
        var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
        // JavaScript micro-templating, similar to John Resig's implementation.
        // Underscore templating handles arbitrary delimiters, preserves whitespace,
        // and correctly escapes quotes within interpolated code.
        _.template = function(text, data, settings) {
            var render;
            settings = _.defaults({}, settings, _.templateSettings);
            // Combine delimiters into one regular expression via alternation.
            var matcher = new RegExp([ (settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source ].join("|") + "|$", "g");
            // Compile the template source, escaping string literals appropriately.
            var index = 0;
            var source = "__p+='";
            text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
                source += text.slice(index, offset).replace(escaper, function(match) {
                    return "\\" + escapes[match];
                });
                if (escape) {
                    source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
                }
                if (interpolate) {
                    source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
                }
                if (evaluate) {
                    source += "';\n" + evaluate + "\n__p+='";
                }
                index = offset + match.length;
                return match;
            });
            source += "';\n";
            // If a variable is not specified, place data values in local scope.
            if (!settings.variable) source = "with(obj||{}){\n" + source + "}\n";
            source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
            try {
                render = new Function(settings.variable || "obj", "_", source);
            } catch (e) {
                e.source = source;
                throw e;
            }
            if (data) return render(data, _);
            var template = function(data) {
                return render.call(this, data, _);
            };
            // Provide the compiled function source as a convenience for precompilation.
            template.source = "function(" + (settings.variable || "obj") + "){\n" + source + "}";
            return template;
        };
        // Add a "chain" function, which will delegate to the wrapper.
        _.chain = function(obj) {
            return _(obj).chain();
        };
        // OOP
        // ---------------
        // If Underscore is called as a function, it returns a wrapped object that
        // can be used OO-style. This wrapper holds altered versions of all the
        // underscore functions. Wrapped objects may be chained.
        // Helper function to continue chaining intermediate results.
        var result = function(obj) {
            return this._chain ? _(obj).chain() : obj;
        };
        // Add all of the Underscore functions to the wrapper object.
        _.mixin(_);
        // Add all mutator Array functions to the wrapper.
        each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(name) {
            var method = ArrayProto[name];
            _.prototype[name] = function() {
                var obj = this._wrapped;
                method.apply(obj, arguments);
                if ((name == "shift" || name == "splice") && obj.length === 0) delete obj[0];
                return result.call(this, obj);
            };
        });
        // Add all accessor Array functions to the wrapper.
        each([ "concat", "join", "slice" ], function(name) {
            var method = ArrayProto[name];
            _.prototype[name] = function() {
                return result.call(this, method.apply(this._wrapped, arguments));
            };
        });
        _.extend(_.prototype, {
            // Start chaining a wrapped Underscore object.
            chain: function() {
                this._chain = true;
                return this;
            },
            // Extracts the result from a wrapped and chained object.
            value: function() {
                return this._wrapped;
            }
        });
    }).call(this);
});

define("sarike/timefly/0.0.1/common/common-debug", [ "sarike/timefly/0.0.1/libs/libs-debug", "$-debug", "gallery/underscore/1.4.4/underscore-debug", "gallery/backbone/1.0.0/backbone-debug", "sarike/jquery-ui/1.10.3/jquery-ui-debug", "sarike/jquery-noty/2.1.0/jquery-noty-debug", "sarike/timefly/0.0.1/common/base/base-debug", "sarike/timefly/0.0.1/editor/editor-debug", "sarike/jquery-validate/1.11.1/jquery-validate-debug", "sarike/timefly/0.0.1/common/box/box-debug" ], function(require, exports, module) {
    "use strict";
    var libs = require("sarike/timefly/0.0.1/libs/libs-debug"), $ = require("$-debug"), _ = require("gallery/underscore/1.4.4/underscore-debug"), Base = require("sarike/timefly/0.0.1/common/base/base-debug"), Box = require("sarike/timefly/0.0.1/common/box/box-debug");
    var initSideBar = function(context, sidebarBoxes) {
        if (!sidebarBoxes) {
            return;
        }
        context.sideBar.empty();
        _.each(sidebarBoxes, function(box) {
            if (box.collection) {
                context.sideBar.append(box.render().el);
                box.collection.fetch({
                    success: function(collection) {
                        if (collection.length === 0) {
                            box.renderEmpty();
                        }
                    }
                });
            } else {
                context.sideBar.append(box.render().el);
            }
        }, this);
    };
    var initHeader = function(context, header) {
        context.header.html(header.render().el);
    };
    var initContent = function(context, content) {
        if (content.model) {
            content.model.fetch({
                data: content.model.queryString,
                success: function() {
                    context.content.html(content.render().el);
                }
            });
            return;
        }
        if (content.collection) {
            context.content.html(content.render().el);
            content.collection.fetch({
                data: content.collection.queryString,
                success: function(collection) {
                    if (collection.length === 0) {
                        content.renderEmpty();
                    }
                }
            });
        }
    };
    var initFooter = function(context, footer) {
        context.footer.html(footer.render().el);
    };
    module.exports = {
        Models: Base.Models,
        Collections: Base.Collections,
        Views: Base.Views,
        Box: Box,
        init: function(context, options) {
            initHeader(context, options.header || new Base.Views.Header({
                user: context.user,
                content: options.content
            }));
            initSideBar(context, options.sideBarBoxes);
            initContent(context, options.content || new Base.Views.Content());
            initFooter(context, options.footer || new Base.Views.Footer());
        }
    };
});

/**
 * Created with PyCharm.
 * User: Administrator
 * Date: 13-9-13
 * Time: 下午8:04
 * To change this template use File | Settings | File Templates.
 */
define("sarike/timefly/0.0.1/libs/libs-debug", [ "$-debug", "gallery/underscore/1.4.4/underscore-debug", "gallery/backbone/1.0.0/backbone-debug", "sarike/jquery-ui/1.10.3/jquery-ui-debug", "sarike/jquery-noty/2.1.0/jquery-noty-debug" ], function(require, exports, module) {
    "use strict";
    var Noty, JQueryUI, Dialog, $ = require("$-debug"), _ = require("gallery/underscore/1.4.4/underscore-debug"), Backbone = require("gallery/backbone/1.0.0/backbone-debug"), ui = require("sarike/jquery-ui/1.10.3/jquery-ui-debug"), noty = require("sarike/jquery-noty/2.1.0/jquery-noty-debug");
    /**
     * var dialog = new Dialog({
     *     content: content,
     *     config: { }
     * })
     */
    Dialog = Backbone.View.extend({
        _getButton: function(text, click) {
            return {
                text: text,
                click: click
            };
        },
        defaultConfig: {
            show: true,
            resizable: true
        },
        tpl_data: {},
        initialize: function() {
            var okButton = this._getButton("确定", $.proxy(this.ok, this)), cancelButton = this._getButton("取消", $.proxy(this.cancel, this));
            this.defaultConfig.buttons = [ okButton, cancelButton ];
            this.extraInitialize();
        },
        extraInitialize: function() {},
        ok: function() {
            console.warn("This is the default okClick, maybe you shoud override ok Func!");
        },
        cancel: function() {
            this.close();
        },
        render: function() {
            this.$el.html(this.template(this.tpl_data));
            this.extraRender();
            return this;
        },
        extraRender: function() {},
        open: function(config) {
            this.render();
            this.$el.dialog(_.extend(this.defaultConfig, config));
        },
        close: function() {
            this.$el.dialog("destroy");
        }
    });
    $.datepicker.setDefaults({
        autoSize: true,
        showAnim: "slideDown",
        closeText: "关闭",
        prevText: "&#x3C;上月",
        nextText: "下月&#x3E;",
        currentText: "今天",
        monthNames: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月" ],
        monthNamesShort: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月" ],
        dayNames: [ "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" ],
        dayNamesShort: [ "周日", "周一", "周二", "周三", "周四", "周五", "周六" ],
        dayNamesMin: [ "日", "一", "二", "三", "四", "五", "六" ],
        weekHeader: "周",
        dateFormat: "yy-mm-dd",
        firstDay: 1,
        isRTL: false,
        showMonthAfterYear: true,
        yearSuffix: "年"
    });
    JQueryUI = {
        Dialog: Dialog
    };
    Noty = {
        noty: function(type, info) {
            noty({
                type: type,
                layout: "center",
                text: info,
                timeout: 1e3
            });
        },
        NotyWithRes: function(res) {
            noty({
                type: res.type,
                layout: res.layout,
                text: res.info,
                timeout: 1e3
            });
        },
        Confirm: function(options) {
            var ok_button, cancel_button;
            ok_button = {
                addClass: "btn btn-primary",
                text: "Ok",
                onClick: options.ok || function(noty) {
                    noty.close();
                }
            };
            cancel_button = {
                addClass: "btn btn-danger",
                text: "Cancel",
                onClick: options.cancel || function(noty) {
                    noty.close();
                }
            };
            noty({
                type: options.type || "information",
                layout: options.layout || "center",
                text: options.text || "你确定吗？",
                buttons: [ ok_button, cancel_button ]
            });
        }
    };
    module.exports = {
        JQueryUI: JQueryUI,
        Noty: Noty
    };
});

define("sarike/jquery-ui/1.10.3/jquery-ui-debug", [ "$-debug" ], function(require, exports, module) {
    var $ = require("$-debug");
    /*! jQuery UI - v1.10.3 - 2013-05-03
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.ui.effect.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.position.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
* Copyright 2013 jQuery Foundation and other contributors; Licensed MIT */
    (function($, undefined) {
        var uuid = 0, runiqueId = /^ui-id-\d+$/;
        // $.ui might exist from components with no dependencies, e.g., $.ui.position
        $.ui = $.ui || {};
        $.extend($.ui, {
            version: "1.10.3",
            keyCode: {
                BACKSPACE: 8,
                COMMA: 188,
                DELETE: 46,
                DOWN: 40,
                END: 35,
                ENTER: 13,
                ESCAPE: 27,
                HOME: 36,
                LEFT: 37,
                NUMPAD_ADD: 107,
                NUMPAD_DECIMAL: 110,
                NUMPAD_DIVIDE: 111,
                NUMPAD_ENTER: 108,
                NUMPAD_MULTIPLY: 106,
                NUMPAD_SUBTRACT: 109,
                PAGE_DOWN: 34,
                PAGE_UP: 33,
                PERIOD: 190,
                RIGHT: 39,
                SPACE: 32,
                TAB: 9,
                UP: 38
            }
        });
        // plugins
        $.fn.extend({
            focus: function(orig) {
                return function(delay, fn) {
                    return typeof delay === "number" ? this.each(function() {
                        var elem = this;
                        setTimeout(function() {
                            $(elem).focus();
                            if (fn) {
                                fn.call(elem);
                            }
                        }, delay);
                    }) : orig.apply(this, arguments);
                };
            }($.fn.focus),
            scrollParent: function() {
                var scrollParent;
                if ($.ui.ie && /(static|relative)/.test(this.css("position")) || /absolute/.test(this.css("position"))) {
                    scrollParent = this.parents().filter(function() {
                        return /(relative|absolute|fixed)/.test($.css(this, "position")) && /(auto|scroll)/.test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
                    }).eq(0);
                } else {
                    scrollParent = this.parents().filter(function() {
                        return /(auto|scroll)/.test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
                    }).eq(0);
                }
                return /fixed/.test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
            },
            zIndex: function(zIndex) {
                if (zIndex !== undefined) {
                    return this.css("zIndex", zIndex);
                }
                if (this.length) {
                    var elem = $(this[0]), position, value;
                    while (elem.length && elem[0] !== document) {
                        // Ignore z-index if position is set to a value where z-index is ignored by the browser
                        // This makes behavior of this function consistent across browsers
                        // WebKit always returns auto if the element is positioned
                        position = elem.css("position");
                        if (position === "absolute" || position === "relative" || position === "fixed") {
                            // IE returns 0 when zIndex is not specified
                            // other browsers return a string
                            // we ignore the case of nested elements with an explicit value of 0
                            // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                            value = parseInt(elem.css("zIndex"), 10);
                            if (!isNaN(value) && value !== 0) {
                                return value;
                            }
                        }
                        elem = elem.parent();
                    }
                }
                return 0;
            },
            uniqueId: function() {
                return this.each(function() {
                    if (!this.id) {
                        this.id = "ui-id-" + ++uuid;
                    }
                });
            },
            removeUniqueId: function() {
                return this.each(function() {
                    if (runiqueId.test(this.id)) {
                        $(this).removeAttr("id");
                    }
                });
            }
        });
        // selectors
        function focusable(element, isTabIndexNotNaN) {
            var map, mapName, img, nodeName = element.nodeName.toLowerCase();
            if ("area" === nodeName) {
                map = element.parentNode;
                mapName = map.name;
                if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
                    return false;
                }
                img = $("img[usemap=#" + mapName + "]")[0];
                return !!img && visible(img);
            }
            return (/input|select|textarea|button|object/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && // the element and all of its ancestors must be visible
            visible(element);
        }
        function visible(element) {
            return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function() {
                return $.css(this, "visibility") === "hidden";
            }).length;
        }
        $.extend($.expr[":"], {
            data: $.expr.createPseudo ? $.expr.createPseudo(function(dataName) {
                return function(elem) {
                    return !!$.data(elem, dataName);
                };
            }) : // support: jQuery <1.8
            function(elem, i, match) {
                return !!$.data(elem, match[3]);
            },
            focusable: function(element) {
                return focusable(element, !isNaN($.attr(element, "tabindex")));
            },
            tabbable: function(element) {
                var tabIndex = $.attr(element, "tabindex"), isTabIndexNaN = isNaN(tabIndex);
                return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
            }
        });
        // support: jQuery <1.8
        if (!$("<a>").outerWidth(1).jquery) {
            $.each([ "Width", "Height" ], function(i, name) {
                var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ], type = name.toLowerCase(), orig = {
                    innerWidth: $.fn.innerWidth,
                    innerHeight: $.fn.innerHeight,
                    outerWidth: $.fn.outerWidth,
                    outerHeight: $.fn.outerHeight
                };
                function reduce(elem, size, border, margin) {
                    $.each(side, function() {
                        size -= parseFloat($.css(elem, "padding" + this)) || 0;
                        if (border) {
                            size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
                        }
                        if (margin) {
                            size -= parseFloat($.css(elem, "margin" + this)) || 0;
                        }
                    });
                    return size;
                }
                $.fn["inner" + name] = function(size) {
                    if (size === undefined) {
                        return orig["inner" + name].call(this);
                    }
                    return this.each(function() {
                        $(this).css(type, reduce(this, size) + "px");
                    });
                };
                $.fn["outer" + name] = function(size, margin) {
                    if (typeof size !== "number") {
                        return orig["outer" + name].call(this, size);
                    }
                    return this.each(function() {
                        $(this).css(type, reduce(this, size, true, margin) + "px");
                    });
                };
            });
        }
        // support: jQuery <1.8
        if (!$.fn.addBack) {
            $.fn.addBack = function(selector) {
                return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
            };
        }
        // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
        if ($("<a>").data("a-b", "a").removeData("a-b").data("a-b")) {
            $.fn.removeData = function(removeData) {
                return function(key) {
                    if (arguments.length) {
                        return removeData.call(this, $.camelCase(key));
                    } else {
                        return removeData.call(this);
                    }
                };
            }($.fn.removeData);
        }
        // deprecated
        $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
        $.support.selectstart = "onselectstart" in document.createElement("div");
        $.fn.extend({
            disableSelection: function() {
                return this.bind(($.support.selectstart ? "selectstart" : "mousedown") + ".ui-disableSelection", function(event) {
                    event.preventDefault();
                });
            },
            enableSelection: function() {
                return this.unbind(".ui-disableSelection");
            }
        });
        $.extend($.ui, {
            // $.ui.plugin is deprecated. Use $.widget() extensions instead.
            plugin: {
                add: function(module, option, set) {
                    var i, proto = $.ui[module].prototype;
                    for (i in set) {
                        proto.plugins[i] = proto.plugins[i] || [];
                        proto.plugins[i].push([ option, set[i] ]);
                    }
                },
                call: function(instance, name, args) {
                    var i, set = instance.plugins[name];
                    if (!set || !instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11) {
                        return;
                    }
                    for (i = 0; i < set.length; i++) {
                        if (instance.options[set[i][0]]) {
                            set[i][1].apply(instance.element, args);
                        }
                    }
                }
            },
            // only used by resizable
            hasScroll: function(el, a) {
                //If overflow is hidden, the element might have extra content, but the user wants to hide it
                if ($(el).css("overflow") === "hidden") {
                    return false;
                }
                var scroll = a && a === "left" ? "scrollLeft" : "scrollTop", has = false;
                if (el[scroll] > 0) {
                    return true;
                }
                // TODO: determine which cases actually cause this to happen
                // if the element doesn't have the scroll set, see if it's possible to
                // set the scroll
                el[scroll] = 1;
                has = el[scroll] > 0;
                el[scroll] = 0;
                return has;
            }
        });
    })(jQuery);
    (function($, undefined) {
        var uuid = 0, slice = Array.prototype.slice, _cleanData = $.cleanData;
        $.cleanData = function(elems) {
            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                try {
                    $(elem).triggerHandler("remove");
                } catch (e) {}
            }
            _cleanData(elems);
        };
        $.widget = function(name, base, prototype) {
            var fullName, existingConstructor, constructor, basePrototype, // proxiedPrototype allows the provided prototype to remain unmodified
            // so that it can be used as a mixin for multiple widgets (#8876)
            proxiedPrototype = {}, namespace = name.split(".")[0];
            name = name.split(".")[1];
            fullName = namespace + "-" + name;
            if (!prototype) {
                prototype = base;
                base = $.Widget;
            }
            // create selector for plugin
            $.expr[":"][fullName.toLowerCase()] = function(elem) {
                return !!$.data(elem, fullName);
            };
            $[namespace] = $[namespace] || {};
            existingConstructor = $[namespace][name];
            constructor = $[namespace][name] = function(options, element) {
                // allow instantiation without "new" keyword
                if (!this._createWidget) {
                    return new constructor(options, element);
                }
                // allow instantiation without initializing for simple inheritance
                // must use "new" keyword (the code above always passes args)
                if (arguments.length) {
                    this._createWidget(options, element);
                }
            };
            // extend with the existing constructor to carry over any static properties
            $.extend(constructor, existingConstructor, {
                version: prototype.version,
                // copy the object used to create the prototype in case we need to
                // redefine the widget later
                _proto: $.extend({}, prototype),
                // track widgets that inherit from this widget in case this widget is
                // redefined after a widget inherits from it
                _childConstructors: []
            });
            basePrototype = new base();
            // we need to make the options hash a property directly on the new instance
            // otherwise we'll modify the options hash on the prototype that we're
            // inheriting from
            basePrototype.options = $.widget.extend({}, basePrototype.options);
            $.each(prototype, function(prop, value) {
                if (!$.isFunction(value)) {
                    proxiedPrototype[prop] = value;
                    return;
                }
                proxiedPrototype[prop] = function() {
                    var _super = function() {
                        return base.prototype[prop].apply(this, arguments);
                    }, _superApply = function(args) {
                        return base.prototype[prop].apply(this, args);
                    };
                    return function() {
                        var __super = this._super, __superApply = this._superApply, returnValue;
                        this._super = _super;
                        this._superApply = _superApply;
                        returnValue = value.apply(this, arguments);
                        this._super = __super;
                        this._superApply = __superApply;
                        return returnValue;
                    };
                }();
            });
            constructor.prototype = $.widget.extend(basePrototype, {
                // TODO: remove support for widgetEventPrefix
                // always use the name + a colon as the prefix, e.g., draggable:start
                // don't prefix for widgets that aren't DOM-based
                widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
            }, proxiedPrototype, {
                constructor: constructor,
                namespace: namespace,
                widgetName: name,
                widgetFullName: fullName
            });
            // If this widget is being redefined then we need to find all widgets that
            // are inheriting from it and redefine all of them so that they inherit from
            // the new version of this widget. We're essentially trying to replace one
            // level in the prototype chain.
            if (existingConstructor) {
                $.each(existingConstructor._childConstructors, function(i, child) {
                    var childPrototype = child.prototype;
                    // redefine the child widget using the same prototype that was
                    // originally used, but inherit from the new version of the base
                    $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
                });
                // remove the list of existing child constructors from the old constructor
                // so the old child constructors can be garbage collected
                delete existingConstructor._childConstructors;
            } else {
                base._childConstructors.push(constructor);
            }
            $.widget.bridge(name, constructor);
        };
        $.widget.extend = function(target) {
            var input = slice.call(arguments, 1), inputIndex = 0, inputLength = input.length, key, value;
            for (;inputIndex < inputLength; inputIndex++) {
                for (key in input[inputIndex]) {
                    value = input[inputIndex][key];
                    if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
                        // Clone objects
                        if ($.isPlainObject(value)) {
                            target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : // Don't extend strings, arrays, etc. with objects
                            $.widget.extend({}, value);
                        } else {
                            target[key] = value;
                        }
                    }
                }
            }
            return target;
        };
        $.widget.bridge = function(name, object) {
            var fullName = object.prototype.widgetFullName || name;
            $.fn[name] = function(options) {
                var isMethodCall = typeof options === "string", args = slice.call(arguments, 1), returnValue = this;
                // allow multiple hashes to be passed on init
                options = !isMethodCall && args.length ? $.widget.extend.apply(null, [ options ].concat(args)) : options;
                if (isMethodCall) {
                    this.each(function() {
                        var methodValue, instance = $.data(this, fullName);
                        if (!instance) {
                            return $.error("cannot call methods on " + name + " prior to initialization; " + "attempted to call method '" + options + "'");
                        }
                        if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                            return $.error("no such method '" + options + "' for " + name + " widget instance");
                        }
                        methodValue = instance[options].apply(instance, args);
                        if (methodValue !== instance && methodValue !== undefined) {
                            returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
                            return false;
                        }
                    });
                } else {
                    this.each(function() {
                        var instance = $.data(this, fullName);
                        if (instance) {
                            instance.option(options || {})._init();
                        } else {
                            $.data(this, fullName, new object(options, this));
                        }
                    });
                }
                return returnValue;
            };
        };
        $.Widget = function() {};
        $.Widget._childConstructors = [];
        $.Widget.prototype = {
            widgetName: "widget",
            widgetEventPrefix: "",
            defaultElement: "<div>",
            options: {
                disabled: false,
                // callbacks
                create: null
            },
            _createWidget: function(options, element) {
                element = $(element || this.defaultElement || this)[0];
                this.element = $(element);
                this.uuid = uuid++;
                this.eventNamespace = "." + this.widgetName + this.uuid;
                this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);
                this.bindings = $();
                this.hoverable = $();
                this.focusable = $();
                if (element !== this) {
                    $.data(element, this.widgetFullName, this);
                    this._on(true, this.element, {
                        remove: function(event) {
                            if (event.target === element) {
                                this.destroy();
                            }
                        }
                    });
                    this.document = $(element.style ? // element within the document
                    element.ownerDocument : // element is window or document
                    element.document || element);
                    this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
                }
                this._create();
                this._trigger("create", null, this._getCreateEventData());
                this._init();
            },
            _getCreateOptions: $.noop,
            _getCreateEventData: $.noop,
            _create: $.noop,
            _init: $.noop,
            destroy: function() {
                this._destroy();
                // we can probably remove the unbind calls in 2.0
                // all event bindings should go through this._on()
                this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName));
                this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled " + "ui-state-disabled");
                // clean up events and states
                this.bindings.unbind(this.eventNamespace);
                this.hoverable.removeClass("ui-state-hover");
                this.focusable.removeClass("ui-state-focus");
            },
            _destroy: $.noop,
            widget: function() {
                return this.element;
            },
            option: function(key, value) {
                var options = key, parts, curOption, i;
                if (arguments.length === 0) {
                    // don't return a reference to the internal hash
                    return $.widget.extend({}, this.options);
                }
                if (typeof key === "string") {
                    // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                    options = {};
                    parts = key.split(".");
                    key = parts.shift();
                    if (parts.length) {
                        curOption = options[key] = $.widget.extend({}, this.options[key]);
                        for (i = 0; i < parts.length - 1; i++) {
                            curOption[parts[i]] = curOption[parts[i]] || {};
                            curOption = curOption[parts[i]];
                        }
                        key = parts.pop();
                        if (value === undefined) {
                            return curOption[key] === undefined ? null : curOption[key];
                        }
                        curOption[key] = value;
                    } else {
                        if (value === undefined) {
                            return this.options[key] === undefined ? null : this.options[key];
                        }
                        options[key] = value;
                    }
                }
                this._setOptions(options);
                return this;
            },
            _setOptions: function(options) {
                var key;
                for (key in options) {
                    this._setOption(key, options[key]);
                }
                return this;
            },
            _setOption: function(key, value) {
                this.options[key] = value;
                if (key === "disabled") {
                    this.widget().toggleClass(this.widgetFullName + "-disabled ui-state-disabled", !!value).attr("aria-disabled", value);
                    this.hoverable.removeClass("ui-state-hover");
                    this.focusable.removeClass("ui-state-focus");
                }
                return this;
            },
            enable: function() {
                return this._setOption("disabled", false);
            },
            disable: function() {
                return this._setOption("disabled", true);
            },
            _on: function(suppressDisabledCheck, element, handlers) {
                var delegateElement, instance = this;
                // no suppressDisabledCheck flag, shuffle arguments
                if (typeof suppressDisabledCheck !== "boolean") {
                    handlers = element;
                    element = suppressDisabledCheck;
                    suppressDisabledCheck = false;
                }
                // no element argument, shuffle and use this.element
                if (!handlers) {
                    handlers = element;
                    element = this.element;
                    delegateElement = this.widget();
                } else {
                    // accept selectors, DOM elements
                    element = delegateElement = $(element);
                    this.bindings = this.bindings.add(element);
                }
                $.each(handlers, function(event, handler) {
                    function handlerProxy() {
                        // allow widgets to customize the disabled handling
                        // - disabled as an array instead of boolean
                        // - disabled class as method for disabling individual parts
                        if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass("ui-state-disabled"))) {
                            return;
                        }
                        return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
                    }
                    // copy the guid so direct unbinding works
                    if (typeof handler !== "string") {
                        handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
                    }
                    var match = event.match(/^(\w+)\s*(.*)$/), eventName = match[1] + instance.eventNamespace, selector = match[2];
                    if (selector) {
                        delegateElement.delegate(selector, eventName, handlerProxy);
                    } else {
                        element.bind(eventName, handlerProxy);
                    }
                });
            },
            _off: function(element, eventName) {
                eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
                element.unbind(eventName).undelegate(eventName);
            },
            _delay: function(handler, delay) {
                function handlerProxy() {
                    return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
                }
                var instance = this;
                return setTimeout(handlerProxy, delay || 0);
            },
            _hoverable: function(element) {
                this.hoverable = this.hoverable.add(element);
                this._on(element, {
                    mouseenter: function(event) {
                        $(event.currentTarget).addClass("ui-state-hover");
                    },
                    mouseleave: function(event) {
                        $(event.currentTarget).removeClass("ui-state-hover");
                    }
                });
            },
            _focusable: function(element) {
                this.focusable = this.focusable.add(element);
                this._on(element, {
                    focusin: function(event) {
                        $(event.currentTarget).addClass("ui-state-focus");
                    },
                    focusout: function(event) {
                        $(event.currentTarget).removeClass("ui-state-focus");
                    }
                });
            },
            _trigger: function(type, event, data) {
                var prop, orig, callback = this.options[type];
                data = data || {};
                event = $.Event(event);
                event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();
                // the original event may come from any element
                // so we need to reset the target on the new event
                event.target = this.element[0];
                // copy original event properties over to the new event
                orig = event.originalEvent;
                if (orig) {
                    for (prop in orig) {
                        if (!(prop in event)) {
                            event[prop] = orig[prop];
                        }
                    }
                }
                this.element.trigger(event, data);
                return !($.isFunction(callback) && callback.apply(this.element[0], [ event ].concat(data)) === false || event.isDefaultPrevented());
            }
        };
        $.each({
            show: "fadeIn",
            hide: "fadeOut"
        }, function(method, defaultEffect) {
            $.Widget.prototype["_" + method] = function(element, options, callback) {
                if (typeof options === "string") {
                    options = {
                        effect: options
                    };
                }
                var hasOptions, effectName = !options ? method : options === true || typeof options === "number" ? defaultEffect : options.effect || defaultEffect;
                options = options || {};
                if (typeof options === "number") {
                    options = {
                        duration: options
                    };
                }
                hasOptions = !$.isEmptyObject(options);
                options.complete = callback;
                if (options.delay) {
                    element.delay(options.delay);
                }
                if (hasOptions && $.effects && $.effects.effect[effectName]) {
                    element[method](options);
                } else if (effectName !== method && element[effectName]) {
                    element[effectName](options.duration, options.easing, callback);
                } else {
                    element.queue(function(next) {
                        $(this)[method]();
                        if (callback) {
                            callback.call(element[0]);
                        }
                        next();
                    });
                }
            };
        });
    })(jQuery);
    (function($, undefined) {
        var mouseHandled = false;
        $(document).mouseup(function() {
            mouseHandled = false;
        });
        $.widget("ui.mouse", {
            version: "1.10.3",
            options: {
                cancel: "input,textarea,button,select,option",
                distance: 1,
                delay: 0
            },
            _mouseInit: function() {
                var that = this;
                this.element.bind("mousedown." + this.widgetName, function(event) {
                    return that._mouseDown(event);
                }).bind("click." + this.widgetName, function(event) {
                    if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
                        $.removeData(event.target, that.widgetName + ".preventClickEvent");
                        event.stopImmediatePropagation();
                        return false;
                    }
                });
                this.started = false;
            },
            // TODO: make sure destroying one instance of mouse doesn't mess with
            // other instances of mouse
            _mouseDestroy: function() {
                this.element.unbind("." + this.widgetName);
                if (this._mouseMoveDelegate) {
                    $(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
                }
            },
            _mouseDown: function(event) {
                // don't let more than one widget handle mouseStart
                if (mouseHandled) {
                    return;
                }
                // we may have missed mouseup (out of window)
                this._mouseStarted && this._mouseUp(event);
                this._mouseDownEvent = event;
                var that = this, btnIsLeft = event.which === 1, // event.target.nodeName works around a bug in IE 8 with
                // disabled inputs (#7620)
                elIsCancel = typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false;
                if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
                    return true;
                }
                this.mouseDelayMet = !this.options.delay;
                if (!this.mouseDelayMet) {
                    this._mouseDelayTimer = setTimeout(function() {
                        that.mouseDelayMet = true;
                    }, this.options.delay);
                }
                if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                    this._mouseStarted = this._mouseStart(event) !== false;
                    if (!this._mouseStarted) {
                        event.preventDefault();
                        return true;
                    }
                }
                // Click event may never have fired (Gecko & Opera)
                if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
                    $.removeData(event.target, this.widgetName + ".preventClickEvent");
                }
                // these delegates are required to keep context
                this._mouseMoveDelegate = function(event) {
                    return that._mouseMove(event);
                };
                this._mouseUpDelegate = function(event) {
                    return that._mouseUp(event);
                };
                $(document).bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate);
                event.preventDefault();
                mouseHandled = true;
                return true;
            },
            _mouseMove: function(event) {
                // IE mouseup check - mouseup happened when mouse was out of window
                if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
                    return this._mouseUp(event);
                }
                if (this._mouseStarted) {
                    this._mouseDrag(event);
                    return event.preventDefault();
                }
                if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                    this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== false;
                    this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event);
                }
                return !this._mouseStarted;
            },
            _mouseUp: function(event) {
                $(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
                if (this._mouseStarted) {
                    this._mouseStarted = false;
                    if (event.target === this._mouseDownEvent.target) {
                        $.data(event.target, this.widgetName + ".preventClickEvent", true);
                    }
                    this._mouseStop(event);
                }
                return false;
            },
            _mouseDistanceMet: function(event) {
                return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance;
            },
            _mouseDelayMet: function() {
                return this.mouseDelayMet;
            },
            // These are placeholder methods, to be overriden by extending plugin
            _mouseStart: function() {},
            _mouseDrag: function() {},
            _mouseStop: function() {},
            _mouseCapture: function() {
                return true;
            }
        });
    })(jQuery);
    (function($, undefined) {
        $.widget("ui.draggable", $.ui.mouse, {
            version: "1.10.3",
            widgetEventPrefix: "drag",
            options: {
                addClasses: true,
                appendTo: "parent",
                axis: false,
                connectToSortable: false,
                containment: false,
                cursor: "auto",
                cursorAt: false,
                grid: false,
                handle: false,
                helper: "original",
                iframeFix: false,
                opacity: false,
                refreshPositions: false,
                revert: false,
                revertDuration: 500,
                scope: "default",
                scroll: true,
                scrollSensitivity: 20,
                scrollSpeed: 20,
                snap: false,
                snapMode: "both",
                snapTolerance: 20,
                stack: false,
                zIndex: false,
                // callbacks
                drag: null,
                start: null,
                stop: null
            },
            _create: function() {
                if (this.options.helper === "original" && !/^(?:r|a|f)/.test(this.element.css("position"))) {
                    this.element[0].style.position = "relative";
                }
                if (this.options.addClasses) {
                    this.element.addClass("ui-draggable");
                }
                if (this.options.disabled) {
                    this.element.addClass("ui-draggable-disabled");
                }
                this._mouseInit();
            },
            _destroy: function() {
                this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled");
                this._mouseDestroy();
            },
            _mouseCapture: function(event) {
                var o = this.options;
                // among others, prevent a drag on a resizable-handle
                if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
                    return false;
                }
                //Quit if we're not on a valid handle
                this.handle = this._getHandle(event);
                if (!this.handle) {
                    return false;
                }
                $(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
                    $("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>").css({
                        width: this.offsetWidth + "px",
                        height: this.offsetHeight + "px",
                        position: "absolute",
                        opacity: "0.001",
                        zIndex: 1e3
                    }).css($(this).offset()).appendTo("body");
                });
                return true;
            },
            _mouseStart: function(event) {
                var o = this.options;
                //Create and append the visible helper
                this.helper = this._createHelper(event);
                this.helper.addClass("ui-draggable-dragging");
                //Cache the helper size
                this._cacheHelperProportions();
                //If ddmanager is used for droppables, set the global draggable
                if ($.ui.ddmanager) {
                    $.ui.ddmanager.current = this;
                }
                /*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */
                //Cache the margins of the original element
                this._cacheMargins();
                //Store the helper's css position
                this.cssPosition = this.helper.css("position");
                this.scrollParent = this.helper.scrollParent();
                this.offsetParent = this.helper.offsetParent();
                this.offsetParentCssPosition = this.offsetParent.css("position");
                //The element's absolute position on the page minus margins
                this.offset = this.positionAbs = this.element.offset();
                this.offset = {
                    top: this.offset.top - this.margins.top,
                    left: this.offset.left - this.margins.left
                };
                //Reset scroll cache
                this.offset.scroll = false;
                $.extend(this.offset, {
                    click: {
                        //Where the click happened, relative to the element
                        left: event.pageX - this.offset.left,
                        top: event.pageY - this.offset.top
                    },
                    parent: this._getParentOffset(),
                    relative: this._getRelativeOffset()
                });
                //Generate the original position
                this.originalPosition = this.position = this._generatePosition(event);
                this.originalPageX = event.pageX;
                this.originalPageY = event.pageY;
                //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
                o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
                //Set a containment if given in the options
                this._setContainment();
                //Trigger event + callbacks
                if (this._trigger("start", event) === false) {
                    this._clear();
                    return false;
                }
                //Recache the helper size
                this._cacheHelperProportions();
                //Prepare the droppable offsets
                if ($.ui.ddmanager && !o.dropBehaviour) {
                    $.ui.ddmanager.prepareOffsets(this, event);
                }
                this._mouseDrag(event, true);
                //Execute the drag once - this causes the helper not to be visible before getting its correct position
                //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
                if ($.ui.ddmanager) {
                    $.ui.ddmanager.dragStart(this, event);
                }
                return true;
            },
            _mouseDrag: function(event, noPropagation) {
                // reset any necessary cached properties (see #5009)
                if (this.offsetParentCssPosition === "fixed") {
                    this.offset.parent = this._getParentOffset();
                }
                //Compute the helpers position
                this.position = this._generatePosition(event);
                this.positionAbs = this._convertPositionTo("absolute");
                //Call plugins and callbacks and use the resulting position if something is returned
                if (!noPropagation) {
                    var ui = this._uiHash();
                    if (this._trigger("drag", event, ui) === false) {
                        this._mouseUp({});
                        return false;
                    }
                    this.position = ui.position;
                }
                if (!this.options.axis || this.options.axis !== "y") {
                    this.helper[0].style.left = this.position.left + "px";
                }
                if (!this.options.axis || this.options.axis !== "x") {
                    this.helper[0].style.top = this.position.top + "px";
                }
                if ($.ui.ddmanager) {
                    $.ui.ddmanager.drag(this, event);
                }
                return false;
            },
            _mouseStop: function(event) {
                //If we are using droppables, inform the manager about the drop
                var that = this, dropped = false;
                if ($.ui.ddmanager && !this.options.dropBehaviour) {
                    dropped = $.ui.ddmanager.drop(this, event);
                }
                //if a drop comes from outside (a sortable)
                if (this.dropped) {
                    dropped = this.dropped;
                    this.dropped = false;
                }
                //if the original element is no longer in the DOM don't bother to continue (see #8269)
                if (this.options.helper === "original" && !$.contains(this.element[0].ownerDocument, this.element[0])) {
                    return false;
                }
                if (this.options.revert === "invalid" && !dropped || this.options.revert === "valid" && dropped || this.options.revert === true || $.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped)) {
                    $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
                        if (that._trigger("stop", event) !== false) {
                            that._clear();
                        }
                    });
                } else {
                    if (this._trigger("stop", event) !== false) {
                        this._clear();
                    }
                }
                return false;
            },
            _mouseUp: function(event) {
                //Remove frame helpers
                $("div.ui-draggable-iframeFix").each(function() {
                    this.parentNode.removeChild(this);
                });
                //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
                if ($.ui.ddmanager) {
                    $.ui.ddmanager.dragStop(this, event);
                }
                return $.ui.mouse.prototype._mouseUp.call(this, event);
            },
            cancel: function() {
                if (this.helper.is(".ui-draggable-dragging")) {
                    this._mouseUp({});
                } else {
                    this._clear();
                }
                return this;
            },
            _getHandle: function(event) {
                return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : true;
            },
            _createHelper: function(event) {
                var o = this.options, helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [ event ])) : o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element;
                if (!helper.parents("body").length) {
                    helper.appendTo(o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo);
                }
                if (helper[0] !== this.element[0] && !/(fixed|absolute)/.test(helper.css("position"))) {
                    helper.css("position", "absolute");
                }
                return helper;
            },
            _adjustOffsetFromHelper: function(obj) {
                if (typeof obj === "string") {
                    obj = obj.split(" ");
                }
                if ($.isArray(obj)) {
                    obj = {
                        left: +obj[0],
                        top: +obj[1] || 0
                    };
                }
                if ("left" in obj) {
                    this.offset.click.left = obj.left + this.margins.left;
                }
                if ("right" in obj) {
                    this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
                }
                if ("top" in obj) {
                    this.offset.click.top = obj.top + this.margins.top;
                }
                if ("bottom" in obj) {
                    this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
                }
            },
            _getParentOffset: function() {
                //Get the offsetParent and cache its position
                var po = this.offsetParent.offset();
                // This is a special case where we need to modify a offset calculated on start, since the following happened:
                // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
                // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
                //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
                if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                    po.left += this.scrollParent.scrollLeft();
                    po.top += this.scrollParent.scrollTop();
                }
                //This needs to be actually done for all browsers, since pageX/pageY includes this information
                //Ugly IE fix
                if (this.offsetParent[0] === document.body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie) {
                    po = {
                        top: 0,
                        left: 0
                    };
                }
                return {
                    top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                    left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
                };
            },
            _getRelativeOffset: function() {
                if (this.cssPosition === "relative") {
                    var p = this.element.position();
                    return {
                        top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                        left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                    };
                } else {
                    return {
                        top: 0,
                        left: 0
                    };
                }
            },
            _cacheMargins: function() {
                this.margins = {
                    left: parseInt(this.element.css("marginLeft"), 10) || 0,
                    top: parseInt(this.element.css("marginTop"), 10) || 0,
                    right: parseInt(this.element.css("marginRight"), 10) || 0,
                    bottom: parseInt(this.element.css("marginBottom"), 10) || 0
                };
            },
            _cacheHelperProportions: function() {
                this.helperProportions = {
                    width: this.helper.outerWidth(),
                    height: this.helper.outerHeight()
                };
            },
            _setContainment: function() {
                var over, c, ce, o = this.options;
                if (!o.containment) {
                    this.containment = null;
                    return;
                }
                if (o.containment === "window") {
                    this.containment = [ $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left, $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ];
                    return;
                }
                if (o.containment === "document") {
                    this.containment = [ 0, 0, $(document).width() - this.helperProportions.width - this.margins.left, ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ];
                    return;
                }
                if (o.containment.constructor === Array) {
                    this.containment = o.containment;
                    return;
                }
                if (o.containment === "parent") {
                    o.containment = this.helper[0].parentNode;
                }
                c = $(o.containment);
                ce = c[0];
                if (!ce) {
                    return;
                }
                over = c.css("overflow") !== "hidden";
                this.containment = [ (parseInt(c.css("borderLeftWidth"), 10) || 0) + (parseInt(c.css("paddingLeft"), 10) || 0), (parseInt(c.css("borderTopWidth"), 10) || 0) + (parseInt(c.css("paddingTop"), 10) || 0), (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css("borderRightWidth"), 10) || 0) - (parseInt(c.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css("borderBottomWidth"), 10) || 0) - (parseInt(c.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom ];
                this.relative_container = c;
            },
            _convertPositionTo: function(d, pos) {
                if (!pos) {
                    pos = this.position;
                }
                var mod = d === "absolute" ? 1 : -1, scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent;
                //Cache the scroll
                if (!this.offset.scroll) {
                    this.offset.scroll = {
                        top: scroll.scrollTop(),
                        left: scroll.scrollLeft()
                    };
                }
                return {
                    top: pos.top + // The absolute mouse position
                    this.offset.relative.top * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.top * mod - // The offsetParent's offset without borders (offset + border)
                    (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top) * mod,
                    left: pos.left + // The absolute mouse position
                    this.offset.relative.left * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.left * mod - // The offsetParent's offset without borders (offset + border)
                    (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left) * mod
                };
            },
            _generatePosition: function(event) {
                var containment, co, top, left, o = this.options, scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, pageX = event.pageX, pageY = event.pageY;
                //Cache the scroll
                if (!this.offset.scroll) {
                    this.offset.scroll = {
                        top: scroll.scrollTop(),
                        left: scroll.scrollLeft()
                    };
                }
                /*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */
                // If we are not dragging yet, we won't check for options
                if (this.originalPosition) {
                    if (this.containment) {
                        if (this.relative_container) {
                            co = this.relative_container.offset();
                            containment = [ this.containment[0] + co.left, this.containment[1] + co.top, this.containment[2] + co.left, this.containment[3] + co.top ];
                        } else {
                            containment = this.containment;
                        }
                        if (event.pageX - this.offset.click.left < containment[0]) {
                            pageX = containment[0] + this.offset.click.left;
                        }
                        if (event.pageY - this.offset.click.top < containment[1]) {
                            pageY = containment[1] + this.offset.click.top;
                        }
                        if (event.pageX - this.offset.click.left > containment[2]) {
                            pageX = containment[2] + this.offset.click.left;
                        }
                        if (event.pageY - this.offset.click.top > containment[3]) {
                            pageY = containment[3] + this.offset.click.top;
                        }
                    }
                    if (o.grid) {
                        //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
                        top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
                        pageY = containment ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3] ? top : top - this.offset.click.top >= containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
                        left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
                        pageX = containment ? left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2] ? left : left - this.offset.click.left >= containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
                    }
                }
                return {
                    top: pageY - // The absolute mouse position
                    this.offset.click.top - // Click offset (relative to the element)
                    this.offset.relative.top - // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.top + (// The offsetParent's offset without borders (offset + border)
                    this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top),
                    left: pageX - // The absolute mouse position
                    this.offset.click.left - // Click offset (relative to the element)
                    this.offset.relative.left - // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.left + (// The offsetParent's offset without borders (offset + border)
                    this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left)
                };
            },
            _clear: function() {
                this.helper.removeClass("ui-draggable-dragging");
                if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
                    this.helper.remove();
                }
                this.helper = null;
                this.cancelHelperRemoval = false;
            },
            // From now on bulk stuff - mainly helpers
            _trigger: function(type, event, ui) {
                ui = ui || this._uiHash();
                $.ui.plugin.call(this, type, [ event, ui ]);
                //The absolute position has to be recalculated after plugins
                if (type === "drag") {
                    this.positionAbs = this._convertPositionTo("absolute");
                }
                return $.Widget.prototype._trigger.call(this, type, event, ui);
            },
            plugins: {},
            _uiHash: function() {
                return {
                    helper: this.helper,
                    position: this.position,
                    originalPosition: this.originalPosition,
                    offset: this.positionAbs
                };
            }
        });
        $.ui.plugin.add("draggable", "connectToSortable", {
            start: function(event, ui) {
                var inst = $(this).data("ui-draggable"), o = inst.options, uiSortable = $.extend({}, ui, {
                    item: inst.element
                });
                inst.sortables = [];
                $(o.connectToSortable).each(function() {
                    var sortable = $.data(this, "ui-sortable");
                    if (sortable && !sortable.options.disabled) {
                        inst.sortables.push({
                            instance: sortable,
                            shouldRevert: sortable.options.revert
                        });
                        sortable.refreshPositions();
                        // Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
                        sortable._trigger("activate", event, uiSortable);
                    }
                });
            },
            stop: function(event, ui) {
                //If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
                var inst = $(this).data("ui-draggable"), uiSortable = $.extend({}, ui, {
                    item: inst.element
                });
                $.each(inst.sortables, function() {
                    if (this.instance.isOver) {
                        this.instance.isOver = 0;
                        inst.cancelHelperRemoval = true;
                        //Don't remove the helper in the draggable instance
                        this.instance.cancelHelperRemoval = false;
                        //Remove it in the sortable instance (so sortable plugins like revert still work)
                        //The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
                        if (this.shouldRevert) {
                            this.instance.options.revert = this.shouldRevert;
                        }
                        //Trigger the stop of the sortable
                        this.instance._mouseStop(event);
                        this.instance.options.helper = this.instance.options._helper;
                        //If the helper has been the original item, restore properties in the sortable
                        if (inst.options.helper === "original") {
                            this.instance.currentItem.css({
                                top: "auto",
                                left: "auto"
                            });
                        }
                    } else {
                        this.instance.cancelHelperRemoval = false;
                        //Remove the helper in the sortable instance
                        this.instance._trigger("deactivate", event, uiSortable);
                    }
                });
            },
            drag: function(event, ui) {
                var inst = $(this).data("ui-draggable"), that = this;
                $.each(inst.sortables, function() {
                    var innermostIntersecting = false, thisSortable = this;
                    //Copy over some variables to allow calling the sortable's native _intersectsWith
                    this.instance.positionAbs = inst.positionAbs;
                    this.instance.helperProportions = inst.helperProportions;
                    this.instance.offset.click = inst.offset.click;
                    if (this.instance._intersectsWith(this.instance.containerCache)) {
                        innermostIntersecting = true;
                        $.each(inst.sortables, function() {
                            this.instance.positionAbs = inst.positionAbs;
                            this.instance.helperProportions = inst.helperProportions;
                            this.instance.offset.click = inst.offset.click;
                            if (this !== thisSortable && this.instance._intersectsWith(this.instance.containerCache) && $.contains(thisSortable.instance.element[0], this.instance.element[0])) {
                                innermostIntersecting = false;
                            }
                            return innermostIntersecting;
                        });
                    }
                    if (innermostIntersecting) {
                        //If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
                        if (!this.instance.isOver) {
                            this.instance.isOver = 1;
                            //Now we fake the start of dragging for the sortable instance,
                            //by cloning the list group item, appending it to the sortable and using it as inst.currentItem
                            //We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
                            this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
                            this.instance.options._helper = this.instance.options.helper;
                            //Store helper option to later restore it
                            this.instance.options.helper = function() {
                                return ui.helper[0];
                            };
                            event.target = this.instance.currentItem[0];
                            this.instance._mouseCapture(event, true);
                            this.instance._mouseStart(event, true, true);
                            //Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
                            this.instance.offset.click.top = inst.offset.click.top;
                            this.instance.offset.click.left = inst.offset.click.left;
                            this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
                            this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;
                            inst._trigger("toSortable", event);
                            inst.dropped = this.instance.element;
                            //draggable revert needs that
                            //hack so receive/update callbacks work (mostly)
                            inst.currentItem = inst.element;
                            this.instance.fromOutside = inst;
                        }
                        //Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
                        if (this.instance.currentItem) {
                            this.instance._mouseDrag(event);
                        }
                    } else {
                        //If it doesn't intersect with the sortable, and it intersected before,
                        //we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
                        if (this.instance.isOver) {
                            this.instance.isOver = 0;
                            this.instance.cancelHelperRemoval = true;
                            //Prevent reverting on this forced stop
                            this.instance.options.revert = false;
                            // The out event needs to be triggered independently
                            this.instance._trigger("out", event, this.instance._uiHash(this.instance));
                            this.instance._mouseStop(event, true);
                            this.instance.options.helper = this.instance.options._helper;
                            //Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
                            this.instance.currentItem.remove();
                            if (this.instance.placeholder) {
                                this.instance.placeholder.remove();
                            }
                            inst._trigger("fromSortable", event);
                            inst.dropped = false;
                        }
                    }
                });
            }
        });
        $.ui.plugin.add("draggable", "cursor", {
            start: function() {
                var t = $("body"), o = $(this).data("ui-draggable").options;
                if (t.css("cursor")) {
                    o._cursor = t.css("cursor");
                }
                t.css("cursor", o.cursor);
            },
            stop: function() {
                var o = $(this).data("ui-draggable").options;
                if (o._cursor) {
                    $("body").css("cursor", o._cursor);
                }
            }
        });
        $.ui.plugin.add("draggable", "opacity", {
            start: function(event, ui) {
                var t = $(ui.helper), o = $(this).data("ui-draggable").options;
                if (t.css("opacity")) {
                    o._opacity = t.css("opacity");
                }
                t.css("opacity", o.opacity);
            },
            stop: function(event, ui) {
                var o = $(this).data("ui-draggable").options;
                if (o._opacity) {
                    $(ui.helper).css("opacity", o._opacity);
                }
            }
        });
        $.ui.plugin.add("draggable", "scroll", {
            start: function() {
                var i = $(this).data("ui-draggable");
                if (i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
                    i.overflowOffset = i.scrollParent.offset();
                }
            },
            drag: function(event) {
                var i = $(this).data("ui-draggable"), o = i.options, scrolled = false;
                if (i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
                    if (!o.axis || o.axis !== "x") {
                        if (i.overflowOffset.top + i.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {
                            i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
                        } else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
                            i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
                        }
                    }
                    if (!o.axis || o.axis !== "y") {
                        if (i.overflowOffset.left + i.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {
                            i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
                        } else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
                            i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
                        }
                    }
                } else {
                    if (!o.axis || o.axis !== "x") {
                        if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                            scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                        } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                            scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                        }
                    }
                    if (!o.axis || o.axis !== "y") {
                        if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                            scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                        } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                            scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                        }
                    }
                }
                if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                    $.ui.ddmanager.prepareOffsets(i, event);
                }
            }
        });
        $.ui.plugin.add("draggable", "snap", {
            start: function() {
                var i = $(this).data("ui-draggable"), o = i.options;
                i.snapElements = [];
                $(o.snap.constructor !== String ? o.snap.items || ":data(ui-draggable)" : o.snap).each(function() {
                    var $t = $(this), $o = $t.offset();
                    if (this !== i.element[0]) {
                        i.snapElements.push({
                            item: this,
                            width: $t.outerWidth(),
                            height: $t.outerHeight(),
                            top: $o.top,
                            left: $o.left
                        });
                    }
                });
            },
            drag: function(event, ui) {
                var ts, bs, ls, rs, l, r, t, b, i, first, inst = $(this).data("ui-draggable"), o = inst.options, d = o.snapTolerance, x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width, y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
                for (i = inst.snapElements.length - 1; i >= 0; i--) {
                    l = inst.snapElements[i].left;
                    r = l + inst.snapElements[i].width;
                    t = inst.snapElements[i].top;
                    b = t + inst.snapElements[i].height;
                    if (x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item)) {
                        if (inst.snapElements[i].snapping) {
                            inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), {
                                snapItem: inst.snapElements[i].item
                            }));
                        }
                        inst.snapElements[i].snapping = false;
                        continue;
                    }
                    if (o.snapMode !== "inner") {
                        ts = Math.abs(t - y2) <= d;
                        bs = Math.abs(b - y1) <= d;
                        ls = Math.abs(l - x2) <= d;
                        rs = Math.abs(r - x1) <= d;
                        if (ts) {
                            ui.position.top = inst._convertPositionTo("relative", {
                                top: t - inst.helperProportions.height,
                                left: 0
                            }).top - inst.margins.top;
                        }
                        if (bs) {
                            ui.position.top = inst._convertPositionTo("relative", {
                                top: b,
                                left: 0
                            }).top - inst.margins.top;
                        }
                        if (ls) {
                            ui.position.left = inst._convertPositionTo("relative", {
                                top: 0,
                                left: l - inst.helperProportions.width
                            }).left - inst.margins.left;
                        }
                        if (rs) {
                            ui.position.left = inst._convertPositionTo("relative", {
                                top: 0,
                                left: r
                            }).left - inst.margins.left;
                        }
                    }
                    first = ts || bs || ls || rs;
                    if (o.snapMode !== "outer") {
                        ts = Math.abs(t - y1) <= d;
                        bs = Math.abs(b - y2) <= d;
                        ls = Math.abs(l - x1) <= d;
                        rs = Math.abs(r - x2) <= d;
                        if (ts) {
                            ui.position.top = inst._convertPositionTo("relative", {
                                top: t,
                                left: 0
                            }).top - inst.margins.top;
                        }
                        if (bs) {
                            ui.position.top = inst._convertPositionTo("relative", {
                                top: b - inst.helperProportions.height,
                                left: 0
                            }).top - inst.margins.top;
                        }
                        if (ls) {
                            ui.position.left = inst._convertPositionTo("relative", {
                                top: 0,
                                left: l
                            }).left - inst.margins.left;
                        }
                        if (rs) {
                            ui.position.left = inst._convertPositionTo("relative", {
                                top: 0,
                                left: r - inst.helperProportions.width
                            }).left - inst.margins.left;
                        }
                    }
                    if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
                        inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), {
                            snapItem: inst.snapElements[i].item
                        }));
                    }
                    inst.snapElements[i].snapping = ts || bs || ls || rs || first;
                }
            }
        });
        $.ui.plugin.add("draggable", "stack", {
            start: function() {
                var min, o = this.data("ui-draggable").options, group = $.makeArray($(o.stack)).sort(function(a, b) {
                    return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
                });
                if (!group.length) {
                    return;
                }
                min = parseInt($(group[0]).css("zIndex"), 10) || 0;
                $(group).each(function(i) {
                    $(this).css("zIndex", min + i);
                });
                this.css("zIndex", min + group.length);
            }
        });
        $.ui.plugin.add("draggable", "zIndex", {
            start: function(event, ui) {
                var t = $(ui.helper), o = $(this).data("ui-draggable").options;
                if (t.css("zIndex")) {
                    o._zIndex = t.css("zIndex");
                }
                t.css("zIndex", o.zIndex);
            },
            stop: function(event, ui) {
                var o = $(this).data("ui-draggable").options;
                if (o._zIndex) {
                    $(ui.helper).css("zIndex", o._zIndex);
                }
            }
        });
    })(jQuery);
    (function($, undefined) {
        function isOverAxis(x, reference, size) {
            return x > reference && x < reference + size;
        }
        $.widget("ui.droppable", {
            version: "1.10.3",
            widgetEventPrefix: "drop",
            options: {
                accept: "*",
                activeClass: false,
                addClasses: true,
                greedy: false,
                hoverClass: false,
                scope: "default",
                tolerance: "intersect",
                // callbacks
                activate: null,
                deactivate: null,
                drop: null,
                out: null,
                over: null
            },
            _create: function() {
                var o = this.options, accept = o.accept;
                this.isover = false;
                this.isout = true;
                this.accept = $.isFunction(accept) ? accept : function(d) {
                    return d.is(accept);
                };
                //Store the droppable's proportions
                this.proportions = {
                    width: this.element[0].offsetWidth,
                    height: this.element[0].offsetHeight
                };
                // Add the reference and positions to the manager
                $.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
                $.ui.ddmanager.droppables[o.scope].push(this);
                o.addClasses && this.element.addClass("ui-droppable");
            },
            _destroy: function() {
                var i = 0, drop = $.ui.ddmanager.droppables[this.options.scope];
                for (;i < drop.length; i++) {
                    if (drop[i] === this) {
                        drop.splice(i, 1);
                    }
                }
                this.element.removeClass("ui-droppable ui-droppable-disabled");
            },
            _setOption: function(key, value) {
                if (key === "accept") {
                    this.accept = $.isFunction(value) ? value : function(d) {
                        return d.is(value);
                    };
                }
                $.Widget.prototype._setOption.apply(this, arguments);
            },
            _activate: function(event) {
                var draggable = $.ui.ddmanager.current;
                if (this.options.activeClass) {
                    this.element.addClass(this.options.activeClass);
                }
                if (draggable) {
                    this._trigger("activate", event, this.ui(draggable));
                }
            },
            _deactivate: function(event) {
                var draggable = $.ui.ddmanager.current;
                if (this.options.activeClass) {
                    this.element.removeClass(this.options.activeClass);
                }
                if (draggable) {
                    this._trigger("deactivate", event, this.ui(draggable));
                }
            },
            _over: function(event) {
                var draggable = $.ui.ddmanager.current;
                // Bail if draggable and droppable are same element
                if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                    return;
                }
                if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                    if (this.options.hoverClass) {
                        this.element.addClass(this.options.hoverClass);
                    }
                    this._trigger("over", event, this.ui(draggable));
                }
            },
            _out: function(event) {
                var draggable = $.ui.ddmanager.current;
                // Bail if draggable and droppable are same element
                if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                    return;
                }
                if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                    if (this.options.hoverClass) {
                        this.element.removeClass(this.options.hoverClass);
                    }
                    this._trigger("out", event, this.ui(draggable));
                }
            },
            _drop: function(event, custom) {
                var draggable = custom || $.ui.ddmanager.current, childrenIntersection = false;
                // Bail if draggable and droppable are same element
                if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                    return false;
                }
                this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
                    var inst = $.data(this, "ui-droppable");
                    if (inst.options.greedy && !inst.options.disabled && inst.options.scope === draggable.options.scope && inst.accept.call(inst.element[0], draggable.currentItem || draggable.element) && $.ui.intersect(draggable, $.extend(inst, {
                        offset: inst.element.offset()
                    }), inst.options.tolerance)) {
                        childrenIntersection = true;
                        return false;
                    }
                });
                if (childrenIntersection) {
                    return false;
                }
                if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                    if (this.options.activeClass) {
                        this.element.removeClass(this.options.activeClass);
                    }
                    if (this.options.hoverClass) {
                        this.element.removeClass(this.options.hoverClass);
                    }
                    this._trigger("drop", event, this.ui(draggable));
                    return this.element;
                }
                return false;
            },
            ui: function(c) {
                return {
                    draggable: c.currentItem || c.element,
                    helper: c.helper,
                    position: c.position,
                    offset: c.positionAbs
                };
            }
        });
        $.ui.intersect = function(draggable, droppable, toleranceMode) {
            if (!droppable.offset) {
                return false;
            }
            var draggableLeft, draggableTop, x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width, y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height, l = droppable.offset.left, r = l + droppable.proportions.width, t = droppable.offset.top, b = t + droppable.proportions.height;
            switch (toleranceMode) {
              case "fit":
                return l <= x1 && x2 <= r && t <= y1 && y2 <= b;

              case "intersect":
                return l < x1 + draggable.helperProportions.width / 2 && // Right Half
                x2 - draggable.helperProportions.width / 2 < r && // Left Half
                t < y1 + draggable.helperProportions.height / 2 && // Bottom Half
                y2 - draggable.helperProportions.height / 2 < b;

              // Top Half
                case "pointer":
                draggableLeft = (draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left;
                draggableTop = (draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top;
                return isOverAxis(draggableTop, t, droppable.proportions.height) && isOverAxis(draggableLeft, l, droppable.proportions.width);

              case "touch":
                return (y1 >= t && y1 <= b || // Top edge touching
                y2 >= t && y2 <= b || // Bottom edge touching
                y1 < t && y2 > b) && (x1 >= l && x1 <= r || // Left edge touching
                x2 >= l && x2 <= r || // Right edge touching
                x1 < l && x2 > r);

              default:
                return false;
            }
        };
        /*
	This manager tracks offsets of draggables and droppables
*/
        $.ui.ddmanager = {
            current: null,
            droppables: {
                "default": []
            },
            prepareOffsets: function(t, event) {
                var i, j, m = $.ui.ddmanager.droppables[t.options.scope] || [], type = event ? event.type : null, // workaround for #2317
                list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
                droppablesLoop: for (i = 0; i < m.length; i++) {
                    //No disabled and non-accepted
                    if (m[i].options.disabled || t && !m[i].accept.call(m[i].element[0], t.currentItem || t.element)) {
                        continue;
                    }
                    // Filter out elements in the current dragged item
                    for (j = 0; j < list.length; j++) {
                        if (list[j] === m[i].element[0]) {
                            m[i].proportions.height = 0;
                            continue droppablesLoop;
                        }
                    }
                    m[i].visible = m[i].element.css("display") !== "none";
                    if (!m[i].visible) {
                        continue;
                    }
                    //Activate the droppable if used directly from draggables
                    if (type === "mousedown") {
                        m[i]._activate.call(m[i], event);
                    }
                    m[i].offset = m[i].element.offset();
                    m[i].proportions = {
                        width: m[i].element[0].offsetWidth,
                        height: m[i].element[0].offsetHeight
                    };
                }
            },
            drop: function(draggable, event) {
                var dropped = false;
                // Create a copy of the droppables in case the list changes during the drop (#9116)
                $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {
                    if (!this.options) {
                        return;
                    }
                    if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance)) {
                        dropped = this._drop.call(this, event) || dropped;
                    }
                    if (!this.options.disabled && this.visible && this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                        this.isout = true;
                        this.isover = false;
                        this._deactivate.call(this, event);
                    }
                });
                return dropped;
            },
            dragStart: function(draggable, event) {
                //Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
                draggable.element.parentsUntil("body").bind("scroll.droppable", function() {
                    if (!draggable.options.refreshPositions) {
                        $.ui.ddmanager.prepareOffsets(draggable, event);
                    }
                });
            },
            drag: function(draggable, event) {
                //If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
                if (draggable.options.refreshPositions) {
                    $.ui.ddmanager.prepareOffsets(draggable, event);
                }
                //Run through all droppables and check their positions based on specific tolerance options
                $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {
                    if (this.options.disabled || this.greedyChild || !this.visible) {
                        return;
                    }
                    var parentInstance, scope, parent, intersects = $.ui.intersect(draggable, this, this.options.tolerance), c = !intersects && this.isover ? "isout" : intersects && !this.isover ? "isover" : null;
                    if (!c) {
                        return;
                    }
                    if (this.options.greedy) {
                        // find droppable parents with same scope
                        scope = this.options.scope;
                        parent = this.element.parents(":data(ui-droppable)").filter(function() {
                            return $.data(this, "ui-droppable").options.scope === scope;
                        });
                        if (parent.length) {
                            parentInstance = $.data(parent[0], "ui-droppable");
                            parentInstance.greedyChild = c === "isover";
                        }
                    }
                    // we just moved into a greedy child
                    if (parentInstance && c === "isover") {
                        parentInstance.isover = false;
                        parentInstance.isout = true;
                        parentInstance._out.call(parentInstance, event);
                    }
                    this[c] = true;
                    this[c === "isout" ? "isover" : "isout"] = false;
                    this[c === "isover" ? "_over" : "_out"].call(this, event);
                    // we just moved out of a greedy child
                    if (parentInstance && c === "isout") {
                        parentInstance.isout = false;
                        parentInstance.isover = true;
                        parentInstance._over.call(parentInstance, event);
                    }
                });
            },
            dragStop: function(draggable, event) {
                draggable.element.parentsUntil("body").unbind("scroll.droppable");
                //Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
                if (!draggable.options.refreshPositions) {
                    $.ui.ddmanager.prepareOffsets(draggable, event);
                }
            }
        };
    })(jQuery);
    (function($, undefined) {
        function num(v) {
            return parseInt(v, 10) || 0;
        }
        function isNumber(value) {
            return !isNaN(parseInt(value, 10));
        }
        $.widget("ui.resizable", $.ui.mouse, {
            version: "1.10.3",
            widgetEventPrefix: "resize",
            options: {
                alsoResize: false,
                animate: false,
                animateDuration: "slow",
                animateEasing: "swing",
                aspectRatio: false,
                autoHide: false,
                containment: false,
                ghost: false,
                grid: false,
                handles: "e,s,se",
                helper: false,
                maxHeight: null,
                maxWidth: null,
                minHeight: 10,
                minWidth: 10,
                // See #7960
                zIndex: 90,
                // callbacks
                resize: null,
                start: null,
                stop: null
            },
            _create: function() {
                var n, i, handle, axis, hname, that = this, o = this.options;
                this.element.addClass("ui-resizable");
                $.extend(this, {
                    _aspectRatio: !!o.aspectRatio,
                    aspectRatio: o.aspectRatio,
                    originalElement: this.element,
                    _proportionallyResizeElements: [],
                    _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
                });
                //Wrap the element if it cannot hold child nodes
                if (this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {
                    //Create a wrapper element and set the wrapper to the new current internal element
                    this.element.wrap($("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                        position: this.element.css("position"),
                        width: this.element.outerWidth(),
                        height: this.element.outerHeight(),
                        top: this.element.css("top"),
                        left: this.element.css("left")
                    }));
                    //Overwrite the original this.element
                    this.element = this.element.parent().data("ui-resizable", this.element.data("ui-resizable"));
                    this.elementIsWrapper = true;
                    //Move margins to the wrapper
                    this.element.css({
                        marginLeft: this.originalElement.css("marginLeft"),
                        marginTop: this.originalElement.css("marginTop"),
                        marginRight: this.originalElement.css("marginRight"),
                        marginBottom: this.originalElement.css("marginBottom")
                    });
                    this.originalElement.css({
                        marginLeft: 0,
                        marginTop: 0,
                        marginRight: 0,
                        marginBottom: 0
                    });
                    //Prevent Safari textarea resize
                    this.originalResizeStyle = this.originalElement.css("resize");
                    this.originalElement.css("resize", "none");
                    //Push the actual element to our proportionallyResize internal array
                    this._proportionallyResizeElements.push(this.originalElement.css({
                        position: "static",
                        zoom: 1,
                        display: "block"
                    }));
                    // avoid IE jump (hard set the margin)
                    this.originalElement.css({
                        margin: this.originalElement.css("margin")
                    });
                    // fix handlers offset
                    this._proportionallyResize();
                }
                this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : {
                    n: ".ui-resizable-n",
                    e: ".ui-resizable-e",
                    s: ".ui-resizable-s",
                    w: ".ui-resizable-w",
                    se: ".ui-resizable-se",
                    sw: ".ui-resizable-sw",
                    ne: ".ui-resizable-ne",
                    nw: ".ui-resizable-nw"
                });
                if (this.handles.constructor === String) {
                    if (this.handles === "all") {
                        this.handles = "n,e,s,w,se,sw,ne,nw";
                    }
                    n = this.handles.split(",");
                    this.handles = {};
                    for (i = 0; i < n.length; i++) {
                        handle = $.trim(n[i]);
                        hname = "ui-resizable-" + handle;
                        axis = $("<div class='ui-resizable-handle " + hname + "'></div>");
                        // Apply zIndex to all handles - see #7960
                        axis.css({
                            zIndex: o.zIndex
                        });
                        //TODO : What's going on here?
                        if ("se" === handle) {
                            axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
                        }
                        //Insert into internal handles object and append to element
                        this.handles[handle] = ".ui-resizable-" + handle;
                        this.element.append(axis);
                    }
                }
                this._renderAxis = function(target) {
                    var i, axis, padPos, padWrapper;
                    target = target || this.element;
                    for (i in this.handles) {
                        if (this.handles[i].constructor === String) {
                            this.handles[i] = $(this.handles[i], this.element).show();
                        }
                        //Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
                        if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {
                            axis = $(this.handles[i], this.element);
                            //Checking the correct pad and border
                            padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
                            //The padding type i have to apply...
                            padPos = [ "padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left" ].join("");
                            target.css(padPos, padWrapper);
                            this._proportionallyResize();
                        }
                        //TODO: What's that good for? There's not anything to be executed left
                        if (!$(this.handles[i]).length) {
                            continue;
                        }
                    }
                };
                //TODO: make renderAxis a prototype function
                this._renderAxis(this.element);
                this._handles = $(".ui-resizable-handle", this.element).disableSelection();
                //Matching axis name
                this._handles.mouseover(function() {
                    if (!that.resizing) {
                        if (this.className) {
                            axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
                        }
                        //Axis, default = se
                        that.axis = axis && axis[1] ? axis[1] : "se";
                    }
                });
                //If we want to auto hide the elements
                if (o.autoHide) {
                    this._handles.hide();
                    $(this.element).addClass("ui-resizable-autohide").mouseenter(function() {
                        if (o.disabled) {
                            return;
                        }
                        $(this).removeClass("ui-resizable-autohide");
                        that._handles.show();
                    }).mouseleave(function() {
                        if (o.disabled) {
                            return;
                        }
                        if (!that.resizing) {
                            $(this).addClass("ui-resizable-autohide");
                            that._handles.hide();
                        }
                    });
                }
                //Initialize the mouse interaction
                this._mouseInit();
            },
            _destroy: function() {
                this._mouseDestroy();
                var wrapper, _destroy = function(exp) {
                    $(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
                };
                //TODO: Unwrap at same DOM position
                if (this.elementIsWrapper) {
                    _destroy(this.element);
                    wrapper = this.element;
                    this.originalElement.css({
                        position: wrapper.css("position"),
                        width: wrapper.outerWidth(),
                        height: wrapper.outerHeight(),
                        top: wrapper.css("top"),
                        left: wrapper.css("left")
                    }).insertAfter(wrapper);
                    wrapper.remove();
                }
                this.originalElement.css("resize", this.originalResizeStyle);
                _destroy(this.originalElement);
                return this;
            },
            _mouseCapture: function(event) {
                var i, handle, capture = false;
                for (i in this.handles) {
                    handle = $(this.handles[i])[0];
                    if (handle === event.target || $.contains(handle, event.target)) {
                        capture = true;
                    }
                }
                return !this.options.disabled && capture;
            },
            _mouseStart: function(event) {
                var curleft, curtop, cursor, o = this.options, iniPos = this.element.position(), el = this.element;
                this.resizing = true;
                // bugfix for http://dev.jquery.com/ticket/1749
                if (/absolute/.test(el.css("position"))) {
                    el.css({
                        position: "absolute",
                        top: el.css("top"),
                        left: el.css("left")
                    });
                } else if (el.is(".ui-draggable")) {
                    el.css({
                        position: "absolute",
                        top: iniPos.top,
                        left: iniPos.left
                    });
                }
                this._renderProxy();
                curleft = num(this.helper.css("left"));
                curtop = num(this.helper.css("top"));
                if (o.containment) {
                    curleft += $(o.containment).scrollLeft() || 0;
                    curtop += $(o.containment).scrollTop() || 0;
                }
                //Store needed variables
                this.offset = this.helper.offset();
                this.position = {
                    left: curleft,
                    top: curtop
                };
                this.size = this._helper ? {
                    width: el.outerWidth(),
                    height: el.outerHeight()
                } : {
                    width: el.width(),
                    height: el.height()
                };
                this.originalSize = this._helper ? {
                    width: el.outerWidth(),
                    height: el.outerHeight()
                } : {
                    width: el.width(),
                    height: el.height()
                };
                this.originalPosition = {
                    left: curleft,
                    top: curtop
                };
                this.sizeDiff = {
                    width: el.outerWidth() - el.width(),
                    height: el.outerHeight() - el.height()
                };
                this.originalMousePosition = {
                    left: event.pageX,
                    top: event.pageY
                };
                //Aspect Ratio
                this.aspectRatio = typeof o.aspectRatio === "number" ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1;
                cursor = $(".ui-resizable-" + this.axis).css("cursor");
                $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);
                el.addClass("ui-resizable-resizing");
                this._propagate("start", event);
                return true;
            },
            _mouseDrag: function(event) {
                //Increase performance, avoid regex
                var data, el = this.helper, props = {}, smp = this.originalMousePosition, a = this.axis, prevTop = this.position.top, prevLeft = this.position.left, prevWidth = this.size.width, prevHeight = this.size.height, dx = event.pageX - smp.left || 0, dy = event.pageY - smp.top || 0, trigger = this._change[a];
                if (!trigger) {
                    return false;
                }
                // Calculate the attrs that will be change
                data = trigger.apply(this, [ event, dx, dy ]);
                // Put this in the mouseDrag handler since the user can start pressing shift while resizing
                this._updateVirtualBoundaries(event.shiftKey);
                if (this._aspectRatio || event.shiftKey) {
                    data = this._updateRatio(data, event);
                }
                data = this._respectSize(data, event);
                this._updateCache(data);
                // plugins callbacks need to be called first
                this._propagate("resize", event);
                if (this.position.top !== prevTop) {
                    props.top = this.position.top + "px";
                }
                if (this.position.left !== prevLeft) {
                    props.left = this.position.left + "px";
                }
                if (this.size.width !== prevWidth) {
                    props.width = this.size.width + "px";
                }
                if (this.size.height !== prevHeight) {
                    props.height = this.size.height + "px";
                }
                el.css(props);
                if (!this._helper && this._proportionallyResizeElements.length) {
                    this._proportionallyResize();
                }
                // Call the user callback if the element was resized
                if (!$.isEmptyObject(props)) {
                    this._trigger("resize", event, this.ui());
                }
                return false;
            },
            _mouseStop: function(event) {
                this.resizing = false;
                var pr, ista, soffseth, soffsetw, s, left, top, o = this.options, that = this;
                if (this._helper) {
                    pr = this._proportionallyResizeElements;
                    ista = pr.length && /textarea/i.test(pr[0].nodeName);
                    soffseth = ista && $.ui.hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
                    soffsetw = ista ? 0 : that.sizeDiff.width;
                    s = {
                        width: that.helper.width() - soffsetw,
                        height: that.helper.height() - soffseth
                    };
                    left = parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left) || null;
                    top = parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top) || null;
                    if (!o.animate) {
                        this.element.css($.extend(s, {
                            top: top,
                            left: left
                        }));
                    }
                    that.helper.height(that.size.height);
                    that.helper.width(that.size.width);
                    if (this._helper && !o.animate) {
                        this._proportionallyResize();
                    }
                }
                $("body").css("cursor", "auto");
                this.element.removeClass("ui-resizable-resizing");
                this._propagate("stop", event);
                if (this._helper) {
                    this.helper.remove();
                }
                return false;
            },
            _updateVirtualBoundaries: function(forceAspectRatio) {
                var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b, o = this.options;
                b = {
                    minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
                    maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
                    minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
                    maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
                };
                if (this._aspectRatio || forceAspectRatio) {
                    // We want to create an enclosing box whose aspect ration is the requested one
                    // First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
                    pMinWidth = b.minHeight * this.aspectRatio;
                    pMinHeight = b.minWidth / this.aspectRatio;
                    pMaxWidth = b.maxHeight * this.aspectRatio;
                    pMaxHeight = b.maxWidth / this.aspectRatio;
                    if (pMinWidth > b.minWidth) {
                        b.minWidth = pMinWidth;
                    }
                    if (pMinHeight > b.minHeight) {
                        b.minHeight = pMinHeight;
                    }
                    if (pMaxWidth < b.maxWidth) {
                        b.maxWidth = pMaxWidth;
                    }
                    if (pMaxHeight < b.maxHeight) {
                        b.maxHeight = pMaxHeight;
                    }
                }
                this._vBoundaries = b;
            },
            _updateCache: function(data) {
                this.offset = this.helper.offset();
                if (isNumber(data.left)) {
                    this.position.left = data.left;
                }
                if (isNumber(data.top)) {
                    this.position.top = data.top;
                }
                if (isNumber(data.height)) {
                    this.size.height = data.height;
                }
                if (isNumber(data.width)) {
                    this.size.width = data.width;
                }
            },
            _updateRatio: function(data) {
                var cpos = this.position, csize = this.size, a = this.axis;
                if (isNumber(data.height)) {
                    data.width = data.height * this.aspectRatio;
                } else if (isNumber(data.width)) {
                    data.height = data.width / this.aspectRatio;
                }
                if (a === "sw") {
                    data.left = cpos.left + (csize.width - data.width);
                    data.top = null;
                }
                if (a === "nw") {
                    data.top = cpos.top + (csize.height - data.height);
                    data.left = cpos.left + (csize.width - data.width);
                }
                return data;
            },
            _respectSize: function(data) {
                var o = this._vBoundaries, a = this.axis, ismaxw = isNumber(data.width) && o.maxWidth && o.maxWidth < data.width, ismaxh = isNumber(data.height) && o.maxHeight && o.maxHeight < data.height, isminw = isNumber(data.width) && o.minWidth && o.minWidth > data.width, isminh = isNumber(data.height) && o.minHeight && o.minHeight > data.height, dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height, cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
                if (isminw) {
                    data.width = o.minWidth;
                }
                if (isminh) {
                    data.height = o.minHeight;
                }
                if (ismaxw) {
                    data.width = o.maxWidth;
                }
                if (ismaxh) {
                    data.height = o.maxHeight;
                }
                if (isminw && cw) {
                    data.left = dw - o.minWidth;
                }
                if (ismaxw && cw) {
                    data.left = dw - o.maxWidth;
                }
                if (isminh && ch) {
                    data.top = dh - o.minHeight;
                }
                if (ismaxh && ch) {
                    data.top = dh - o.maxHeight;
                }
                // fixing jump error on top/left - bug #2330
                if (!data.width && !data.height && !data.left && data.top) {
                    data.top = null;
                } else if (!data.width && !data.height && !data.top && data.left) {
                    data.left = null;
                }
                return data;
            },
            _proportionallyResize: function() {
                if (!this._proportionallyResizeElements.length) {
                    return;
                }
                var i, j, borders, paddings, prel, element = this.helper || this.element;
                for (i = 0; i < this._proportionallyResizeElements.length; i++) {
                    prel = this._proportionallyResizeElements[i];
                    if (!this.borderDif) {
                        this.borderDif = [];
                        borders = [ prel.css("borderTopWidth"), prel.css("borderRightWidth"), prel.css("borderBottomWidth"), prel.css("borderLeftWidth") ];
                        paddings = [ prel.css("paddingTop"), prel.css("paddingRight"), prel.css("paddingBottom"), prel.css("paddingLeft") ];
                        for (j = 0; j < borders.length; j++) {
                            this.borderDif[j] = (parseInt(borders[j], 10) || 0) + (parseInt(paddings[j], 10) || 0);
                        }
                    }
                    prel.css({
                        height: element.height() - this.borderDif[0] - this.borderDif[2] || 0,
                        width: element.width() - this.borderDif[1] - this.borderDif[3] || 0
                    });
                }
            },
            _renderProxy: function() {
                var el = this.element, o = this.options;
                this.elementOffset = el.offset();
                if (this._helper) {
                    this.helper = this.helper || $("<div style='overflow:hidden;'></div>");
                    this.helper.addClass(this._helper).css({
                        width: this.element.outerWidth() - 1,
                        height: this.element.outerHeight() - 1,
                        position: "absolute",
                        left: this.elementOffset.left + "px",
                        top: this.elementOffset.top + "px",
                        zIndex: ++o.zIndex
                    });
                    this.helper.appendTo("body").disableSelection();
                } else {
                    this.helper = this.element;
                }
            },
            _change: {
                e: function(event, dx) {
                    return {
                        width: this.originalSize.width + dx
                    };
                },
                w: function(event, dx) {
                    var cs = this.originalSize, sp = this.originalPosition;
                    return {
                        left: sp.left + dx,
                        width: cs.width - dx
                    };
                },
                n: function(event, dx, dy) {
                    var cs = this.originalSize, sp = this.originalPosition;
                    return {
                        top: sp.top + dy,
                        height: cs.height - dy
                    };
                },
                s: function(event, dx, dy) {
                    return {
                        height: this.originalSize.height + dy
                    };
                },
                se: function(event, dx, dy) {
                    return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [ event, dx, dy ]));
                },
                sw: function(event, dx, dy) {
                    return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [ event, dx, dy ]));
                },
                ne: function(event, dx, dy) {
                    return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [ event, dx, dy ]));
                },
                nw: function(event, dx, dy) {
                    return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [ event, dx, dy ]));
                }
            },
            _propagate: function(n, event) {
                $.ui.plugin.call(this, n, [ event, this.ui() ]);
                n !== "resize" && this._trigger(n, event, this.ui());
            },
            plugins: {},
            ui: function() {
                return {
                    originalElement: this.originalElement,
                    element: this.element,
                    helper: this.helper,
                    position: this.position,
                    size: this.size,
                    originalSize: this.originalSize,
                    originalPosition: this.originalPosition
                };
            }
        });
        /*
 * Resizable Extensions
 */
        $.ui.plugin.add("resizable", "animate", {
            stop: function(event) {
                var that = $(this).data("ui-resizable"), o = that.options, pr = that._proportionallyResizeElements, ista = pr.length && /textarea/i.test(pr[0].nodeName), soffseth = ista && $.ui.hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height, soffsetw = ista ? 0 : that.sizeDiff.width, style = {
                    width: that.size.width - soffsetw,
                    height: that.size.height - soffseth
                }, left = parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left) || null, top = parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top) || null;
                that.element.animate($.extend(style, top && left ? {
                    top: top,
                    left: left
                } : {}), {
                    duration: o.animateDuration,
                    easing: o.animateEasing,
                    step: function() {
                        var data = {
                            width: parseInt(that.element.css("width"), 10),
                            height: parseInt(that.element.css("height"), 10),
                            top: parseInt(that.element.css("top"), 10),
                            left: parseInt(that.element.css("left"), 10)
                        };
                        if (pr && pr.length) {
                            $(pr[0]).css({
                                width: data.width,
                                height: data.height
                            });
                        }
                        // propagating resize, and updating values for each animation step
                        that._updateCache(data);
                        that._propagate("resize", event);
                    }
                });
            }
        });
        $.ui.plugin.add("resizable", "containment", {
            start: function() {
                var element, p, co, ch, cw, width, height, that = $(this).data("ui-resizable"), o = that.options, el = that.element, oc = o.containment, ce = oc instanceof $ ? oc.get(0) : /parent/.test(oc) ? el.parent().get(0) : oc;
                if (!ce) {
                    return;
                }
                that.containerElement = $(ce);
                if (/document/.test(oc) || oc === document) {
                    that.containerOffset = {
                        left: 0,
                        top: 0
                    };
                    that.containerPosition = {
                        left: 0,
                        top: 0
                    };
                    that.parentData = {
                        element: $(document),
                        left: 0,
                        top: 0,
                        width: $(document).width(),
                        height: $(document).height() || document.body.parentNode.scrollHeight
                    };
                } else {
                    element = $(ce);
                    p = [];
                    $([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) {
                        p[i] = num(element.css("padding" + name));
                    });
                    that.containerOffset = element.offset();
                    that.containerPosition = element.position();
                    that.containerSize = {
                        height: element.innerHeight() - p[3],
                        width: element.innerWidth() - p[1]
                    };
                    co = that.containerOffset;
                    ch = that.containerSize.height;
                    cw = that.containerSize.width;
                    width = $.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw;
                    height = $.ui.hasScroll(ce) ? ce.scrollHeight : ch;
                    that.parentData = {
                        element: ce,
                        left: co.left,
                        top: co.top,
                        width: width,
                        height: height
                    };
                }
            },
            resize: function(event) {
                var woset, hoset, isParent, isOffsetRelative, that = $(this).data("ui-resizable"), o = that.options, co = that.containerOffset, cp = that.position, pRatio = that._aspectRatio || event.shiftKey, cop = {
                    top: 0,
                    left: 0
                }, ce = that.containerElement;
                if (ce[0] !== document && /static/.test(ce.css("position"))) {
                    cop = co;
                }
                if (cp.left < (that._helper ? co.left : 0)) {
                    that.size.width = that.size.width + (that._helper ? that.position.left - co.left : that.position.left - cop.left);
                    if (pRatio) {
                        that.size.height = that.size.width / that.aspectRatio;
                    }
                    that.position.left = o.helper ? co.left : 0;
                }
                if (cp.top < (that._helper ? co.top : 0)) {
                    that.size.height = that.size.height + (that._helper ? that.position.top - co.top : that.position.top);
                    if (pRatio) {
                        that.size.width = that.size.height * that.aspectRatio;
                    }
                    that.position.top = that._helper ? co.top : 0;
                }
                that.offset.left = that.parentData.left + that.position.left;
                that.offset.top = that.parentData.top + that.position.top;
                woset = Math.abs((that._helper ? that.offset.left - cop.left : that.offset.left - cop.left) + that.sizeDiff.width);
                hoset = Math.abs((that._helper ? that.offset.top - cop.top : that.offset.top - co.top) + that.sizeDiff.height);
                isParent = that.containerElement.get(0) === that.element.parent().get(0);
                isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));
                if (isParent && isOffsetRelative) {
                    woset -= that.parentData.left;
                }
                if (woset + that.size.width >= that.parentData.width) {
                    that.size.width = that.parentData.width - woset;
                    if (pRatio) {
                        that.size.height = that.size.width / that.aspectRatio;
                    }
                }
                if (hoset + that.size.height >= that.parentData.height) {
                    that.size.height = that.parentData.height - hoset;
                    if (pRatio) {
                        that.size.width = that.size.height * that.aspectRatio;
                    }
                }
            },
            stop: function() {
                var that = $(this).data("ui-resizable"), o = that.options, co = that.containerOffset, cop = that.containerPosition, ce = that.containerElement, helper = $(that.helper), ho = helper.offset(), w = helper.outerWidth() - that.sizeDiff.width, h = helper.outerHeight() - that.sizeDiff.height;
                if (that._helper && !o.animate && /relative/.test(ce.css("position"))) {
                    $(this).css({
                        left: ho.left - cop.left - co.left,
                        width: w,
                        height: h
                    });
                }
                if (that._helper && !o.animate && /static/.test(ce.css("position"))) {
                    $(this).css({
                        left: ho.left - cop.left - co.left,
                        width: w,
                        height: h
                    });
                }
            }
        });
        $.ui.plugin.add("resizable", "alsoResize", {
            start: function() {
                var that = $(this).data("ui-resizable"), o = that.options, _store = function(exp) {
                    $(exp).each(function() {
                        var el = $(this);
                        el.data("ui-resizable-alsoresize", {
                            width: parseInt(el.width(), 10),
                            height: parseInt(el.height(), 10),
                            left: parseInt(el.css("left"), 10),
                            top: parseInt(el.css("top"), 10)
                        });
                    });
                };
                if (typeof o.alsoResize === "object" && !o.alsoResize.parentNode) {
                    if (o.alsoResize.length) {
                        o.alsoResize = o.alsoResize[0];
                        _store(o.alsoResize);
                    } else {
                        $.each(o.alsoResize, function(exp) {
                            _store(exp);
                        });
                    }
                } else {
                    _store(o.alsoResize);
                }
            },
            resize: function(event, ui) {
                var that = $(this).data("ui-resizable"), o = that.options, os = that.originalSize, op = that.originalPosition, delta = {
                    height: that.size.height - os.height || 0,
                    width: that.size.width - os.width || 0,
                    top: that.position.top - op.top || 0,
                    left: that.position.left - op.left || 0
                }, _alsoResize = function(exp, c) {
                    $(exp).each(function() {
                        var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {}, css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? [ "width", "height" ] : [ "width", "height", "top", "left" ];
                        $.each(css, function(i, prop) {
                            var sum = (start[prop] || 0) + (delta[prop] || 0);
                            if (sum && sum >= 0) {
                                style[prop] = sum || null;
                            }
                        });
                        el.css(style);
                    });
                };
                if (typeof o.alsoResize === "object" && !o.alsoResize.nodeType) {
                    $.each(o.alsoResize, function(exp, c) {
                        _alsoResize(exp, c);
                    });
                } else {
                    _alsoResize(o.alsoResize);
                }
            },
            stop: function() {
                $(this).removeData("resizable-alsoresize");
            }
        });
        $.ui.plugin.add("resizable", "ghost", {
            start: function() {
                var that = $(this).data("ui-resizable"), o = that.options, cs = that.size;
                that.ghost = that.originalElement.clone();
                that.ghost.css({
                    opacity: .25,
                    display: "block",
                    position: "relative",
                    height: cs.height,
                    width: cs.width,
                    margin: 0,
                    left: 0,
                    top: 0
                }).addClass("ui-resizable-ghost").addClass(typeof o.ghost === "string" ? o.ghost : "");
                that.ghost.appendTo(that.helper);
            },
            resize: function() {
                var that = $(this).data("ui-resizable");
                if (that.ghost) {
                    that.ghost.css({
                        position: "relative",
                        height: that.size.height,
                        width: that.size.width
                    });
                }
            },
            stop: function() {
                var that = $(this).data("ui-resizable");
                if (that.ghost && that.helper) {
                    that.helper.get(0).removeChild(that.ghost.get(0));
                }
            }
        });
        $.ui.plugin.add("resizable", "grid", {
            resize: function() {
                var that = $(this).data("ui-resizable"), o = that.options, cs = that.size, os = that.originalSize, op = that.originalPosition, a = that.axis, grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid, gridX = grid[0] || 1, gridY = grid[1] || 1, ox = Math.round((cs.width - os.width) / gridX) * gridX, oy = Math.round((cs.height - os.height) / gridY) * gridY, newWidth = os.width + ox, newHeight = os.height + oy, isMaxWidth = o.maxWidth && o.maxWidth < newWidth, isMaxHeight = o.maxHeight && o.maxHeight < newHeight, isMinWidth = o.minWidth && o.minWidth > newWidth, isMinHeight = o.minHeight && o.minHeight > newHeight;
                o.grid = grid;
                if (isMinWidth) {
                    newWidth = newWidth + gridX;
                }
                if (isMinHeight) {
                    newHeight = newHeight + gridY;
                }
                if (isMaxWidth) {
                    newWidth = newWidth - gridX;
                }
                if (isMaxHeight) {
                    newHeight = newHeight - gridY;
                }
                if (/^(se|s|e)$/.test(a)) {
                    that.size.width = newWidth;
                    that.size.height = newHeight;
                } else if (/^(ne)$/.test(a)) {
                    that.size.width = newWidth;
                    that.size.height = newHeight;
                    that.position.top = op.top - oy;
                } else if (/^(sw)$/.test(a)) {
                    that.size.width = newWidth;
                    that.size.height = newHeight;
                    that.position.left = op.left - ox;
                } else {
                    that.size.width = newWidth;
                    that.size.height = newHeight;
                    that.position.top = op.top - oy;
                    that.position.left = op.left - ox;
                }
            }
        });
    })(jQuery);
    (function($, undefined) {
        $.widget("ui.selectable", $.ui.mouse, {
            version: "1.10.3",
            options: {
                appendTo: "body",
                autoRefresh: true,
                distance: 0,
                filter: "*",
                tolerance: "touch",
                // callbacks
                selected: null,
                selecting: null,
                start: null,
                stop: null,
                unselected: null,
                unselecting: null
            },
            _create: function() {
                var selectees, that = this;
                this.element.addClass("ui-selectable");
                this.dragged = false;
                // cache selectee children based on filter
                this.refresh = function() {
                    selectees = $(that.options.filter, that.element[0]);
                    selectees.addClass("ui-selectee");
                    selectees.each(function() {
                        var $this = $(this), pos = $this.offset();
                        $.data(this, "selectable-item", {
                            element: this,
                            $element: $this,
                            left: pos.left,
                            top: pos.top,
                            right: pos.left + $this.outerWidth(),
                            bottom: pos.top + $this.outerHeight(),
                            startselected: false,
                            selected: $this.hasClass("ui-selected"),
                            selecting: $this.hasClass("ui-selecting"),
                            unselecting: $this.hasClass("ui-unselecting")
                        });
                    });
                };
                this.refresh();
                this.selectees = selectees.addClass("ui-selectee");
                this._mouseInit();
                this.helper = $("<div class='ui-selectable-helper'></div>");
            },
            _destroy: function() {
                this.selectees.removeClass("ui-selectee").removeData("selectable-item");
                this.element.removeClass("ui-selectable ui-selectable-disabled");
                this._mouseDestroy();
            },
            _mouseStart: function(event) {
                var that = this, options = this.options;
                this.opos = [ event.pageX, event.pageY ];
                if (this.options.disabled) {
                    return;
                }
                this.selectees = $(options.filter, this.element[0]);
                this._trigger("start", event);
                $(options.appendTo).append(this.helper);
                // position helper (lasso)
                this.helper.css({
                    left: event.pageX,
                    top: event.pageY,
                    width: 0,
                    height: 0
                });
                if (options.autoRefresh) {
                    this.refresh();
                }
                this.selectees.filter(".ui-selected").each(function() {
                    var selectee = $.data(this, "selectable-item");
                    selectee.startselected = true;
                    if (!event.metaKey && !event.ctrlKey) {
                        selectee.$element.removeClass("ui-selected");
                        selectee.selected = false;
                        selectee.$element.addClass("ui-unselecting");
                        selectee.unselecting = true;
                        // selectable UNSELECTING callback
                        that._trigger("unselecting", event, {
                            unselecting: selectee.element
                        });
                    }
                });
                $(event.target).parents().addBack().each(function() {
                    var doSelect, selectee = $.data(this, "selectable-item");
                    if (selectee) {
                        doSelect = !event.metaKey && !event.ctrlKey || !selectee.$element.hasClass("ui-selected");
                        selectee.$element.removeClass(doSelect ? "ui-unselecting" : "ui-selected").addClass(doSelect ? "ui-selecting" : "ui-unselecting");
                        selectee.unselecting = !doSelect;
                        selectee.selecting = doSelect;
                        selectee.selected = doSelect;
                        // selectable (UN)SELECTING callback
                        if (doSelect) {
                            that._trigger("selecting", event, {
                                selecting: selectee.element
                            });
                        } else {
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            });
                        }
                        return false;
                    }
                });
            },
            _mouseDrag: function(event) {
                this.dragged = true;
                if (this.options.disabled) {
                    return;
                }
                var tmp, that = this, options = this.options, x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
                if (x1 > x2) {
                    tmp = x2;
                    x2 = x1;
                    x1 = tmp;
                }
                if (y1 > y2) {
                    tmp = y2;
                    y2 = y1;
                    y1 = tmp;
                }
                this.helper.css({
                    left: x1,
                    top: y1,
                    width: x2 - x1,
                    height: y2 - y1
                });
                this.selectees.each(function() {
                    var selectee = $.data(this, "selectable-item"), hit = false;
                    //prevent helper from being selected if appendTo: selectable
                    if (!selectee || selectee.element === that.element[0]) {
                        return;
                    }
                    if (options.tolerance === "touch") {
                        hit = !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1);
                    } else if (options.tolerance === "fit") {
                        hit = selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2;
                    }
                    if (hit) {
                        // SELECT
                        if (selectee.selected) {
                            selectee.$element.removeClass("ui-selected");
                            selectee.selected = false;
                        }
                        if (selectee.unselecting) {
                            selectee.$element.removeClass("ui-unselecting");
                            selectee.unselecting = false;
                        }
                        if (!selectee.selecting) {
                            selectee.$element.addClass("ui-selecting");
                            selectee.selecting = true;
                            // selectable SELECTING callback
                            that._trigger("selecting", event, {
                                selecting: selectee.element
                            });
                        }
                    } else {
                        // UNSELECT
                        if (selectee.selecting) {
                            if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
                                selectee.$element.removeClass("ui-selecting");
                                selectee.selecting = false;
                                selectee.$element.addClass("ui-selected");
                                selectee.selected = true;
                            } else {
                                selectee.$element.removeClass("ui-selecting");
                                selectee.selecting = false;
                                if (selectee.startselected) {
                                    selectee.$element.addClass("ui-unselecting");
                                    selectee.unselecting = true;
                                }
                                // selectable UNSELECTING callback
                                that._trigger("unselecting", event, {
                                    unselecting: selectee.element
                                });
                            }
                        }
                        if (selectee.selected) {
                            if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
                                selectee.$element.removeClass("ui-selected");
                                selectee.selected = false;
                                selectee.$element.addClass("ui-unselecting");
                                selectee.unselecting = true;
                                // selectable UNSELECTING callback
                                that._trigger("unselecting", event, {
                                    unselecting: selectee.element
                                });
                            }
                        }
                    }
                });
                return false;
            },
            _mouseStop: function(event) {
                var that = this;
                this.dragged = false;
                $(".ui-unselecting", this.element[0]).each(function() {
                    var selectee = $.data(this, "selectable-item");
                    selectee.$element.removeClass("ui-unselecting");
                    selectee.unselecting = false;
                    selectee.startselected = false;
                    that._trigger("unselected", event, {
                        unselected: selectee.element
                    });
                });
                $(".ui-selecting", this.element[0]).each(function() {
                    var selectee = $.data(this, "selectable-item");
                    selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
                    selectee.selecting = false;
                    selectee.selected = true;
                    selectee.startselected = true;
                    that._trigger("selected", event, {
                        selected: selectee.element
                    });
                });
                this._trigger("stop", event);
                this.helper.remove();
                return false;
            }
        });
    })(jQuery);
    (function($, undefined) {
        /*jshint loopfunc: true */
        function isOverAxis(x, reference, size) {
            return x > reference && x < reference + size;
        }
        function isFloating(item) {
            return /left|right/.test(item.css("float")) || /inline|table-cell/.test(item.css("display"));
        }
        $.widget("ui.sortable", $.ui.mouse, {
            version: "1.10.3",
            widgetEventPrefix: "sort",
            ready: false,
            options: {
                appendTo: "parent",
                axis: false,
                connectWith: false,
                containment: false,
                cursor: "auto",
                cursorAt: false,
                dropOnEmpty: true,
                forcePlaceholderSize: false,
                forceHelperSize: false,
                grid: false,
                handle: false,
                helper: "original",
                items: "> *",
                opacity: false,
                placeholder: false,
                revert: false,
                scroll: true,
                scrollSensitivity: 20,
                scrollSpeed: 20,
                scope: "default",
                tolerance: "intersect",
                zIndex: 1e3,
                // callbacks
                activate: null,
                beforeStop: null,
                change: null,
                deactivate: null,
                out: null,
                over: null,
                receive: null,
                remove: null,
                sort: null,
                start: null,
                stop: null,
                update: null
            },
            _create: function() {
                var o = this.options;
                this.containerCache = {};
                this.element.addClass("ui-sortable");
                //Get the items
                this.refresh();
                //Let's determine if the items are being displayed horizontally
                this.floating = this.items.length ? o.axis === "x" || isFloating(this.items[0].item) : false;
                //Let's determine the parent's offset
                this.offset = this.element.offset();
                //Initialize mouse events for interaction
                this._mouseInit();
                //We're ready to go
                this.ready = true;
            },
            _destroy: function() {
                this.element.removeClass("ui-sortable ui-sortable-disabled");
                this._mouseDestroy();
                for (var i = this.items.length - 1; i >= 0; i--) {
                    this.items[i].item.removeData(this.widgetName + "-item");
                }
                return this;
            },
            _setOption: function(key, value) {
                if (key === "disabled") {
                    this.options[key] = value;
                    this.widget().toggleClass("ui-sortable-disabled", !!value);
                } else {
                    // Don't call widget base _setOption for disable as it adds ui-state-disabled class
                    $.Widget.prototype._setOption.apply(this, arguments);
                }
            },
            _mouseCapture: function(event, overrideHandle) {
                var currentItem = null, validHandle = false, that = this;
                if (this.reverting) {
                    return false;
                }
                if (this.options.disabled || this.options.type === "static") {
                    return false;
                }
                //We have to refresh the items data once first
                this._refreshItems(event);
                //Find out if the clicked node (or one of its parents) is a actual item in this.items
                $(event.target).parents().each(function() {
                    if ($.data(this, that.widgetName + "-item") === that) {
                        currentItem = $(this);
                        return false;
                    }
                });
                if ($.data(event.target, that.widgetName + "-item") === that) {
                    currentItem = $(event.target);
                }
                if (!currentItem) {
                    return false;
                }
                if (this.options.handle && !overrideHandle) {
                    $(this.options.handle, currentItem).find("*").addBack().each(function() {
                        if (this === event.target) {
                            validHandle = true;
                        }
                    });
                    if (!validHandle) {
                        return false;
                    }
                }
                this.currentItem = currentItem;
                this._removeCurrentsFromItems();
                return true;
            },
            _mouseStart: function(event, overrideHandle, noActivation) {
                var i, body, o = this.options;
                this.currentContainer = this;
                //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
                this.refreshPositions();
                //Create and append the visible helper
                this.helper = this._createHelper(event);
                //Cache the helper size
                this._cacheHelperProportions();
                /*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */
                //Cache the margins of the original element
                this._cacheMargins();
                //Get the next scrolling parent
                this.scrollParent = this.helper.scrollParent();
                //The element's absolute position on the page minus margins
                this.offset = this.currentItem.offset();
                this.offset = {
                    top: this.offset.top - this.margins.top,
                    left: this.offset.left - this.margins.left
                };
                $.extend(this.offset, {
                    click: {
                        //Where the click happened, relative to the element
                        left: event.pageX - this.offset.left,
                        top: event.pageY - this.offset.top
                    },
                    parent: this._getParentOffset(),
                    relative: this._getRelativeOffset()
                });
                // Only after we got the offset, we can change the helper's position to absolute
                // TODO: Still need to figure out a way to make relative sorting possible
                this.helper.css("position", "absolute");
                this.cssPosition = this.helper.css("position");
                //Generate the original position
                this.originalPosition = this._generatePosition(event);
                this.originalPageX = event.pageX;
                this.originalPageY = event.pageY;
                //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
                o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
                //Cache the former DOM position
                this.domPosition = {
                    prev: this.currentItem.prev()[0],
                    parent: this.currentItem.parent()[0]
                };
                //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
                if (this.helper[0] !== this.currentItem[0]) {
                    this.currentItem.hide();
                }
                //Create the placeholder
                this._createPlaceholder();
                //Set a containment if given in the options
                if (o.containment) {
                    this._setContainment();
                }
                if (o.cursor && o.cursor !== "auto") {
                    // cursor option
                    body = this.document.find("body");
                    // support: IE
                    this.storedCursor = body.css("cursor");
                    body.css("cursor", o.cursor);
                    this.storedStylesheet = $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body);
                }
                if (o.opacity) {
                    // opacity option
                    if (this.helper.css("opacity")) {
                        this._storedOpacity = this.helper.css("opacity");
                    }
                    this.helper.css("opacity", o.opacity);
                }
                if (o.zIndex) {
                    // zIndex option
                    if (this.helper.css("zIndex")) {
                        this._storedZIndex = this.helper.css("zIndex");
                    }
                    this.helper.css("zIndex", o.zIndex);
                }
                //Prepare scrolling
                if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
                    this.overflowOffset = this.scrollParent.offset();
                }
                //Call callbacks
                this._trigger("start", event, this._uiHash());
                //Recache the helper size
                if (!this._preserveHelperProportions) {
                    this._cacheHelperProportions();
                }
                //Post "activate" events to possible containers
                if (!noActivation) {
                    for (i = this.containers.length - 1; i >= 0; i--) {
                        this.containers[i]._trigger("activate", event, this._uiHash(this));
                    }
                }
                //Prepare possible droppables
                if ($.ui.ddmanager) {
                    $.ui.ddmanager.current = this;
                }
                if ($.ui.ddmanager && !o.dropBehaviour) {
                    $.ui.ddmanager.prepareOffsets(this, event);
                }
                this.dragging = true;
                this.helper.addClass("ui-sortable-helper");
                this._mouseDrag(event);
                //Execute the drag once - this causes the helper not to be visible before getting its correct position
                return true;
            },
            _mouseDrag: function(event) {
                var i, item, itemElement, intersection, o = this.options, scrolled = false;
                //Compute the helpers position
                this.position = this._generatePosition(event);
                this.positionAbs = this._convertPositionTo("absolute");
                if (!this.lastPositionAbs) {
                    this.lastPositionAbs = this.positionAbs;
                }
                //Do scrolling
                if (this.options.scroll) {
                    if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
                        if (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {
                            this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
                        } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
                            this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
                        }
                        if (this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {
                            this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
                        } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
                            this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
                        }
                    } else {
                        if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                            scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                        } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                            scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                        }
                        if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                            scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                        } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                            scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                        }
                    }
                    if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                        $.ui.ddmanager.prepareOffsets(this, event);
                    }
                }
                //Regenerate the absolute position used for position checks
                this.positionAbs = this._convertPositionTo("absolute");
                //Set the helper position
                if (!this.options.axis || this.options.axis !== "y") {
                    this.helper[0].style.left = this.position.left + "px";
                }
                if (!this.options.axis || this.options.axis !== "x") {
                    this.helper[0].style.top = this.position.top + "px";
                }
                //Rearrange
                for (i = this.items.length - 1; i >= 0; i--) {
                    //Cache variables and intersection, continue if no intersection
                    item = this.items[i];
                    itemElement = item.item[0];
                    intersection = this._intersectsWithPointer(item);
                    if (!intersection) {
                        continue;
                    }
                    // Only put the placeholder inside the current Container, skip all
                    // items form other containers. This works because when moving
                    // an item from one container to another the
                    // currentContainer is switched before the placeholder is moved.
                    //
                    // Without this moving items in "sub-sortables" can cause the placeholder to jitter
                    // beetween the outer and inner container.
                    if (item.instance !== this.currentContainer) {
                        continue;
                    }
                    // cannot intersect with itself
                    // no useless actions that have been done before
                    // no action if the item moved is the parent of the item checked
                    if (itemElement !== this.currentItem[0] && this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)) {
                        this.direction = intersection === 1 ? "down" : "up";
                        if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
                            this._rearrange(event, item);
                        } else {
                            break;
                        }
                        this._trigger("change", event, this._uiHash());
                        break;
                    }
                }
                //Post events to containers
                this._contactContainers(event);
                //Interconnect with droppables
                if ($.ui.ddmanager) {
                    $.ui.ddmanager.drag(this, event);
                }
                //Call callbacks
                this._trigger("sort", event, this._uiHash());
                this.lastPositionAbs = this.positionAbs;
                return false;
            },
            _mouseStop: function(event, noPropagation) {
                if (!event) {
                    return;
                }
                //If we are using droppables, inform the manager about the drop
                if ($.ui.ddmanager && !this.options.dropBehaviour) {
                    $.ui.ddmanager.drop(this, event);
                }
                if (this.options.revert) {
                    var that = this, cur = this.placeholder.offset(), axis = this.options.axis, animation = {};
                    if (!axis || axis === "x") {
                        animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);
                    }
                    if (!axis || axis === "y") {
                        animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);
                    }
                    this.reverting = true;
                    $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function() {
                        that._clear(event);
                    });
                } else {
                    this._clear(event, noPropagation);
                }
                return false;
            },
            cancel: function() {
                if (this.dragging) {
                    this._mouseUp({
                        target: null
                    });
                    if (this.options.helper === "original") {
                        this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
                    } else {
                        this.currentItem.show();
                    }
                    //Post deactivating events to containers
                    for (var i = this.containers.length - 1; i >= 0; i--) {
                        this.containers[i]._trigger("deactivate", null, this._uiHash(this));
                        if (this.containers[i].containerCache.over) {
                            this.containers[i]._trigger("out", null, this._uiHash(this));
                            this.containers[i].containerCache.over = 0;
                        }
                    }
                }
                if (this.placeholder) {
                    //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
                    if (this.placeholder[0].parentNode) {
                        this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
                    }
                    if (this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
                        this.helper.remove();
                    }
                    $.extend(this, {
                        helper: null,
                        dragging: false,
                        reverting: false,
                        _noFinalSort: null
                    });
                    if (this.domPosition.prev) {
                        $(this.domPosition.prev).after(this.currentItem);
                    } else {
                        $(this.domPosition.parent).prepend(this.currentItem);
                    }
                }
                return this;
            },
            serialize: function(o) {
                var items = this._getItemsAsjQuery(o && o.connected), str = [];
                o = o || {};
                $(items).each(function() {
                    var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || /(.+)[\-=_](.+)/);
                    if (res) {
                        str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]));
                    }
                });
                if (!str.length && o.key) {
                    str.push(o.key + "=");
                }
                return str.join("&");
            },
            toArray: function(o) {
                var items = this._getItemsAsjQuery(o && o.connected), ret = [];
                o = o || {};
                items.each(function() {
                    ret.push($(o.item || this).attr(o.attribute || "id") || "");
                });
                return ret;
            },
            /* Be careful with the following core functions */
            _intersectsWith: function(item) {
                var x1 = this.positionAbs.left, x2 = x1 + this.helperProportions.width, y1 = this.positionAbs.top, y2 = y1 + this.helperProportions.height, l = item.left, r = l + item.width, t = item.top, b = t + item.height, dyClick = this.offset.click.top, dxClick = this.offset.click.left, isOverElementHeight = this.options.axis === "x" || y1 + dyClick > t && y1 + dyClick < b, isOverElementWidth = this.options.axis === "y" || x1 + dxClick > l && x1 + dxClick < r, isOverElement = isOverElementHeight && isOverElementWidth;
                if (this.options.tolerance === "pointer" || this.options.forcePointerForContainers || this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"]) {
                    return isOverElement;
                } else {
                    return l < x1 + this.helperProportions.width / 2 && // Right Half
                    x2 - this.helperProportions.width / 2 < r && // Left Half
                    t < y1 + this.helperProportions.height / 2 && // Bottom Half
                    y2 - this.helperProportions.height / 2 < b;
                }
            },
            _intersectsWithPointer: function(item) {
                var isOverElementHeight = this.options.axis === "x" || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height), isOverElementWidth = this.options.axis === "y" || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width), isOverElement = isOverElementHeight && isOverElementWidth, verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection();
                if (!isOverElement) {
                    return false;
                }
                return this.floating ? horizontalDirection && horizontalDirection === "right" || verticalDirection === "down" ? 2 : 1 : verticalDirection && (verticalDirection === "down" ? 2 : 1);
            },
            _intersectsWithSides: function(item) {
                var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height), isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width), verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection();
                if (this.floating && horizontalDirection) {
                    return horizontalDirection === "right" && isOverRightHalf || horizontalDirection === "left" && !isOverRightHalf;
                } else {
                    return verticalDirection && (verticalDirection === "down" && isOverBottomHalf || verticalDirection === "up" && !isOverBottomHalf);
                }
            },
            _getDragVerticalDirection: function() {
                var delta = this.positionAbs.top - this.lastPositionAbs.top;
                return delta !== 0 && (delta > 0 ? "down" : "up");
            },
            _getDragHorizontalDirection: function() {
                var delta = this.positionAbs.left - this.lastPositionAbs.left;
                return delta !== 0 && (delta > 0 ? "right" : "left");
            },
            refresh: function(event) {
                this._refreshItems(event);
                this.refreshPositions();
                return this;
            },
            _connectWith: function() {
                var options = this.options;
                return options.connectWith.constructor === String ? [ options.connectWith ] : options.connectWith;
            },
            _getItemsAsjQuery: function(connected) {
                var i, j, cur, inst, items = [], queries = [], connectWith = this._connectWith();
                if (connectWith && connected) {
                    for (i = connectWith.length - 1; i >= 0; i--) {
                        cur = $(connectWith[i]);
                        for (j = cur.length - 1; j >= 0; j--) {
                            inst = $.data(cur[j], this.widgetFullName);
                            if (inst && inst !== this && !inst.options.disabled) {
                                queries.push([ $.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst ]);
                            }
                        }
                    }
                }
                queries.push([ $.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
                    options: this.options,
                    item: this.currentItem
                }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this ]);
                for (i = queries.length - 1; i >= 0; i--) {
                    queries[i][0].each(function() {
                        items.push(this);
                    });
                }
                return $(items);
            },
            _removeCurrentsFromItems: function() {
                var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
                this.items = $.grep(this.items, function(item) {
                    for (var j = 0; j < list.length; j++) {
                        if (list[j] === item.item[0]) {
                            return false;
                        }
                    }
                    return true;
                });
            },
            _refreshItems: function(event) {
                this.items = [];
                this.containers = [ this ];
                var i, j, cur, inst, targetData, _queries, item, queriesLength, items = this.items, queries = [ [ $.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, {
                    item: this.currentItem
                }) : $(this.options.items, this.element), this ] ], connectWith = this._connectWith();
                if (connectWith && this.ready) {
                    //Shouldn't be run the first time through due to massive slow-down
                    for (i = connectWith.length - 1; i >= 0; i--) {
                        cur = $(connectWith[i]);
                        for (j = cur.length - 1; j >= 0; j--) {
                            inst = $.data(cur[j], this.widgetFullName);
                            if (inst && inst !== this && !inst.options.disabled) {
                                queries.push([ $.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, {
                                    item: this.currentItem
                                }) : $(inst.options.items, inst.element), inst ]);
                                this.containers.push(inst);
                            }
                        }
                    }
                }
                for (i = queries.length - 1; i >= 0; i--) {
                    targetData = queries[i][1];
                    _queries = queries[i][0];
                    for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
                        item = $(_queries[j]);
                        item.data(this.widgetName + "-item", targetData);
                        // Data for target checking (mouse manager)
                        items.push({
                            item: item,
                            instance: targetData,
                            width: 0,
                            height: 0,
                            left: 0,
                            top: 0
                        });
                    }
                }
            },
            refreshPositions: function(fast) {
                //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
                if (this.offsetParent && this.helper) {
                    this.offset.parent = this._getParentOffset();
                }
                var i, item, t, p;
                for (i = this.items.length - 1; i >= 0; i--) {
                    item = this.items[i];
                    //We ignore calculating positions of all connected containers when we're not over them
                    if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
                        continue;
                    }
                    t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
                    if (!fast) {
                        item.width = t.outerWidth();
                        item.height = t.outerHeight();
                    }
                    p = t.offset();
                    item.left = p.left;
                    item.top = p.top;
                }
                if (this.options.custom && this.options.custom.refreshContainers) {
                    this.options.custom.refreshContainers.call(this);
                } else {
                    for (i = this.containers.length - 1; i >= 0; i--) {
                        p = this.containers[i].element.offset();
                        this.containers[i].containerCache.left = p.left;
                        this.containers[i].containerCache.top = p.top;
                        this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
                        this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
                    }
                }
                return this;
            },
            _createPlaceholder: function(that) {
                that = that || this;
                var className, o = that.options;
                if (!o.placeholder || o.placeholder.constructor === String) {
                    className = o.placeholder;
                    o.placeholder = {
                        element: function() {
                            var nodeName = that.currentItem[0].nodeName.toLowerCase(), element = $("<" + nodeName + ">", that.document[0]).addClass(className || that.currentItem[0].className + " ui-sortable-placeholder").removeClass("ui-sortable-helper");
                            if (nodeName === "tr") {
                                that.currentItem.children().each(function() {
                                    $("<td>&#160;</td>", that.document[0]).attr("colspan", $(this).attr("colspan") || 1).appendTo(element);
                                });
                            } else if (nodeName === "img") {
                                element.attr("src", that.currentItem.attr("src"));
                            }
                            if (!className) {
                                element.css("visibility", "hidden");
                            }
                            return element;
                        },
                        update: function(container, p) {
                            // 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
                            // 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
                            if (className && !o.forcePlaceholderSize) {
                                return;
                            }
                            //If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
                            if (!p.height()) {
                                p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10));
                            }
                            if (!p.width()) {
                                p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10));
                            }
                        }
                    };
                }
                //Create the placeholder
                that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
                //Append it after the actual current item
                that.currentItem.after(that.placeholder);
                //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
                o.placeholder.update(that, that.placeholder);
            },
            _contactContainers: function(event) {
                var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom, floating, innermostContainer = null, innermostIndex = null;
                // get innermost container that intersects with item
                for (i = this.containers.length - 1; i >= 0; i--) {
                    // never consider a container that's located within the item itself
                    if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
                        continue;
                    }
                    if (this._intersectsWith(this.containers[i].containerCache)) {
                        // if we've already found a container and it's more "inner" than this, then continue
                        if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
                            continue;
                        }
                        innermostContainer = this.containers[i];
                        innermostIndex = i;
                    } else {
                        // container doesn't intersect. trigger "out" event if necessary
                        if (this.containers[i].containerCache.over) {
                            this.containers[i]._trigger("out", event, this._uiHash(this));
                            this.containers[i].containerCache.over = 0;
                        }
                    }
                }
                // if no intersecting containers found, return
                if (!innermostContainer) {
                    return;
                }
                // move the item into the container if it's not there already
                if (this.containers.length === 1) {
                    if (!this.containers[innermostIndex].containerCache.over) {
                        this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                        this.containers[innermostIndex].containerCache.over = 1;
                    }
                } else {
                    //When entering a new container, we will find the item with the least distance and append our item near it
                    dist = 1e4;
                    itemWithLeastDistance = null;
                    floating = innermostContainer.floating || isFloating(this.currentItem);
                    posProperty = floating ? "left" : "top";
                    sizeProperty = floating ? "width" : "height";
                    base = this.positionAbs[posProperty] + this.offset.click[posProperty];
                    for (j = this.items.length - 1; j >= 0; j--) {
                        if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
                            continue;
                        }
                        if (this.items[j].item[0] === this.currentItem[0]) {
                            continue;
                        }
                        if (floating && !isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)) {
                            continue;
                        }
                        cur = this.items[j].item.offset()[posProperty];
                        nearBottom = false;
                        if (Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)) {
                            nearBottom = true;
                            cur += this.items[j][sizeProperty];
                        }
                        if (Math.abs(cur - base) < dist) {
                            dist = Math.abs(cur - base);
                            itemWithLeastDistance = this.items[j];
                            this.direction = nearBottom ? "up" : "down";
                        }
                    }
                    //Check if dropOnEmpty is enabled
                    if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
                        return;
                    }
                    if (this.currentContainer === this.containers[innermostIndex]) {
                        return;
                    }
                    itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
                    this._trigger("change", event, this._uiHash());
                    this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
                    this.currentContainer = this.containers[innermostIndex];
                    //Update the placeholder
                    this.options.placeholder.update(this.currentContainer, this.placeholder);
                    this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                    this.containers[innermostIndex].containerCache.over = 1;
                }
            },
            _createHelper: function(event) {
                var o = this.options, helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [ event, this.currentItem ])) : o.helper === "clone" ? this.currentItem.clone() : this.currentItem;
                //Add the helper to the DOM if that didn't happen already
                if (!helper.parents("body").length) {
                    $(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
                }
                if (helper[0] === this.currentItem[0]) {
                    this._storedCSS = {
                        width: this.currentItem[0].style.width,
                        height: this.currentItem[0].style.height,
                        position: this.currentItem.css("position"),
                        top: this.currentItem.css("top"),
                        left: this.currentItem.css("left")
                    };
                }
                if (!helper[0].style.width || o.forceHelperSize) {
                    helper.width(this.currentItem.width());
                }
                if (!helper[0].style.height || o.forceHelperSize) {
                    helper.height(this.currentItem.height());
                }
                return helper;
            },
            _adjustOffsetFromHelper: function(obj) {
                if (typeof obj === "string") {
                    obj = obj.split(" ");
                }
                if ($.isArray(obj)) {
                    obj = {
                        left: +obj[0],
                        top: +obj[1] || 0
                    };
                }
                if ("left" in obj) {
                    this.offset.click.left = obj.left + this.margins.left;
                }
                if ("right" in obj) {
                    this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
                }
                if ("top" in obj) {
                    this.offset.click.top = obj.top + this.margins.top;
                }
                if ("bottom" in obj) {
                    this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
                }
            },
            _getParentOffset: function() {
                //Get the offsetParent and cache its position
                this.offsetParent = this.helper.offsetParent();
                var po = this.offsetParent.offset();
                // This is a special case where we need to modify a offset calculated on start, since the following happened:
                // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
                // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
                //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
                if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                    po.left += this.scrollParent.scrollLeft();
                    po.top += this.scrollParent.scrollTop();
                }
                // This needs to be actually done for all browsers, since pageX/pageY includes this information
                // with an ugly IE fix
                if (this.offsetParent[0] === document.body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie) {
                    po = {
                        top: 0,
                        left: 0
                    };
                }
                return {
                    top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                    left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
                };
            },
            _getRelativeOffset: function() {
                if (this.cssPosition === "relative") {
                    var p = this.currentItem.position();
                    return {
                        top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                        left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                    };
                } else {
                    return {
                        top: 0,
                        left: 0
                    };
                }
            },
            _cacheMargins: function() {
                this.margins = {
                    left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
                    top: parseInt(this.currentItem.css("marginTop"), 10) || 0
                };
            },
            _cacheHelperProportions: function() {
                this.helperProportions = {
                    width: this.helper.outerWidth(),
                    height: this.helper.outerHeight()
                };
            },
            _setContainment: function() {
                var ce, co, over, o = this.options;
                if (o.containment === "parent") {
                    o.containment = this.helper[0].parentNode;
                }
                if (o.containment === "document" || o.containment === "window") {
                    this.containment = [ 0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, $(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left, ($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ];
                }
                if (!/^(document|window|parent)$/.test(o.containment)) {
                    ce = $(o.containment)[0];
                    co = $(o.containment).offset();
                    over = $(ce).css("overflow") !== "hidden";
                    this.containment = [ co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left, co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top ];
                }
            },
            _convertPositionTo: function(d, pos) {
                if (!pos) {
                    pos = this.position;
                }
                var mod = d === "absolute" ? 1 : -1, scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
                return {
                    top: pos.top + // The absolute mouse position
                    this.offset.relative.top * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.top * mod - // The offsetParent's offset without borders (offset + border)
                    (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,
                    left: pos.left + // The absolute mouse position
                    this.offset.relative.left * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.left * mod - // The offsetParent's offset without borders (offset + border)
                    (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod
                };
            },
            _generatePosition: function(event) {
                var top, left, o = this.options, pageX = event.pageX, pageY = event.pageY, scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
                // This is another very weird special case that only happens for relative elements:
                // 1. If the css position is relative
                // 2. and the scroll parent is the document or similar to the offset parent
                // we have to refresh the relative offset during the scroll so there are no jumps
                if (this.cssPosition === "relative" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
                    this.offset.relative = this._getRelativeOffset();
                }
                /*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */
                if (this.originalPosition) {
                    //If we are not dragging yet, we won't check for options
                    if (this.containment) {
                        if (event.pageX - this.offset.click.left < this.containment[0]) {
                            pageX = this.containment[0] + this.offset.click.left;
                        }
                        if (event.pageY - this.offset.click.top < this.containment[1]) {
                            pageY = this.containment[1] + this.offset.click.top;
                        }
                        if (event.pageX - this.offset.click.left > this.containment[2]) {
                            pageX = this.containment[2] + this.offset.click.left;
                        }
                        if (event.pageY - this.offset.click.top > this.containment[3]) {
                            pageY = this.containment[3] + this.offset.click.top;
                        }
                    }
                    if (o.grid) {
                        top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
                        pageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
                        left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
                        pageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
                    }
                }
                return {
                    top: pageY - // The absolute mouse position
                    this.offset.click.top - // Click offset (relative to the element)
                    this.offset.relative.top - // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.top + (// The offsetParent's offset without borders (offset + border)
                    this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),
                    left: pageX - // The absolute mouse position
                    this.offset.click.left - // Click offset (relative to the element)
                    this.offset.relative.left - // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.left + (// The offsetParent's offset without borders (offset + border)
                    this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())
                };
            },
            _rearrange: function(event, i, a, hardRefresh) {
                a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], this.direction === "down" ? i.item[0] : i.item[0].nextSibling);
                //Various things done here to improve the performance:
                // 1. we create a setTimeout, that calls refreshPositions
                // 2. on the instance, we have a counter variable, that get's higher after every append
                // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
                // 4. this lets only the last addition to the timeout stack through
                this.counter = this.counter ? ++this.counter : 1;
                var counter = this.counter;
                this._delay(function() {
                    if (counter === this.counter) {
                        this.refreshPositions(!hardRefresh);
                    }
                });
            },
            _clear: function(event, noPropagation) {
                this.reverting = false;
                // We delay all events that have to be triggered to after the point where the placeholder has been removed and
                // everything else normalized again
                var i, delayedTriggers = [];
                // We first have to update the dom position of the actual currentItem
                // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
                if (!this._noFinalSort && this.currentItem.parent().length) {
                    this.placeholder.before(this.currentItem);
                }
                this._noFinalSort = null;
                if (this.helper[0] === this.currentItem[0]) {
                    for (i in this._storedCSS) {
                        if (this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
                            this._storedCSS[i] = "";
                        }
                    }
                    this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
                } else {
                    this.currentItem.show();
                }
                if (this.fromOutside && !noPropagation) {
                    delayedTriggers.push(function(event) {
                        this._trigger("receive", event, this._uiHash(this.fromOutside));
                    });
                }
                if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
                    delayedTriggers.push(function(event) {
                        this._trigger("update", event, this._uiHash());
                    });
                }
                // Check if the items Container has Changed and trigger appropriate
                // events.
                if (this !== this.currentContainer) {
                    if (!noPropagation) {
                        delayedTriggers.push(function(event) {
                            this._trigger("remove", event, this._uiHash());
                        });
                        delayedTriggers.push(function(c) {
                            return function(event) {
                                c._trigger("receive", event, this._uiHash(this));
                            };
                        }.call(this, this.currentContainer));
                        delayedTriggers.push(function(c) {
                            return function(event) {
                                c._trigger("update", event, this._uiHash(this));
                            };
                        }.call(this, this.currentContainer));
                    }
                }
                //Post events to containers
                for (i = this.containers.length - 1; i >= 0; i--) {
                    if (!noPropagation) {
                        delayedTriggers.push(function(c) {
                            return function(event) {
                                c._trigger("deactivate", event, this._uiHash(this));
                            };
                        }.call(this, this.containers[i]));
                    }
                    if (this.containers[i].containerCache.over) {
                        delayedTriggers.push(function(c) {
                            return function(event) {
                                c._trigger("out", event, this._uiHash(this));
                            };
                        }.call(this, this.containers[i]));
                        this.containers[i].containerCache.over = 0;
                    }
                }
                //Do what was originally in plugins
                if (this.storedCursor) {
                    this.document.find("body").css("cursor", this.storedCursor);
                    this.storedStylesheet.remove();
                }
                if (this._storedOpacity) {
                    this.helper.css("opacity", this._storedOpacity);
                }
                if (this._storedZIndex) {
                    this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
                }
                this.dragging = false;
                if (this.cancelHelperRemoval) {
                    if (!noPropagation) {
                        this._trigger("beforeStop", event, this._uiHash());
                        for (i = 0; i < delayedTriggers.length; i++) {
                            delayedTriggers[i].call(this, event);
                        }
                        //Trigger all delayed events
                        this._trigger("stop", event, this._uiHash());
                    }
                    this.fromOutside = false;
                    return false;
                }
                if (!noPropagation) {
                    this._trigger("beforeStop", event, this._uiHash());
                }
                //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
                this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
                if (this.helper[0] !== this.currentItem[0]) {
                    this.helper.remove();
                }
                this.helper = null;
                if (!noPropagation) {
                    for (i = 0; i < delayedTriggers.length; i++) {
                        delayedTriggers[i].call(this, event);
                    }
                    //Trigger all delayed events
                    this._trigger("stop", event, this._uiHash());
                }
                this.fromOutside = false;
                return true;
            },
            _trigger: function() {
                if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
                    this.cancel();
                }
            },
            _uiHash: function(_inst) {
                var inst = _inst || this;
                return {
                    helper: inst.helper,
                    placeholder: inst.placeholder || $([]),
                    position: inst.position,
                    originalPosition: inst.originalPosition,
                    offset: inst.positionAbs,
                    item: inst.currentItem,
                    sender: _inst ? _inst.element : null
                };
            }
        });
    })(jQuery);
    (function($, undefined) {
        var dataSpace = "ui-effects-";
        $.effects = {
            effect: {}
        };
        /*!
 * jQuery Color Animations v2.1.2
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Wed Jan 16 08:47:09 2013 -0600
 */
        (function(jQuery, undefined) {
            var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor", // plusequals test for += 100 -= 100
            rplusequals = /^([\-+])=\s*(\d+\.?\d*)/, // a set of RE's that can match strings and generate color tuples.
            stringParsers = [ {
                re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                parse: function(execResult) {
                    return [ execResult[1], execResult[2], execResult[3], execResult[4] ];
                }
            }, {
                re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                parse: function(execResult) {
                    return [ execResult[1] * 2.55, execResult[2] * 2.55, execResult[3] * 2.55, execResult[4] ];
                }
            }, {
                // this regex ignores A-F because it's compared against an already lowercased string
                re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
                parse: function(execResult) {
                    return [ parseInt(execResult[1], 16), parseInt(execResult[2], 16), parseInt(execResult[3], 16) ];
                }
            }, {
                // this regex ignores A-F because it's compared against an already lowercased string
                re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
                parse: function(execResult) {
                    return [ parseInt(execResult[1] + execResult[1], 16), parseInt(execResult[2] + execResult[2], 16), parseInt(execResult[3] + execResult[3], 16) ];
                }
            }, {
                re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                space: "hsla",
                parse: function(execResult) {
                    return [ execResult[1], execResult[2] / 100, execResult[3] / 100, execResult[4] ];
                }
            } ], // jQuery.Color( )
            color = jQuery.Color = function(color, green, blue, alpha) {
                return new jQuery.Color.fn.parse(color, green, blue, alpha);
            }, spaces = {
                rgba: {
                    props: {
                        red: {
                            idx: 0,
                            type: "byte"
                        },
                        green: {
                            idx: 1,
                            type: "byte"
                        },
                        blue: {
                            idx: 2,
                            type: "byte"
                        }
                    }
                },
                hsla: {
                    props: {
                        hue: {
                            idx: 0,
                            type: "degrees"
                        },
                        saturation: {
                            idx: 1,
                            type: "percent"
                        },
                        lightness: {
                            idx: 2,
                            type: "percent"
                        }
                    }
                }
            }, propTypes = {
                "byte": {
                    floor: true,
                    max: 255
                },
                percent: {
                    max: 1
                },
                degrees: {
                    mod: 360,
                    floor: true
                }
            }, support = color.support = {}, // element for support tests
            supportElem = jQuery("<p>")[0], // colors = jQuery.Color.names
            colors, // local aliases of functions called often
            each = jQuery.each;
            // determine rgba support immediately
            supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
            support.rgba = supportElem.style.backgroundColor.indexOf("rgba") > -1;
            // define cache name and alpha properties
            // for rgba and hsla spaces
            each(spaces, function(spaceName, space) {
                space.cache = "_" + spaceName;
                space.props.alpha = {
                    idx: 3,
                    type: "percent",
                    def: 1
                };
            });
            function clamp(value, prop, allowEmpty) {
                var type = propTypes[prop.type] || {};
                if (value == null) {
                    return allowEmpty || !prop.def ? null : prop.def;
                }
                // ~~ is an short way of doing floor for positive numbers
                value = type.floor ? ~~value : parseFloat(value);
                // IE will pass in empty strings as value for alpha,
                // which will hit this case
                if (isNaN(value)) {
                    return prop.def;
                }
                if (type.mod) {
                    // we add mod before modding to make sure that negatives values
                    // get converted properly: -10 -> 350
                    return (value + type.mod) % type.mod;
                }
                // for now all property types without mod have min and max
                return 0 > value ? 0 : type.max < value ? type.max : value;
            }
            function stringParse(string) {
                var inst = color(), rgba = inst._rgba = [];
                string = string.toLowerCase();
                each(stringParsers, function(i, parser) {
                    var parsed, match = parser.re.exec(string), values = match && parser.parse(match), spaceName = parser.space || "rgba";
                    if (values) {
                        parsed = inst[spaceName](values);
                        // if this was an rgba parse the assignment might happen twice
                        // oh well....
                        inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];
                        rgba = inst._rgba = parsed._rgba;
                        // exit each( stringParsers ) here because we matched
                        return false;
                    }
                });
                // Found a stringParser that handled it
                if (rgba.length) {
                    // if this came from a parsed string, force "transparent" when alpha is 0
                    // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
                    if (rgba.join() === "0,0,0,0") {
                        jQuery.extend(rgba, colors.transparent);
                    }
                    return inst;
                }
                // named colors
                return colors[string];
            }
            color.fn = jQuery.extend(color.prototype, {
                parse: function(red, green, blue, alpha) {
                    if (red === undefined) {
                        this._rgba = [ null, null, null, null ];
                        return this;
                    }
                    if (red.jquery || red.nodeType) {
                        red = jQuery(red).css(green);
                        green = undefined;
                    }
                    var inst = this, type = jQuery.type(red), rgba = this._rgba = [];
                    // more than 1 argument specified - assume ( red, green, blue, alpha )
                    if (green !== undefined) {
                        red = [ red, green, blue, alpha ];
                        type = "array";
                    }
                    if (type === "string") {
                        return this.parse(stringParse(red) || colors._default);
                    }
                    if (type === "array") {
                        each(spaces.rgba.props, function(key, prop) {
                            rgba[prop.idx] = clamp(red[prop.idx], prop);
                        });
                        return this;
                    }
                    if (type === "object") {
                        if (red instanceof color) {
                            each(spaces, function(spaceName, space) {
                                if (red[space.cache]) {
                                    inst[space.cache] = red[space.cache].slice();
                                }
                            });
                        } else {
                            each(spaces, function(spaceName, space) {
                                var cache = space.cache;
                                each(space.props, function(key, prop) {
                                    // if the cache doesn't exist, and we know how to convert
                                    if (!inst[cache] && space.to) {
                                        // if the value was null, we don't need to copy it
                                        // if the key was alpha, we don't need to copy it either
                                        if (key === "alpha" || red[key] == null) {
                                            return;
                                        }
                                        inst[cache] = space.to(inst._rgba);
                                    }
                                    // this is the only case where we allow nulls for ALL properties.
                                    // call clamp with alwaysAllowEmpty
                                    inst[cache][prop.idx] = clamp(red[key], prop, true);
                                });
                                // everything defined but alpha?
                                if (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {
                                    // use the default of 1
                                    inst[cache][3] = 1;
                                    if (space.from) {
                                        inst._rgba = space.from(inst[cache]);
                                    }
                                }
                            });
                        }
                        return this;
                    }
                },
                is: function(compare) {
                    var is = color(compare), same = true, inst = this;
                    each(spaces, function(_, space) {
                        var localCache, isCache = is[space.cache];
                        if (isCache) {
                            localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];
                            each(space.props, function(_, prop) {
                                if (isCache[prop.idx] != null) {
                                    same = isCache[prop.idx] === localCache[prop.idx];
                                    return same;
                                }
                            });
                        }
                        return same;
                    });
                    return same;
                },
                _space: function() {
                    var used = [], inst = this;
                    each(spaces, function(spaceName, space) {
                        if (inst[space.cache]) {
                            used.push(spaceName);
                        }
                    });
                    return used.pop();
                },
                transition: function(other, distance) {
                    var end = color(other), spaceName = end._space(), space = spaces[spaceName], startColor = this.alpha() === 0 ? color("transparent") : this, start = startColor[space.cache] || space.to(startColor._rgba), result = start.slice();
                    end = end[space.cache];
                    each(space.props, function(key, prop) {
                        var index = prop.idx, startValue = start[index], endValue = end[index], type = propTypes[prop.type] || {};
                        // if null, don't override start value
                        if (endValue === null) {
                            return;
                        }
                        // if null - use end
                        if (startValue === null) {
                            result[index] = endValue;
                        } else {
                            if (type.mod) {
                                if (endValue - startValue > type.mod / 2) {
                                    startValue += type.mod;
                                } else if (startValue - endValue > type.mod / 2) {
                                    startValue -= type.mod;
                                }
                            }
                            result[index] = clamp((endValue - startValue) * distance + startValue, prop);
                        }
                    });
                    return this[spaceName](result);
                },
                blend: function(opaque) {
                    // if we are already opaque - return ourself
                    if (this._rgba[3] === 1) {
                        return this;
                    }
                    var rgb = this._rgba.slice(), a = rgb.pop(), blend = color(opaque)._rgba;
                    return color(jQuery.map(rgb, function(v, i) {
                        return (1 - a) * blend[i] + a * v;
                    }));
                },
                toRgbaString: function() {
                    var prefix = "rgba(", rgba = jQuery.map(this._rgba, function(v, i) {
                        return v == null ? i > 2 ? 1 : 0 : v;
                    });
                    if (rgba[3] === 1) {
                        rgba.pop();
                        prefix = "rgb(";
                    }
                    return prefix + rgba.join() + ")";
                },
                toHslaString: function() {
                    var prefix = "hsla(", hsla = jQuery.map(this.hsla(), function(v, i) {
                        if (v == null) {
                            v = i > 2 ? 1 : 0;
                        }
                        // catch 1 and 2
                        if (i && i < 3) {
                            v = Math.round(v * 100) + "%";
                        }
                        return v;
                    });
                    if (hsla[3] === 1) {
                        hsla.pop();
                        prefix = "hsl(";
                    }
                    return prefix + hsla.join() + ")";
                },
                toHexString: function(includeAlpha) {
                    var rgba = this._rgba.slice(), alpha = rgba.pop();
                    if (includeAlpha) {
                        rgba.push(~~(alpha * 255));
                    }
                    return "#" + jQuery.map(rgba, function(v) {
                        // default to 0 when nulls exist
                        v = (v || 0).toString(16);
                        return v.length === 1 ? "0" + v : v;
                    }).join("");
                },
                toString: function() {
                    return this._rgba[3] === 0 ? "transparent" : this.toRgbaString();
                }
            });
            color.fn.parse.prototype = color.fn;
            // hsla conversions adapted from:
            // https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021
            function hue2rgb(p, q, h) {
                h = (h + 1) % 1;
                if (h * 6 < 1) {
                    return p + (q - p) * h * 6;
                }
                if (h * 2 < 1) {
                    return q;
                }
                if (h * 3 < 2) {
                    return p + (q - p) * (2 / 3 - h) * 6;
                }
                return p;
            }
            spaces.hsla.to = function(rgba) {
                if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {
                    return [ null, null, null, rgba[3] ];
                }
                var r = rgba[0] / 255, g = rgba[1] / 255, b = rgba[2] / 255, a = rgba[3], max = Math.max(r, g, b), min = Math.min(r, g, b), diff = max - min, add = max + min, l = add * .5, h, s;
                if (min === max) {
                    h = 0;
                } else if (r === max) {
                    h = 60 * (g - b) / diff + 360;
                } else if (g === max) {
                    h = 60 * (b - r) / diff + 120;
                } else {
                    h = 60 * (r - g) / diff + 240;
                }
                // chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
                // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
                if (diff === 0) {
                    s = 0;
                } else if (l <= .5) {
                    s = diff / add;
                } else {
                    s = diff / (2 - add);
                }
                return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
            };
            spaces.hsla.from = function(hsla) {
                if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {
                    return [ null, null, null, hsla[3] ];
                }
                var h = hsla[0] / 360, s = hsla[1], l = hsla[2], a = hsla[3], q = l <= .5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
                return [ Math.round(hue2rgb(p, q, h + 1 / 3) * 255), Math.round(hue2rgb(p, q, h) * 255), Math.round(hue2rgb(p, q, h - 1 / 3) * 255), a ];
            };
            each(spaces, function(spaceName, space) {
                var props = space.props, cache = space.cache, to = space.to, from = space.from;
                // makes rgba() and hsla()
                color.fn[spaceName] = function(value) {
                    // generate a cache for this space if it doesn't exist
                    if (to && !this[cache]) {
                        this[cache] = to(this._rgba);
                    }
                    if (value === undefined) {
                        return this[cache].slice();
                    }
                    var ret, type = jQuery.type(value), arr = type === "array" || type === "object" ? value : arguments, local = this[cache].slice();
                    each(props, function(key, prop) {
                        var val = arr[type === "object" ? key : prop.idx];
                        if (val == null) {
                            val = local[prop.idx];
                        }
                        local[prop.idx] = clamp(val, prop);
                    });
                    if (from) {
                        ret = color(from(local));
                        ret[cache] = local;
                        return ret;
                    } else {
                        return color(local);
                    }
                };
                // makes red() green() blue() alpha() hue() saturation() lightness()
                each(props, function(key, prop) {
                    // alpha is included in more than one space
                    if (color.fn[key]) {
                        return;
                    }
                    color.fn[key] = function(value) {
                        var vtype = jQuery.type(value), fn = key === "alpha" ? this._hsla ? "hsla" : "rgba" : spaceName, local = this[fn](), cur = local[prop.idx], match;
                        if (vtype === "undefined") {
                            return cur;
                        }
                        if (vtype === "function") {
                            value = value.call(this, cur);
                            vtype = jQuery.type(value);
                        }
                        if (value == null && prop.empty) {
                            return this;
                        }
                        if (vtype === "string") {
                            match = rplusequals.exec(value);
                            if (match) {
                                value = cur + parseFloat(match[2]) * (match[1] === "+" ? 1 : -1);
                            }
                        }
                        local[prop.idx] = value;
                        return this[fn](local);
                    };
                });
            });
            // add cssHook and .fx.step function for each named hook.
            // accept a space separated string of properties
            color.hook = function(hook) {
                var hooks = hook.split(" ");
                each(hooks, function(i, hook) {
                    jQuery.cssHooks[hook] = {
                        set: function(elem, value) {
                            var parsed, curElem, backgroundColor = "";
                            if (value !== "transparent" && (jQuery.type(value) !== "string" || (parsed = stringParse(value)))) {
                                value = color(parsed || value);
                                if (!support.rgba && value._rgba[3] !== 1) {
                                    curElem = hook === "backgroundColor" ? elem.parentNode : elem;
                                    while ((backgroundColor === "" || backgroundColor === "transparent") && curElem && curElem.style) {
                                        try {
                                            backgroundColor = jQuery.css(curElem, "backgroundColor");
                                            curElem = curElem.parentNode;
                                        } catch (e) {}
                                    }
                                    value = value.blend(backgroundColor && backgroundColor !== "transparent" ? backgroundColor : "_default");
                                }
                                value = value.toRgbaString();
                            }
                            try {
                                elem.style[hook] = value;
                            } catch (e) {}
                        }
                    };
                    jQuery.fx.step[hook] = function(fx) {
                        if (!fx.colorInit) {
                            fx.start = color(fx.elem, hook);
                            fx.end = color(fx.end);
                            fx.colorInit = true;
                        }
                        jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));
                    };
                });
            };
            color.hook(stepHooks);
            jQuery.cssHooks.borderColor = {
                expand: function(value) {
                    var expanded = {};
                    each([ "Top", "Right", "Bottom", "Left" ], function(i, part) {
                        expanded["border" + part + "Color"] = value;
                    });
                    return expanded;
                }
            };
            // Basic color names only.
            // Usage of any of the other color names requires adding yourself or including
            // jquery.color.svg-names.js.
            colors = jQuery.Color.names = {
                // 4.1. Basic color keywords
                aqua: "#00ffff",
                black: "#000000",
                blue: "#0000ff",
                fuchsia: "#ff00ff",
                gray: "#808080",
                green: "#008000",
                lime: "#00ff00",
                maroon: "#800000",
                navy: "#000080",
                olive: "#808000",
                purple: "#800080",
                red: "#ff0000",
                silver: "#c0c0c0",
                teal: "#008080",
                white: "#ffffff",
                yellow: "#ffff00",
                // 4.2.3. "transparent" color keyword
                transparent: [ null, null, null, 0 ],
                _default: "#ffffff"
            };
        })(jQuery);
        /******************************************************************************/
        /****************************** CLASS ANIMATIONS ******************************/
        /******************************************************************************/
        (function() {
            var classAnimationActions = [ "add", "remove", "toggle" ], shorthandStyles = {
                border: 1,
                borderBottom: 1,
                borderColor: 1,
                borderLeft: 1,
                borderRight: 1,
                borderTop: 1,
                borderWidth: 1,
                margin: 1,
                padding: 1
            };
            $.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function(_, prop) {
                $.fx.step[prop] = function(fx) {
                    if (fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {
                        jQuery.style(fx.elem, prop, fx.end);
                        fx.setAttr = true;
                    }
                };
            });
            function getElementStyles(elem) {
                var key, len, style = elem.ownerDocument.defaultView ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : elem.currentStyle, styles = {};
                if (style && style.length && style[0] && style[style[0]]) {
                    len = style.length;
                    while (len--) {
                        key = style[len];
                        if (typeof style[key] === "string") {
                            styles[$.camelCase(key)] = style[key];
                        }
                    }
                } else {
                    for (key in style) {
                        if (typeof style[key] === "string") {
                            styles[key] = style[key];
                        }
                    }
                }
                return styles;
            }
            function styleDifference(oldStyle, newStyle) {
                var diff = {}, name, value;
                for (name in newStyle) {
                    value = newStyle[name];
                    if (oldStyle[name] !== value) {
                        if (!shorthandStyles[name]) {
                            if ($.fx.step[name] || !isNaN(parseFloat(value))) {
                                diff[name] = value;
                            }
                        }
                    }
                }
                return diff;
            }
            // support: jQuery <1.8
            if (!$.fn.addBack) {
                $.fn.addBack = function(selector) {
                    return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
                };
            }
            $.effects.animateClass = function(value, duration, easing, callback) {
                var o = $.speed(duration, easing, callback);
                return this.queue(function() {
                    var animated = $(this), baseClass = animated.attr("class") || "", applyClassChange, allAnimations = o.children ? animated.find("*").addBack() : animated;
                    // map the animated objects to store the original styles.
                    allAnimations = allAnimations.map(function() {
                        var el = $(this);
                        return {
                            el: el,
                            start: getElementStyles(this)
                        };
                    });
                    // apply class change
                    applyClassChange = function() {
                        $.each(classAnimationActions, function(i, action) {
                            if (value[action]) {
                                animated[action + "Class"](value[action]);
                            }
                        });
                    };
                    applyClassChange();
                    // map all animated objects again - calculate new styles and diff
                    allAnimations = allAnimations.map(function() {
                        this.end = getElementStyles(this.el[0]);
                        this.diff = styleDifference(this.start, this.end);
                        return this;
                    });
                    // apply original class
                    animated.attr("class", baseClass);
                    // map all animated objects again - this time collecting a promise
                    allAnimations = allAnimations.map(function() {
                        var styleInfo = this, dfd = $.Deferred(), opts = $.extend({}, o, {
                            queue: false,
                            complete: function() {
                                dfd.resolve(styleInfo);
                            }
                        });
                        this.el.animate(this.diff, opts);
                        return dfd.promise();
                    });
                    // once all animations have completed:
                    $.when.apply($, allAnimations.get()).done(function() {
                        // set the final class
                        applyClassChange();
                        // for each animated element,
                        // clear all css properties that were animated
                        $.each(arguments, function() {
                            var el = this.el;
                            $.each(this.diff, function(key) {
                                el.css(key, "");
                            });
                        });
                        // this is guarnteed to be there if you use jQuery.speed()
                        // it also handles dequeuing the next anim...
                        o.complete.call(animated[0]);
                    });
                });
            };
            $.fn.extend({
                addClass: function(orig) {
                    return function(classNames, speed, easing, callback) {
                        return speed ? $.effects.animateClass.call(this, {
                            add: classNames
                        }, speed, easing, callback) : orig.apply(this, arguments);
                    };
                }($.fn.addClass),
                removeClass: function(orig) {
                    return function(classNames, speed, easing, callback) {
                        return arguments.length > 1 ? $.effects.animateClass.call(this, {
                            remove: classNames
                        }, speed, easing, callback) : orig.apply(this, arguments);
                    };
                }($.fn.removeClass),
                toggleClass: function(orig) {
                    return function(classNames, force, speed, easing, callback) {
                        if (typeof force === "boolean" || force === undefined) {
                            if (!speed) {
                                // without speed parameter
                                return orig.apply(this, arguments);
                            } else {
                                return $.effects.animateClass.call(this, force ? {
                                    add: classNames
                                } : {
                                    remove: classNames
                                }, speed, easing, callback);
                            }
                        } else {
                            // without force parameter
                            return $.effects.animateClass.call(this, {
                                toggle: classNames
                            }, force, speed, easing);
                        }
                    };
                }($.fn.toggleClass),
                switchClass: function(remove, add, speed, easing, callback) {
                    return $.effects.animateClass.call(this, {
                        add: add,
                        remove: remove
                    }, speed, easing, callback);
                }
            });
        })();
        /******************************************************************************/
        /*********************************** EFFECTS **********************************/
        /******************************************************************************/
        (function() {
            $.extend($.effects, {
                version: "1.10.3",
                // Saves a set of properties in a data storage
                save: function(element, set) {
                    for (var i = 0; i < set.length; i++) {
                        if (set[i] !== null) {
                            element.data(dataSpace + set[i], element[0].style[set[i]]);
                        }
                    }
                },
                // Restores a set of previously saved properties from a data storage
                restore: function(element, set) {
                    var val, i;
                    for (i = 0; i < set.length; i++) {
                        if (set[i] !== null) {
                            val = element.data(dataSpace + set[i]);
                            // support: jQuery 1.6.2
                            // http://bugs.jquery.com/ticket/9917
                            // jQuery 1.6.2 incorrectly returns undefined for any falsy value.
                            // We can't differentiate between "" and 0 here, so we just assume
                            // empty string since it's likely to be a more common value...
                            if (val === undefined) {
                                val = "";
                            }
                            element.css(set[i], val);
                        }
                    }
                },
                setMode: function(el, mode) {
                    if (mode === "toggle") {
                        mode = el.is(":hidden") ? "show" : "hide";
                    }
                    return mode;
                },
                // Translates a [top,left] array into a baseline value
                // this should be a little more flexible in the future to handle a string & hash
                getBaseline: function(origin, original) {
                    var y, x;
                    switch (origin[0]) {
                      case "top":
                        y = 0;
                        break;

                      case "middle":
                        y = .5;
                        break;

                      case "bottom":
                        y = 1;
                        break;

                      default:
                        y = origin[0] / original.height;
                    }
                    switch (origin[1]) {
                      case "left":
                        x = 0;
                        break;

                      case "center":
                        x = .5;
                        break;

                      case "right":
                        x = 1;
                        break;

                      default:
                        x = origin[1] / original.width;
                    }
                    return {
                        x: x,
                        y: y
                    };
                },
                // Wraps the element around a wrapper that copies position properties
                createWrapper: function(element) {
                    // if the element is already wrapped, return it
                    if (element.parent().is(".ui-effects-wrapper")) {
                        return element.parent();
                    }
                    // wrap the element
                    var props = {
                        width: element.outerWidth(true),
                        height: element.outerHeight(true),
                        "float": element.css("float")
                    }, wrapper = $("<div></div>").addClass("ui-effects-wrapper").css({
                        fontSize: "100%",
                        background: "transparent",
                        border: "none",
                        margin: 0,
                        padding: 0
                    }), // Store the size in case width/height are defined in % - Fixes #5245
                    size = {
                        width: element.width(),
                        height: element.height()
                    }, active = document.activeElement;
                    // support: Firefox
                    // Firefox incorrectly exposes anonymous content
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=561664
                    try {
                        active.id;
                    } catch (e) {
                        active = document.body;
                    }
                    element.wrap(wrapper);
                    // Fixes #7595 - Elements lose focus when wrapped.
                    if (element[0] === active || $.contains(element[0], active)) {
                        $(active).focus();
                    }
                    wrapper = element.parent();
                    //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element
                    // transfer positioning properties to the wrapper
                    if (element.css("position") === "static") {
                        wrapper.css({
                            position: "relative"
                        });
                        element.css({
                            position: "relative"
                        });
                    } else {
                        $.extend(props, {
                            position: element.css("position"),
                            zIndex: element.css("z-index")
                        });
                        $.each([ "top", "left", "bottom", "right" ], function(i, pos) {
                            props[pos] = element.css(pos);
                            if (isNaN(parseInt(props[pos], 10))) {
                                props[pos] = "auto";
                            }
                        });
                        element.css({
                            position: "relative",
                            top: 0,
                            left: 0,
                            right: "auto",
                            bottom: "auto"
                        });
                    }
                    element.css(size);
                    return wrapper.css(props).show();
                },
                removeWrapper: function(element) {
                    var active = document.activeElement;
                    if (element.parent().is(".ui-effects-wrapper")) {
                        element.parent().replaceWith(element);
                        // Fixes #7595 - Elements lose focus when wrapped.
                        if (element[0] === active || $.contains(element[0], active)) {
                            $(active).focus();
                        }
                    }
                    return element;
                },
                setTransition: function(element, list, factor, value) {
                    value = value || {};
                    $.each(list, function(i, x) {
                        var unit = element.cssUnit(x);
                        if (unit[0] > 0) {
                            value[x] = unit[0] * factor + unit[1];
                        }
                    });
                    return value;
                }
            });
            // return an effect options object for the given parameters:
            function _normalizeArguments(effect, options, speed, callback) {
                // allow passing all options as the first parameter
                if ($.isPlainObject(effect)) {
                    options = effect;
                    effect = effect.effect;
                }
                // convert to an object
                effect = {
                    effect: effect
                };
                // catch (effect, null, ...)
                if (options == null) {
                    options = {};
                }
                // catch (effect, callback)
                if ($.isFunction(options)) {
                    callback = options;
                    speed = null;
                    options = {};
                }
                // catch (effect, speed, ?)
                if (typeof options === "number" || $.fx.speeds[options]) {
                    callback = speed;
                    speed = options;
                    options = {};
                }
                // catch (effect, options, callback)
                if ($.isFunction(speed)) {
                    callback = speed;
                    speed = null;
                }
                // add options to effect
                if (options) {
                    $.extend(effect, options);
                }
                speed = speed || options.duration;
                effect.duration = $.fx.off ? 0 : typeof speed === "number" ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;
                effect.complete = callback || options.complete;
                return effect;
            }
            function standardAnimationOption(option) {
                // Valid standard speeds (nothing, number, named speed)
                if (!option || typeof option === "number" || $.fx.speeds[option]) {
                    return true;
                }
                // Invalid strings - treat as "normal" speed
                if (typeof option === "string" && !$.effects.effect[option]) {
                    return true;
                }
                // Complete callback
                if ($.isFunction(option)) {
                    return true;
                }
                // Options hash (but not naming an effect)
                if (typeof option === "object" && !option.effect) {
                    return true;
                }
                // Didn't match any standard API
                return false;
            }
            $.fn.extend({
                effect: function() {
                    var args = _normalizeArguments.apply(this, arguments), mode = args.mode, queue = args.queue, effectMethod = $.effects.effect[args.effect];
                    if ($.fx.off || !effectMethod) {
                        // delegate to the original method (e.g., .show()) if possible
                        if (mode) {
                            return this[mode](args.duration, args.complete);
                        } else {
                            return this.each(function() {
                                if (args.complete) {
                                    args.complete.call(this);
                                }
                            });
                        }
                    }
                    function run(next) {
                        var elem = $(this), complete = args.complete, mode = args.mode;
                        function done() {
                            if ($.isFunction(complete)) {
                                complete.call(elem[0]);
                            }
                            if ($.isFunction(next)) {
                                next();
                            }
                        }
                        // If the element already has the correct final state, delegate to
                        // the core methods so the internal tracking of "olddisplay" works.
                        if (elem.is(":hidden") ? mode === "hide" : mode === "show") {
                            elem[mode]();
                            done();
                        } else {
                            effectMethod.call(elem[0], args, done);
                        }
                    }
                    return queue === false ? this.each(run) : this.queue(queue || "fx", run);
                },
                show: function(orig) {
                    return function(option) {
                        if (standardAnimationOption(option)) {
                            return orig.apply(this, arguments);
                        } else {
                            var args = _normalizeArguments.apply(this, arguments);
                            args.mode = "show";
                            return this.effect.call(this, args);
                        }
                    };
                }($.fn.show),
                hide: function(orig) {
                    return function(option) {
                        if (standardAnimationOption(option)) {
                            return orig.apply(this, arguments);
                        } else {
                            var args = _normalizeArguments.apply(this, arguments);
                            args.mode = "hide";
                            return this.effect.call(this, args);
                        }
                    };
                }($.fn.hide),
                toggle: function(orig) {
                    return function(option) {
                        if (standardAnimationOption(option) || typeof option === "boolean") {
                            return orig.apply(this, arguments);
                        } else {
                            var args = _normalizeArguments.apply(this, arguments);
                            args.mode = "toggle";
                            return this.effect.call(this, args);
                        }
                    };
                }($.fn.toggle),
                // helper functions
                cssUnit: function(key) {
                    var style = this.css(key), val = [];
                    $.each([ "em", "px", "%", "pt" ], function(i, unit) {
                        if (style.indexOf(unit) > 0) {
                            val = [ parseFloat(style), unit ];
                        }
                    });
                    return val;
                }
            });
        })();
        /******************************************************************************/
        /*********************************** EASING ***********************************/
        /******************************************************************************/
        (function() {
            // based on easing equations from Robert Penner (http://www.robertpenner.com/easing)
            var baseEasings = {};
            $.each([ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function(i, name) {
                baseEasings[name] = function(p) {
                    return Math.pow(p, i + 2);
                };
            });
            $.extend(baseEasings, {
                Sine: function(p) {
                    return 1 - Math.cos(p * Math.PI / 2);
                },
                Circ: function(p) {
                    return 1 - Math.sqrt(1 - p * p);
                },
                Elastic: function(p) {
                    return p === 0 || p === 1 ? p : -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);
                },
                Back: function(p) {
                    return p * p * (3 * p - 2);
                },
                Bounce: function(p) {
                    var pow2, bounce = 4;
                    while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {}
                    return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);
                }
            });
            $.each(baseEasings, function(name, easeIn) {
                $.easing["easeIn" + name] = easeIn;
                $.easing["easeOut" + name] = function(p) {
                    return 1 - easeIn(1 - p);
                };
                $.easing["easeInOut" + name] = function(p) {
                    return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn(p * -2 + 2) / 2;
                };
            });
        })();
    })(jQuery);
    (function($, undefined) {
        var uid = 0, hideProps = {}, showProps = {};
        hideProps.height = hideProps.paddingTop = hideProps.paddingBottom = hideProps.borderTopWidth = hideProps.borderBottomWidth = "hide";
        showProps.height = showProps.paddingTop = showProps.paddingBottom = showProps.borderTopWidth = showProps.borderBottomWidth = "show";
        $.widget("ui.accordion", {
            version: "1.10.3",
            options: {
                active: 0,
                animate: {},
                collapsible: false,
                event: "click",
                header: "> li > :first-child,> :not(li):even",
                heightStyle: "auto",
                icons: {
                    activeHeader: "ui-icon-triangle-1-s",
                    header: "ui-icon-triangle-1-e"
                },
                // callbacks
                activate: null,
                beforeActivate: null
            },
            _create: function() {
                var options = this.options;
                this.prevShow = this.prevHide = $();
                this.element.addClass("ui-accordion ui-widget ui-helper-reset").attr("role", "tablist");
                // don't allow collapsible: false and active: false / null
                if (!options.collapsible && (options.active === false || options.active == null)) {
                    options.active = 0;
                }
                this._processPanels();
                // handle negative values
                if (options.active < 0) {
                    options.active += this.headers.length;
                }
                this._refresh();
            },
            _getCreateEventData: function() {
                return {
                    header: this.active,
                    panel: !this.active.length ? $() : this.active.next(),
                    content: !this.active.length ? $() : this.active.next()
                };
            },
            _createIcons: function() {
                var icons = this.options.icons;
                if (icons) {
                    $("<span>").addClass("ui-accordion-header-icon ui-icon " + icons.header).prependTo(this.headers);
                    this.active.children(".ui-accordion-header-icon").removeClass(icons.header).addClass(icons.activeHeader);
                    this.headers.addClass("ui-accordion-icons");
                }
            },
            _destroyIcons: function() {
                this.headers.removeClass("ui-accordion-icons").children(".ui-accordion-header-icon").remove();
            },
            _destroy: function() {
                var contents;
                // clean up main element
                this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role");
                // clean up headers
                this.headers.removeClass("ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-selected").removeAttr("aria-controls").removeAttr("tabIndex").each(function() {
                    if (/^ui-accordion/.test(this.id)) {
                        this.removeAttribute("id");
                    }
                });
                this._destroyIcons();
                // clean up content panels
                contents = this.headers.next().css("display", "").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-labelledby").removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled").each(function() {
                    if (/^ui-accordion/.test(this.id)) {
                        this.removeAttribute("id");
                    }
                });
                if (this.options.heightStyle !== "content") {
                    contents.css("height", "");
                }
            },
            _setOption: function(key, value) {
                if (key === "active") {
                    // _activate() will handle invalid values and update this.options
                    this._activate(value);
                    return;
                }
                if (key === "event") {
                    if (this.options.event) {
                        this._off(this.headers, this.options.event);
                    }
                    this._setupEvents(value);
                }
                this._super(key, value);
                // setting collapsible: false while collapsed; open first panel
                if (key === "collapsible" && !value && this.options.active === false) {
                    this._activate(0);
                }
                if (key === "icons") {
                    this._destroyIcons();
                    if (value) {
                        this._createIcons();
                    }
                }
                // #5332 - opacity doesn't cascade to positioned elements in IE
                // so we need to add the disabled class to the headers and panels
                if (key === "disabled") {
                    this.headers.add(this.headers.next()).toggleClass("ui-state-disabled", !!value);
                }
            },
            _keydown: function(event) {
                /*jshint maxcomplexity:15*/
                if (event.altKey || event.ctrlKey) {
                    return;
                }
                var keyCode = $.ui.keyCode, length = this.headers.length, currentIndex = this.headers.index(event.target), toFocus = false;
                switch (event.keyCode) {
                  case keyCode.RIGHT:
                  case keyCode.DOWN:
                    toFocus = this.headers[(currentIndex + 1) % length];
                    break;

                  case keyCode.LEFT:
                  case keyCode.UP:
                    toFocus = this.headers[(currentIndex - 1 + length) % length];
                    break;

                  case keyCode.SPACE:
                  case keyCode.ENTER:
                    this._eventHandler(event);
                    break;

                  case keyCode.HOME:
                    toFocus = this.headers[0];
                    break;

                  case keyCode.END:
                    toFocus = this.headers[length - 1];
                    break;
                }
                if (toFocus) {
                    $(event.target).attr("tabIndex", -1);
                    $(toFocus).attr("tabIndex", 0);
                    toFocus.focus();
                    event.preventDefault();
                }
            },
            _panelKeyDown: function(event) {
                if (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {
                    $(event.currentTarget).prev().focus();
                }
            },
            refresh: function() {
                var options = this.options;
                this._processPanels();
                // was collapsed or no panel
                if (options.active === false && options.collapsible === true || !this.headers.length) {
                    options.active = false;
                    this.active = $();
                } else if (options.active === false) {
                    this._activate(0);
                } else if (this.active.length && !$.contains(this.element[0], this.active[0])) {
                    // all remaining panel are disabled
                    if (this.headers.length === this.headers.find(".ui-state-disabled").length) {
                        options.active = false;
                        this.active = $();
                    } else {
                        this._activate(Math.max(0, options.active - 1));
                    }
                } else {
                    // make sure active index is correct
                    options.active = this.headers.index(this.active);
                }
                this._destroyIcons();
                this._refresh();
            },
            _processPanels: function() {
                this.headers = this.element.find(this.options.header).addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-all");
                this.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom").filter(":not(.ui-accordion-content-active)").hide();
            },
            _refresh: function() {
                var maxHeight, options = this.options, heightStyle = options.heightStyle, parent = this.element.parent(), accordionId = this.accordionId = "ui-accordion-" + (this.element.attr("id") || ++uid);
                this.active = this._findActive(options.active).addClass("ui-accordion-header-active ui-state-active ui-corner-top").removeClass("ui-corner-all");
                this.active.next().addClass("ui-accordion-content-active").show();
                this.headers.attr("role", "tab").each(function(i) {
                    var header = $(this), headerId = header.attr("id"), panel = header.next(), panelId = panel.attr("id");
                    if (!headerId) {
                        headerId = accordionId + "-header-" + i;
                        header.attr("id", headerId);
                    }
                    if (!panelId) {
                        panelId = accordionId + "-panel-" + i;
                        panel.attr("id", panelId);
                    }
                    header.attr("aria-controls", panelId);
                    panel.attr("aria-labelledby", headerId);
                }).next().attr("role", "tabpanel");
                this.headers.not(this.active).attr({
                    "aria-selected": "false",
                    tabIndex: -1
                }).next().attr({
                    "aria-expanded": "false",
                    "aria-hidden": "true"
                }).hide();
                // make sure at least one header is in the tab order
                if (!this.active.length) {
                    this.headers.eq(0).attr("tabIndex", 0);
                } else {
                    this.active.attr({
                        "aria-selected": "true",
                        tabIndex: 0
                    }).next().attr({
                        "aria-expanded": "true",
                        "aria-hidden": "false"
                    });
                }
                this._createIcons();
                this._setupEvents(options.event);
                if (heightStyle === "fill") {
                    maxHeight = parent.height();
                    this.element.siblings(":visible").each(function() {
                        var elem = $(this), position = elem.css("position");
                        if (position === "absolute" || position === "fixed") {
                            return;
                        }
                        maxHeight -= elem.outerHeight(true);
                    });
                    this.headers.each(function() {
                        maxHeight -= $(this).outerHeight(true);
                    });
                    this.headers.next().each(function() {
                        $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
                    }).css("overflow", "auto");
                } else if (heightStyle === "auto") {
                    maxHeight = 0;
                    this.headers.next().each(function() {
                        maxHeight = Math.max(maxHeight, $(this).css("height", "").height());
                    }).height(maxHeight);
                }
            },
            _activate: function(index) {
                var active = this._findActive(index)[0];
                // trying to activate the already active panel
                if (active === this.active[0]) {
                    return;
                }
                // trying to collapse, simulate a click on the currently active header
                active = active || this.active[0];
                this._eventHandler({
                    target: active,
                    currentTarget: active,
                    preventDefault: $.noop
                });
            },
            _findActive: function(selector) {
                return typeof selector === "number" ? this.headers.eq(selector) : $();
            },
            _setupEvents: function(event) {
                var events = {
                    keydown: "_keydown"
                };
                if (event) {
                    $.each(event.split(" "), function(index, eventName) {
                        events[eventName] = "_eventHandler";
                    });
                }
                this._off(this.headers.add(this.headers.next()));
                this._on(this.headers, events);
                this._on(this.headers.next(), {
                    keydown: "_panelKeyDown"
                });
                this._hoverable(this.headers);
                this._focusable(this.headers);
            },
            _eventHandler: function(event) {
                var options = this.options, active = this.active, clicked = $(event.currentTarget), clickedIsActive = clicked[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : clicked.next(), toHide = active.next(), eventData = {
                    oldHeader: active,
                    oldPanel: toHide,
                    newHeader: collapsing ? $() : clicked,
                    newPanel: toShow
                };
                event.preventDefault();
                if (// click on active header, but not collapsible
                clickedIsActive && !options.collapsible || // allow canceling activation
                this._trigger("beforeActivate", event, eventData) === false) {
                    return;
                }
                options.active = collapsing ? false : this.headers.index(clicked);
                // when the call to ._toggle() comes after the class changes
                // it causes a very odd bug in IE 8 (see #6720)
                this.active = clickedIsActive ? $() : clicked;
                this._toggle(eventData);
                // switch classes
                // corner classes on the previously active header stay after the animation
                active.removeClass("ui-accordion-header-active ui-state-active");
                if (options.icons) {
                    active.children(".ui-accordion-header-icon").removeClass(options.icons.activeHeader).addClass(options.icons.header);
                }
                if (!clickedIsActive) {
                    clicked.removeClass("ui-corner-all").addClass("ui-accordion-header-active ui-state-active ui-corner-top");
                    if (options.icons) {
                        clicked.children(".ui-accordion-header-icon").removeClass(options.icons.header).addClass(options.icons.activeHeader);
                    }
                    clicked.next().addClass("ui-accordion-content-active");
                }
            },
            _toggle: function(data) {
                var toShow = data.newPanel, toHide = this.prevShow.length ? this.prevShow : data.oldPanel;
                // handle activating a panel during the animation for another activation
                this.prevShow.add(this.prevHide).stop(true, true);
                this.prevShow = toShow;
                this.prevHide = toHide;
                if (this.options.animate) {
                    this._animate(toShow, toHide, data);
                } else {
                    toHide.hide();
                    toShow.show();
                    this._toggleComplete(data);
                }
                toHide.attr({
                    "aria-expanded": "false",
                    "aria-hidden": "true"
                });
                toHide.prev().attr("aria-selected", "false");
                // if we're switching panels, remove the old header from the tab order
                // if we're opening from collapsed state, remove the previous header from the tab order
                // if we're collapsing, then keep the collapsing header in the tab order
                if (toShow.length && toHide.length) {
                    toHide.prev().attr("tabIndex", -1);
                } else if (toShow.length) {
                    this.headers.filter(function() {
                        return $(this).attr("tabIndex") === 0;
                    }).attr("tabIndex", -1);
                }
                toShow.attr({
                    "aria-expanded": "true",
                    "aria-hidden": "false"
                }).prev().attr({
                    "aria-selected": "true",
                    tabIndex: 0
                });
            },
            _animate: function(toShow, toHide, data) {
                var total, easing, duration, that = this, adjust = 0, down = toShow.length && (!toHide.length || toShow.index() < toHide.index()), animate = this.options.animate || {}, options = down && animate.down || animate, complete = function() {
                    that._toggleComplete(data);
                };
                if (typeof options === "number") {
                    duration = options;
                }
                if (typeof options === "string") {
                    easing = options;
                }
                // fall back from options to animation in case of partial down settings
                easing = easing || options.easing || animate.easing;
                duration = duration || options.duration || animate.duration;
                if (!toHide.length) {
                    return toShow.animate(showProps, duration, easing, complete);
                }
                if (!toShow.length) {
                    return toHide.animate(hideProps, duration, easing, complete);
                }
                total = toShow.show().outerHeight();
                toHide.animate(hideProps, {
                    duration: duration,
                    easing: easing,
                    step: function(now, fx) {
                        fx.now = Math.round(now);
                    }
                });
                toShow.hide().animate(showProps, {
                    duration: duration,
                    easing: easing,
                    complete: complete,
                    step: function(now, fx) {
                        fx.now = Math.round(now);
                        if (fx.prop !== "height") {
                            adjust += fx.now;
                        } else if (that.options.heightStyle !== "content") {
                            fx.now = Math.round(total - toHide.outerHeight() - adjust);
                            adjust = 0;
                        }
                    }
                });
            },
            _toggleComplete: function(data) {
                var toHide = data.oldPanel;
                toHide.removeClass("ui-accordion-content-active").prev().removeClass("ui-corner-top").addClass("ui-corner-all");
                // Work around for rendering bug in IE (#5421)
                if (toHide.length) {
                    toHide.parent()[0].className = toHide.parent()[0].className;
                }
                this._trigger("activate", null, data);
            }
        });
    })(jQuery);
    (function($, undefined) {
        // used to prevent race conditions with remote data sources
        var requestIndex = 0;
        $.widget("ui.autocomplete", {
            version: "1.10.3",
            defaultElement: "<input>",
            options: {
                appendTo: null,
                autoFocus: false,
                delay: 300,
                minLength: 1,
                position: {
                    my: "left top",
                    at: "left bottom",
                    collision: "none"
                },
                source: null,
                // callbacks
                change: null,
                close: null,
                focus: null,
                open: null,
                response: null,
                search: null,
                select: null
            },
            pending: 0,
            _create: function() {
                // Some browsers only repeat keydown events, not keypress events,
                // so we use the suppressKeyPress flag to determine if we've already
                // handled the keydown event. #7269
                // Unfortunately the code for & in keypress is the same as the up arrow,
                // so we use the suppressKeyPressRepeat flag to avoid handling keypress
                // events when we know the keydown event was used to modify the
                // search term. #7799
                var suppressKeyPress, suppressKeyPressRepeat, suppressInput, nodeName = this.element[0].nodeName.toLowerCase(), isTextarea = nodeName === "textarea", isInput = nodeName === "input";
                this.isMultiLine = // Textareas are always multi-line
                isTextarea ? true : // Inputs are always single-line, even if inside a contentEditable element
                // IE also treats inputs as contentEditable
                isInput ? false : // All other element types are determined by whether or not they're contentEditable
                this.element.prop("isContentEditable");
                this.valueMethod = this.element[isTextarea || isInput ? "val" : "text"];
                this.isNewMenu = true;
                this.element.addClass("ui-autocomplete-input").attr("autocomplete", "off");
                this._on(this.element, {
                    keydown: function(event) {
                        /*jshint maxcomplexity:15*/
                        if (this.element.prop("readOnly")) {
                            suppressKeyPress = true;
                            suppressInput = true;
                            suppressKeyPressRepeat = true;
                            return;
                        }
                        suppressKeyPress = false;
                        suppressInput = false;
                        suppressKeyPressRepeat = false;
                        var keyCode = $.ui.keyCode;
                        switch (event.keyCode) {
                          case keyCode.PAGE_UP:
                            suppressKeyPress = true;
                            this._move("previousPage", event);
                            break;

                          case keyCode.PAGE_DOWN:
                            suppressKeyPress = true;
                            this._move("nextPage", event);
                            break;

                          case keyCode.UP:
                            suppressKeyPress = true;
                            this._keyEvent("previous", event);
                            break;

                          case keyCode.DOWN:
                            suppressKeyPress = true;
                            this._keyEvent("next", event);
                            break;

                          case keyCode.ENTER:
                          case keyCode.NUMPAD_ENTER:
                            // when menu is open and has focus
                            if (this.menu.active) {
                                // #6055 - Opera still allows the keypress to occur
                                // which causes forms to submit
                                suppressKeyPress = true;
                                event.preventDefault();
                                this.menu.select(event);
                            }
                            break;

                          case keyCode.TAB:
                            if (this.menu.active) {
                                this.menu.select(event);
                            }
                            break;

                          case keyCode.ESCAPE:
                            if (this.menu.element.is(":visible")) {
                                this._value(this.term);
                                this.close(event);
                                // Different browsers have different default behavior for escape
                                // Single press can mean undo or clear
                                // Double press in IE means clear the whole form
                                event.preventDefault();
                            }
                            break;

                          default:
                            suppressKeyPressRepeat = true;
                            // search timeout should be triggered before the input value is changed
                            this._searchTimeout(event);
                            break;
                        }
                    },
                    keypress: function(event) {
                        if (suppressKeyPress) {
                            suppressKeyPress = false;
                            if (!this.isMultiLine || this.menu.element.is(":visible")) {
                                event.preventDefault();
                            }
                            return;
                        }
                        if (suppressKeyPressRepeat) {
                            return;
                        }
                        // replicate some key handlers to allow them to repeat in Firefox and Opera
                        var keyCode = $.ui.keyCode;
                        switch (event.keyCode) {
                          case keyCode.PAGE_UP:
                            this._move("previousPage", event);
                            break;

                          case keyCode.PAGE_DOWN:
                            this._move("nextPage", event);
                            break;

                          case keyCode.UP:
                            this._keyEvent("previous", event);
                            break;

                          case keyCode.DOWN:
                            this._keyEvent("next", event);
                            break;
                        }
                    },
                    input: function(event) {
                        if (suppressInput) {
                            suppressInput = false;
                            event.preventDefault();
                            return;
                        }
                        this._searchTimeout(event);
                    },
                    focus: function() {
                        this.selectedItem = null;
                        this.previous = this._value();
                    },
                    blur: function(event) {
                        if (this.cancelBlur) {
                            delete this.cancelBlur;
                            return;
                        }
                        clearTimeout(this.searching);
                        this.close(event);
                        this._change(event);
                    }
                });
                this._initSource();
                this.menu = $("<ul>").addClass("ui-autocomplete ui-front").appendTo(this._appendTo()).menu({
                    // disable ARIA support, the live region takes care of that
                    role: null
                }).hide().data("ui-menu");
                this._on(this.menu.element, {
                    mousedown: function(event) {
                        // prevent moving focus out of the text field
                        event.preventDefault();
                        // IE doesn't prevent moving focus even with event.preventDefault()
                        // so we set a flag to know when we should ignore the blur event
                        this.cancelBlur = true;
                        this._delay(function() {
                            delete this.cancelBlur;
                        });
                        // clicking on the scrollbar causes focus to shift to the body
                        // but we can't detect a mouseup or a click immediately afterward
                        // so we have to track the next mousedown and close the menu if
                        // the user clicks somewhere outside of the autocomplete
                        var menuElement = this.menu.element[0];
                        if (!$(event.target).closest(".ui-menu-item").length) {
                            this._delay(function() {
                                var that = this;
                                this.document.one("mousedown", function(event) {
                                    if (event.target !== that.element[0] && event.target !== menuElement && !$.contains(menuElement, event.target)) {
                                        that.close();
                                    }
                                });
                            });
                        }
                    },
                    menufocus: function(event, ui) {
                        // support: Firefox
                        // Prevent accidental activation of menu items in Firefox (#7024 #9118)
                        if (this.isNewMenu) {
                            this.isNewMenu = false;
                            if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
                                this.menu.blur();
                                this.document.one("mousemove", function() {
                                    $(event.target).trigger(event.originalEvent);
                                });
                                return;
                            }
                        }
                        var item = ui.item.data("ui-autocomplete-item");
                        if (false !== this._trigger("focus", event, {
                            item: item
                        })) {
                            // use value to match what will end up in the input, if it was a key event
                            if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
                                this._value(item.value);
                            }
                        } else {
                            // Normally the input is populated with the item's value as the
                            // menu is navigated, causing screen readers to notice a change and
                            // announce the item. Since the focus event was canceled, this doesn't
                            // happen, so we update the live region so that screen readers can
                            // still notice the change and announce it.
                            this.liveRegion.text(item.value);
                        }
                    },
                    menuselect: function(event, ui) {
                        var item = ui.item.data("ui-autocomplete-item"), previous = this.previous;
                        // only trigger when focus was lost (click on menu)
                        if (this.element[0] !== this.document[0].activeElement) {
                            this.element.focus();
                            this.previous = previous;
                            // #6109 - IE triggers two focus events and the second
                            // is asynchronous, so we need to reset the previous
                            // term synchronously and asynchronously :-(
                            this._delay(function() {
                                this.previous = previous;
                                this.selectedItem = item;
                            });
                        }
                        if (false !== this._trigger("select", event, {
                            item: item
                        })) {
                            this._value(item.value);
                        }
                        // reset the term after the select event
                        // this allows custom select handling to work properly
                        this.term = this._value();
                        this.close(event);
                        this.selectedItem = item;
                    }
                });
                this.liveRegion = $("<span>", {
                    role: "status",
                    "aria-live": "polite"
                }).addClass("ui-helper-hidden-accessible").insertBefore(this.element);
                // turning off autocomplete prevents the browser from remembering the
                // value when navigating through history, so we re-enable autocomplete
                // if the page is unloaded before the widget is destroyed. #7790
                this._on(this.window, {
                    beforeunload: function() {
                        this.element.removeAttr("autocomplete");
                    }
                });
            },
            _destroy: function() {
                clearTimeout(this.searching);
                this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete");
                this.menu.element.remove();
                this.liveRegion.remove();
            },
            _setOption: function(key, value) {
                this._super(key, value);
                if (key === "source") {
                    this._initSource();
                }
                if (key === "appendTo") {
                    this.menu.element.appendTo(this._appendTo());
                }
                if (key === "disabled" && value && this.xhr) {
                    this.xhr.abort();
                }
            },
            _appendTo: function() {
                var element = this.options.appendTo;
                if (element) {
                    element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);
                }
                if (!element) {
                    element = this.element.closest(".ui-front");
                }
                if (!element.length) {
                    element = this.document[0].body;
                }
                return element;
            },
            _initSource: function() {
                var array, url, that = this;
                if ($.isArray(this.options.source)) {
                    array = this.options.source;
                    this.source = function(request, response) {
                        response($.ui.autocomplete.filter(array, request.term));
                    };
                } else if (typeof this.options.source === "string") {
                    url = this.options.source;
                    this.source = function(request, response) {
                        if (that.xhr) {
                            that.xhr.abort();
                        }
                        that.xhr = $.ajax({
                            url: url,
                            data: request,
                            dataType: "json",
                            success: function(data) {
                                response(data);
                            },
                            error: function() {
                                response([]);
                            }
                        });
                    };
                } else {
                    this.source = this.options.source;
                }
            },
            _searchTimeout: function(event) {
                clearTimeout(this.searching);
                this.searching = this._delay(function() {
                    // only search if the value has changed
                    if (this.term !== this._value()) {
                        this.selectedItem = null;
                        this.search(null, event);
                    }
                }, this.options.delay);
            },
            search: function(value, event) {
                value = value != null ? value : this._value();
                // always save the actual value, not the one passed as an argument
                this.term = this._value();
                if (value.length < this.options.minLength) {
                    return this.close(event);
                }
                if (this._trigger("search", event) === false) {
                    return;
                }
                return this._search(value);
            },
            _search: function(value) {
                this.pending++;
                this.element.addClass("ui-autocomplete-loading");
                this.cancelSearch = false;
                this.source({
                    term: value
                }, this._response());
            },
            _response: function() {
                var that = this, index = ++requestIndex;
                return function(content) {
                    if (index === requestIndex) {
                        that.__response(content);
                    }
                    that.pending--;
                    if (!that.pending) {
                        that.element.removeClass("ui-autocomplete-loading");
                    }
                };
            },
            __response: function(content) {
                if (content) {
                    content = this._normalize(content);
                }
                this._trigger("response", null, {
                    content: content
                });
                if (!this.options.disabled && content && content.length && !this.cancelSearch) {
                    this._suggest(content);
                    this._trigger("open");
                } else {
                    // use ._close() instead of .close() so we don't cancel future searches
                    this._close();
                }
            },
            close: function(event) {
                this.cancelSearch = true;
                this._close(event);
            },
            _close: function(event) {
                if (this.menu.element.is(":visible")) {
                    this.menu.element.hide();
                    this.menu.blur();
                    this.isNewMenu = true;
                    this._trigger("close", event);
                }
            },
            _change: function(event) {
                if (this.previous !== this._value()) {
                    this._trigger("change", event, {
                        item: this.selectedItem
                    });
                }
            },
            _normalize: function(items) {
                // assume all items have the right format when the first item is complete
                if (items.length && items[0].label && items[0].value) {
                    return items;
                }
                return $.map(items, function(item) {
                    if (typeof item === "string") {
                        return {
                            label: item,
                            value: item
                        };
                    }
                    return $.extend({
                        label: item.label || item.value,
                        value: item.value || item.label
                    }, item);
                });
            },
            _suggest: function(items) {
                var ul = this.menu.element.empty();
                this._renderMenu(ul, items);
                this.isNewMenu = true;
                this.menu.refresh();
                // size and position menu
                ul.show();
                this._resizeMenu();
                ul.position($.extend({
                    of: this.element
                }, this.options.position));
                if (this.options.autoFocus) {
                    this.menu.next();
                }
            },
            _resizeMenu: function() {
                var ul = this.menu.element;
                ul.outerWidth(Math.max(// Firefox wraps long text (possibly a rounding bug)
                // so we add 1px to avoid the wrapping (#7513)
                ul.width("").outerWidth() + 1, this.element.outerWidth()));
            },
            _renderMenu: function(ul, items) {
                var that = this;
                $.each(items, function(index, item) {
                    that._renderItemData(ul, item);
                });
            },
            _renderItemData: function(ul, item) {
                return this._renderItem(ul, item).data("ui-autocomplete-item", item);
            },
            _renderItem: function(ul, item) {
                return $("<li>").append($("<a>").text(item.label)).appendTo(ul);
            },
            _move: function(direction, event) {
                if (!this.menu.element.is(":visible")) {
                    this.search(null, event);
                    return;
                }
                if (this.menu.isFirstItem() && /^previous/.test(direction) || this.menu.isLastItem() && /^next/.test(direction)) {
                    this._value(this.term);
                    this.menu.blur();
                    return;
                }
                this.menu[direction](event);
            },
            widget: function() {
                return this.menu.element;
            },
            _value: function() {
                return this.valueMethod.apply(this.element, arguments);
            },
            _keyEvent: function(keyEvent, event) {
                if (!this.isMultiLine || this.menu.element.is(":visible")) {
                    this._move(keyEvent, event);
                    // prevents moving cursor to beginning/end of the text field in some browsers
                    event.preventDefault();
                }
            }
        });
        $.extend($.ui.autocomplete, {
            escapeRegex: function(value) {
                return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
            },
            filter: function(array, term) {
                var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i");
                return $.grep(array, function(value) {
                    return matcher.test(value.label || value.value || value);
                });
            }
        });
        // live region extension, adding a `messages` option
        // NOTE: This is an experimental API. We are still investigating
        // a full solution for string manipulation and internationalization.
        $.widget("ui.autocomplete", $.ui.autocomplete, {
            options: {
                messages: {
                    noResults: "No search results.",
                    results: function(amount) {
                        return amount + (amount > 1 ? " results are" : " result is") + " available, use up and down arrow keys to navigate.";
                    }
                }
            },
            __response: function(content) {
                var message;
                this._superApply(arguments);
                if (this.options.disabled || this.cancelSearch) {
                    return;
                }
                if (content && content.length) {
                    message = this.options.messages.results(content.length);
                } else {
                    message = this.options.messages.noResults;
                }
                this.liveRegion.text(message);
            }
        });
    })(jQuery);
    (function($, undefined) {
        var lastActive, startXPos, startYPos, clickDragged, baseClasses = "ui-button ui-widget ui-state-default ui-corner-all", stateClasses = "ui-state-hover ui-state-active ", typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only", formResetHandler = function() {
            var form = $(this);
            setTimeout(function() {
                form.find(":ui-button").button("refresh");
            }, 1);
        }, radioGroup = function(radio) {
            var name = radio.name, form = radio.form, radios = $([]);
            if (name) {
                name = name.replace(/'/g, "\\'");
                if (form) {
                    radios = $(form).find("[name='" + name + "']");
                } else {
                    radios = $("[name='" + name + "']", radio.ownerDocument).filter(function() {
                        return !this.form;
                    });
                }
            }
            return radios;
        };
        $.widget("ui.button", {
            version: "1.10.3",
            defaultElement: "<button>",
            options: {
                disabled: null,
                text: true,
                label: null,
                icons: {
                    primary: null,
                    secondary: null
                }
            },
            _create: function() {
                this.element.closest("form").unbind("reset" + this.eventNamespace).bind("reset" + this.eventNamespace, formResetHandler);
                if (typeof this.options.disabled !== "boolean") {
                    this.options.disabled = !!this.element.prop("disabled");
                } else {
                    this.element.prop("disabled", this.options.disabled);
                }
                this._determineButtonType();
                this.hasTitle = !!this.buttonElement.attr("title");
                var that = this, options = this.options, toggleButton = this.type === "checkbox" || this.type === "radio", activeClass = !toggleButton ? "ui-state-active" : "", focusClass = "ui-state-focus";
                if (options.label === null) {
                    options.label = this.type === "input" ? this.buttonElement.val() : this.buttonElement.html();
                }
                this._hoverable(this.buttonElement);
                this.buttonElement.addClass(baseClasses).attr("role", "button").bind("mouseenter" + this.eventNamespace, function() {
                    if (options.disabled) {
                        return;
                    }
                    if (this === lastActive) {
                        $(this).addClass("ui-state-active");
                    }
                }).bind("mouseleave" + this.eventNamespace, function() {
                    if (options.disabled) {
                        return;
                    }
                    $(this).removeClass(activeClass);
                }).bind("click" + this.eventNamespace, function(event) {
                    if (options.disabled) {
                        event.preventDefault();
                        event.stopImmediatePropagation();
                    }
                });
                this.element.bind("focus" + this.eventNamespace, function() {
                    // no need to check disabled, focus won't be triggered anyway
                    that.buttonElement.addClass(focusClass);
                }).bind("blur" + this.eventNamespace, function() {
                    that.buttonElement.removeClass(focusClass);
                });
                if (toggleButton) {
                    this.element.bind("change" + this.eventNamespace, function() {
                        if (clickDragged) {
                            return;
                        }
                        that.refresh();
                    });
                    // if mouse moves between mousedown and mouseup (drag) set clickDragged flag
                    // prevents issue where button state changes but checkbox/radio checked state
                    // does not in Firefox (see ticket #6970)
                    this.buttonElement.bind("mousedown" + this.eventNamespace, function(event) {
                        if (options.disabled) {
                            return;
                        }
                        clickDragged = false;
                        startXPos = event.pageX;
                        startYPos = event.pageY;
                    }).bind("mouseup" + this.eventNamespace, function(event) {
                        if (options.disabled) {
                            return;
                        }
                        if (startXPos !== event.pageX || startYPos !== event.pageY) {
                            clickDragged = true;
                        }
                    });
                }
                if (this.type === "checkbox") {
                    this.buttonElement.bind("click" + this.eventNamespace, function() {
                        if (options.disabled || clickDragged) {
                            return false;
                        }
                    });
                } else if (this.type === "radio") {
                    this.buttonElement.bind("click" + this.eventNamespace, function() {
                        if (options.disabled || clickDragged) {
                            return false;
                        }
                        $(this).addClass("ui-state-active");
                        that.buttonElement.attr("aria-pressed", "true");
                        var radio = that.element[0];
                        radioGroup(radio).not(radio).map(function() {
                            return $(this).button("widget")[0];
                        }).removeClass("ui-state-active").attr("aria-pressed", "false");
                    });
                } else {
                    this.buttonElement.bind("mousedown" + this.eventNamespace, function() {
                        if (options.disabled) {
                            return false;
                        }
                        $(this).addClass("ui-state-active");
                        lastActive = this;
                        that.document.one("mouseup", function() {
                            lastActive = null;
                        });
                    }).bind("mouseup" + this.eventNamespace, function() {
                        if (options.disabled) {
                            return false;
                        }
                        $(this).removeClass("ui-state-active");
                    }).bind("keydown" + this.eventNamespace, function(event) {
                        if (options.disabled) {
                            return false;
                        }
                        if (event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) {
                            $(this).addClass("ui-state-active");
                        }
                    }).bind("keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
                        $(this).removeClass("ui-state-active");
                    });
                    if (this.buttonElement.is("a")) {
                        this.buttonElement.keyup(function(event) {
                            if (event.keyCode === $.ui.keyCode.SPACE) {
                                // TODO pass through original event correctly (just as 2nd argument doesn't work)
                                $(this).click();
                            }
                        });
                    }
                }
                // TODO: pull out $.Widget's handling for the disabled option into
                // $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
                // be overridden by individual plugins
                this._setOption("disabled", options.disabled);
                this._resetButton();
            },
            _determineButtonType: function() {
                var ancestor, labelSelector, checked;
                if (this.element.is("[type=checkbox]")) {
                    this.type = "checkbox";
                } else if (this.element.is("[type=radio]")) {
                    this.type = "radio";
                } else if (this.element.is("input")) {
                    this.type = "input";
                } else {
                    this.type = "button";
                }
                if (this.type === "checkbox" || this.type === "radio") {
                    // we don't search against the document in case the element
                    // is disconnected from the DOM
                    ancestor = this.element.parents().last();
                    labelSelector = "label[for='" + this.element.attr("id") + "']";
                    this.buttonElement = ancestor.find(labelSelector);
                    if (!this.buttonElement.length) {
                        ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
                        this.buttonElement = ancestor.filter(labelSelector);
                        if (!this.buttonElement.length) {
                            this.buttonElement = ancestor.find(labelSelector);
                        }
                    }
                    this.element.addClass("ui-helper-hidden-accessible");
                    checked = this.element.is(":checked");
                    if (checked) {
                        this.buttonElement.addClass("ui-state-active");
                    }
                    this.buttonElement.prop("aria-pressed", checked);
                } else {
                    this.buttonElement = this.element;
                }
            },
            widget: function() {
                return this.buttonElement;
            },
            _destroy: function() {
                this.element.removeClass("ui-helper-hidden-accessible");
                this.buttonElement.removeClass(baseClasses + " " + stateClasses + " " + typeClasses).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html());
                if (!this.hasTitle) {
                    this.buttonElement.removeAttr("title");
                }
            },
            _setOption: function(key, value) {
                this._super(key, value);
                if (key === "disabled") {
                    if (value) {
                        this.element.prop("disabled", true);
                    } else {
                        this.element.prop("disabled", false);
                    }
                    return;
                }
                this._resetButton();
            },
            refresh: function() {
                //See #8237 & #8828
                var isDisabled = this.element.is("input, button") ? this.element.is(":disabled") : this.element.hasClass("ui-button-disabled");
                if (isDisabled !== this.options.disabled) {
                    this._setOption("disabled", isDisabled);
                }
                if (this.type === "radio") {
                    radioGroup(this.element[0]).each(function() {
                        if ($(this).is(":checked")) {
                            $(this).button("widget").addClass("ui-state-active").attr("aria-pressed", "true");
                        } else {
                            $(this).button("widget").removeClass("ui-state-active").attr("aria-pressed", "false");
                        }
                    });
                } else if (this.type === "checkbox") {
                    if (this.element.is(":checked")) {
                        this.buttonElement.addClass("ui-state-active").attr("aria-pressed", "true");
                    } else {
                        this.buttonElement.removeClass("ui-state-active").attr("aria-pressed", "false");
                    }
                }
            },
            _resetButton: function() {
                if (this.type === "input") {
                    if (this.options.label) {
                        this.element.val(this.options.label);
                    }
                    return;
                }
                var buttonElement = this.buttonElement.removeClass(typeClasses), buttonText = $("<span></span>", this.document[0]).addClass("ui-button-text").html(this.options.label).appendTo(buttonElement.empty()).text(), icons = this.options.icons, multipleIcons = icons.primary && icons.secondary, buttonClasses = [];
                if (icons.primary || icons.secondary) {
                    if (this.options.text) {
                        buttonClasses.push("ui-button-text-icon" + (multipleIcons ? "s" : icons.primary ? "-primary" : "-secondary"));
                    }
                    if (icons.primary) {
                        buttonElement.prepend("<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>");
                    }
                    if (icons.secondary) {
                        buttonElement.append("<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>");
                    }
                    if (!this.options.text) {
                        buttonClasses.push(multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only");
                        if (!this.hasTitle) {
                            buttonElement.attr("title", $.trim(buttonText));
                        }
                    }
                } else {
                    buttonClasses.push("ui-button-text-only");
                }
                buttonElement.addClass(buttonClasses.join(" "));
            }
        });
        $.widget("ui.buttonset", {
            version: "1.10.3",
            options: {
                items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
            },
            _create: function() {
                this.element.addClass("ui-buttonset");
            },
            _init: function() {
                this.refresh();
            },
            _setOption: function(key, value) {
                if (key === "disabled") {
                    this.buttons.button("option", key, value);
                }
                this._super(key, value);
            },
            refresh: function() {
                var rtl = this.element.css("direction") === "rtl";
                this.buttons = this.element.find(this.options.items).filter(":ui-button").button("refresh").end().not(":ui-button").button().end().map(function() {
                    return $(this).button("widget")[0];
                }).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(rtl ? "ui-corner-right" : "ui-corner-left").end().filter(":last").addClass(rtl ? "ui-corner-left" : "ui-corner-right").end().end();
            },
            _destroy: function() {
                this.element.removeClass("ui-buttonset");
                this.buttons.map(function() {
                    return $(this).button("widget")[0];
                }).removeClass("ui-corner-left ui-corner-right").end().button("destroy");
            }
        });
    })(jQuery);
    (function($, undefined) {
        $.extend($.ui, {
            datepicker: {
                version: "1.10.3"
            }
        });
        var PROP_NAME = "datepicker", instActive;
        /* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */
        function Datepicker() {
            this._curInst = null;
            // The current instance in use
            this._keyEvent = false;
            // If the last event was a key event
            this._disabledInputs = [];
            // List of date picker inputs that have been disabled
            this._datepickerShowing = false;
            // True if the popup picker is showing , false if not
            this._inDialog = false;
            // True if showing within a "dialog", false if not
            this._mainDivId = "ui-datepicker-div";
            // The ID of the main datepicker division
            this._inlineClass = "ui-datepicker-inline";
            // The name of the inline marker class
            this._appendClass = "ui-datepicker-append";
            // The name of the append marker class
            this._triggerClass = "ui-datepicker-trigger";
            // The name of the trigger marker class
            this._dialogClass = "ui-datepicker-dialog";
            // The name of the dialog marker class
            this._disableClass = "ui-datepicker-disabled";
            // The name of the disabled covering marker class
            this._unselectableClass = "ui-datepicker-unselectable";
            // The name of the unselectable cell marker class
            this._currentClass = "ui-datepicker-current-day";
            // The name of the current day marker class
            this._dayOverClass = "ui-datepicker-days-cell-over";
            // The name of the day hover marker class
            this.regional = [];
            // Available regional settings, indexed by language code
            this.regional[""] = {
                // Default regional settings
                closeText: "Done",
                // Display text for close link
                prevText: "Prev",
                // Display text for previous month link
                nextText: "Next",
                // Display text for next month link
                currentText: "Today",
                // Display text for current month link
                monthNames: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                // Names of months for drop-down and formatting
                monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
                // For formatting
                dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                // For formatting
                dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                // For formatting
                dayNamesMin: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ],
                // Column headings for days starting at Sunday
                weekHeader: "Wk",
                // Column header for week of the year
                dateFormat: "mm/dd/yy",
                // See format options on parseDate
                firstDay: 0,
                // The first day of the week, Sun = 0, Mon = 1, ...
                isRTL: false,
                // True if right-to-left language, false if left-to-right
                showMonthAfterYear: false,
                // True if the year select precedes month, false for month then year
                yearSuffix: ""
            };
            this._defaults = {
                // Global defaults for all the date picker instances
                showOn: "focus",
                // "focus" for popup on focus,
                // "button" for trigger button, or "both" for either
                showAnim: "fadeIn",
                // Name of jQuery animation for popup
                showOptions: {},
                // Options for enhanced animations
                defaultDate: null,
                // Used when field is blank: actual date,
                // +/-number for offset from today, null for today
                appendText: "",
                // Display text following the input box, e.g. showing the format
                buttonText: "...",
                // Text for trigger button
                buttonImage: "",
                // URL for trigger button image
                buttonImageOnly: false,
                // True if the image appears alone, false if it appears on a button
                hideIfNoPrevNext: false,
                // True to hide next/previous month links
                // if not applicable, false to just disable them
                navigationAsDateFormat: false,
                // True if date formatting applied to prev/today/next links
                gotoCurrent: false,
                // True if today link goes back to current selection instead
                changeMonth: false,
                // True if month can be selected directly, false if only prev/next
                changeYear: false,
                // True if year can be selected directly, false if only prev/next
                yearRange: "c-10:c+10",
                // Range of years to display in drop-down,
                // either relative to today's year (-nn:+nn), relative to currently displayed year
                // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
                showOtherMonths: false,
                // True to show dates in other months, false to leave blank
                selectOtherMonths: false,
                // True to allow selection of dates in other months, false for unselectable
                showWeek: false,
                // True to show week of the year, false to not show it
                calculateWeek: this.iso8601Week,
                // How to calculate the week of the year,
                // takes a Date and returns the number of the week for it
                shortYearCutoff: "+10",
                // Short year values < this are in the current century,
                // > this are in the previous century,
                // string value starting with "+" for current year + value
                minDate: null,
                // The earliest selectable date, or null for no limit
                maxDate: null,
                // The latest selectable date, or null for no limit
                duration: "fast",
                // Duration of display/closure
                beforeShowDay: null,
                // Function that takes a date and returns an array with
                // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
                // [2] = cell title (optional), e.g. $.datepicker.noWeekends
                beforeShow: null,
                // Function that takes an input field and
                // returns a set of custom settings for the date picker
                onSelect: null,
                // Define a callback function when a date is selected
                onChangeMonthYear: null,
                // Define a callback function when the month or year is changed
                onClose: null,
                // Define a callback function when the datepicker is closed
                numberOfMonths: 1,
                // Number of months to show at a time
                showCurrentAtPos: 0,
                // The position in multipe months at which to show the current month (starting at 0)
                stepMonths: 1,
                // Number of months to step back/forward
                stepBigMonths: 12,
                // Number of months to step back/forward for the big links
                altField: "",
                // Selector for an alternate field to store selected dates into
                altFormat: "",
                // The date format to use for the alternate field
                constrainInput: true,
                // The input is constrained by the current date format
                showButtonPanel: false,
                // True to show button panel, false to not show it
                autoSize: false,
                // True to size the input for the date format, false to leave as is
                disabled: false
            };
            $.extend(this._defaults, this.regional[""]);
            this.dpDiv = bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
        }
        $.extend(Datepicker.prototype, {
            /* Class name added to elements to indicate already configured with a date picker. */
            markerClassName: "hasDatepicker",
            //Keep track of the maximum number of rows displayed (see #7043)
            maxRows: 4,
            // TODO rename to "widget" when switching to widget factory
            _widgetDatepicker: function() {
                return this.dpDiv;
            },
            /* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
            setDefaults: function(settings) {
                extendRemove(this._defaults, settings || {});
                return this;
            },
            /* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
            _attachDatepicker: function(target, settings) {
                var nodeName, inline, inst;
                nodeName = target.nodeName.toLowerCase();
                inline = nodeName === "div" || nodeName === "span";
                if (!target.id) {
                    this.uuid += 1;
                    target.id = "dp" + this.uuid;
                }
                inst = this._newInst($(target), inline);
                inst.settings = $.extend({}, settings || {});
                if (nodeName === "input") {
                    this._connectDatepicker(target, inst);
                } else if (inline) {
                    this._inlineDatepicker(target, inst);
                }
            },
            /* Create a new instance object. */
            _newInst: function(target, inline) {
                var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1");
                // escape jQuery meta chars
                return {
                    id: id,
                    input: target,
                    // associated target
                    selectedDay: 0,
                    selectedMonth: 0,
                    selectedYear: 0,
                    // current selection
                    drawMonth: 0,
                    drawYear: 0,
                    // month being drawn
                    inline: inline,
                    // is datepicker inline or not
                    dpDiv: !inline ? this.dpDiv : // presentation div
                    bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))
                };
            },
            /* Attach the date picker to an input field. */
            _connectDatepicker: function(target, inst) {
                var input = $(target);
                inst.append = $([]);
                inst.trigger = $([]);
                if (input.hasClass(this.markerClassName)) {
                    return;
                }
                this._attachments(input, inst);
                input.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp);
                this._autoSize(inst);
                $.data(target, PROP_NAME, inst);
                //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
                if (inst.settings.disabled) {
                    this._disableDatepicker(target);
                }
            },
            /* Make attachments based on settings. */
            _attachments: function(input, inst) {
                var showOn, buttonText, buttonImage, appendText = this._get(inst, "appendText"), isRTL = this._get(inst, "isRTL");
                if (inst.append) {
                    inst.append.remove();
                }
                if (appendText) {
                    inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
                    input[isRTL ? "before" : "after"](inst.append);
                }
                input.unbind("focus", this._showDatepicker);
                if (inst.trigger) {
                    inst.trigger.remove();
                }
                showOn = this._get(inst, "showOn");
                if (showOn === "focus" || showOn === "both") {
                    // pop-up date picker when in the marked field
                    input.focus(this._showDatepicker);
                }
                if (showOn === "button" || showOn === "both") {
                    // pop-up date picker when button clicked
                    buttonText = this._get(inst, "buttonText");
                    buttonImage = this._get(inst, "buttonImage");
                    inst.trigger = $(this._get(inst, "buttonImageOnly") ? $("<img/>").addClass(this._triggerClass).attr({
                        src: buttonImage,
                        alt: buttonText,
                        title: buttonText
                    }) : $("<button type='button'></button>").addClass(this._triggerClass).html(!buttonImage ? buttonText : $("<img/>").attr({
                        src: buttonImage,
                        alt: buttonText,
                        title: buttonText
                    })));
                    input[isRTL ? "before" : "after"](inst.trigger);
                    inst.trigger.click(function() {
                        if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
                            $.datepicker._hideDatepicker();
                        } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
                            $.datepicker._hideDatepicker();
                            $.datepicker._showDatepicker(input[0]);
                        } else {
                            $.datepicker._showDatepicker(input[0]);
                        }
                        return false;
                    });
                }
            },
            /* Apply the maximum length for the date format. */
            _autoSize: function(inst) {
                if (this._get(inst, "autoSize") && !inst.inline) {
                    var findMax, max, maxI, i, date = new Date(2009, 12 - 1, 20), // Ensure double digits
                    dateFormat = this._get(inst, "dateFormat");
                    if (dateFormat.match(/[DM]/)) {
                        findMax = function(names) {
                            max = 0;
                            maxI = 0;
                            for (i = 0; i < names.length; i++) {
                                if (names[i].length > max) {
                                    max = names[i].length;
                                    maxI = i;
                                }
                            }
                            return maxI;
                        };
                        date.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? "monthNames" : "monthNamesShort")));
                        date.setDate(findMax(this._get(inst, dateFormat.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - date.getDay());
                    }
                    inst.input.attr("size", this._formatDate(inst, date).length);
                }
            },
            /* Attach an inline date picker to a div. */
            _inlineDatepicker: function(target, inst) {
                var divSpan = $(target);
                if (divSpan.hasClass(this.markerClassName)) {
                    return;
                }
                divSpan.addClass(this.markerClassName).append(inst.dpDiv);
                $.data(target, PROP_NAME, inst);
                this._setDate(inst, this._getDefaultDate(inst), true);
                this._updateDatepicker(inst);
                this._updateAlternate(inst);
                //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
                if (inst.settings.disabled) {
                    this._disableDatepicker(target);
                }
                // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
                // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
                inst.dpDiv.css("display", "block");
            },
            /* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
            _dialogDatepicker: function(input, date, onSelect, settings, pos) {
                var id, browserWidth, browserHeight, scrollX, scrollY, inst = this._dialogInst;
                // internal instance
                if (!inst) {
                    this.uuid += 1;
                    id = "dp" + this.uuid;
                    this._dialogInput = $("<input type='text' id='" + id + "' style='position: absolute; top: -100px; width: 0px;'/>");
                    this._dialogInput.keydown(this._doKeyDown);
                    $("body").append(this._dialogInput);
                    inst = this._dialogInst = this._newInst(this._dialogInput, false);
                    inst.settings = {};
                    $.data(this._dialogInput[0], PROP_NAME, inst);
                }
                extendRemove(inst.settings, settings || {});
                date = date && date.constructor === Date ? this._formatDate(inst, date) : date;
                this._dialogInput.val(date);
                this._pos = pos ? pos.length ? pos : [ pos.pageX, pos.pageY ] : null;
                if (!this._pos) {
                    browserWidth = document.documentElement.clientWidth;
                    browserHeight = document.documentElement.clientHeight;
                    scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                    scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                    this._pos = // should use actual width/height below
                    [ browserWidth / 2 - 100 + scrollX, browserHeight / 2 - 150 + scrollY ];
                }
                // move input on screen for focus, but hidden behind dialog
                this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px");
                inst.settings.onSelect = onSelect;
                this._inDialog = true;
                this.dpDiv.addClass(this._dialogClass);
                this._showDatepicker(this._dialogInput[0]);
                if ($.blockUI) {
                    $.blockUI(this.dpDiv);
                }
                $.data(this._dialogInput[0], PROP_NAME, inst);
                return this;
            },
            /* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
            _destroyDatepicker: function(target) {
                var nodeName, $target = $(target), inst = $.data(target, PROP_NAME);
                if (!$target.hasClass(this.markerClassName)) {
                    return;
                }
                nodeName = target.nodeName.toLowerCase();
                $.removeData(target, PROP_NAME);
                if (nodeName === "input") {
                    inst.append.remove();
                    inst.trigger.remove();
                    $target.removeClass(this.markerClassName).unbind("focus", this._showDatepicker).unbind("keydown", this._doKeyDown).unbind("keypress", this._doKeyPress).unbind("keyup", this._doKeyUp);
                } else if (nodeName === "div" || nodeName === "span") {
                    $target.removeClass(this.markerClassName).empty();
                }
            },
            /* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
            _enableDatepicker: function(target) {
                var nodeName, inline, $target = $(target), inst = $.data(target, PROP_NAME);
                if (!$target.hasClass(this.markerClassName)) {
                    return;
                }
                nodeName = target.nodeName.toLowerCase();
                if (nodeName === "input") {
                    target.disabled = false;
                    inst.trigger.filter("button").each(function() {
                        this.disabled = false;
                    }).end().filter("img").css({
                        opacity: "1.0",
                        cursor: ""
                    });
                } else if (nodeName === "div" || nodeName === "span") {
                    inline = $target.children("." + this._inlineClass);
                    inline.children().removeClass("ui-state-disabled");
                    inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", false);
                }
                this._disabledInputs = $.map(this._disabledInputs, function(value) {
                    return value === target ? null : value;
                });
            },
            /* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
            _disableDatepicker: function(target) {
                var nodeName, inline, $target = $(target), inst = $.data(target, PROP_NAME);
                if (!$target.hasClass(this.markerClassName)) {
                    return;
                }
                nodeName = target.nodeName.toLowerCase();
                if (nodeName === "input") {
                    target.disabled = true;
                    inst.trigger.filter("button").each(function() {
                        this.disabled = true;
                    }).end().filter("img").css({
                        opacity: "0.5",
                        cursor: "default"
                    });
                } else if (nodeName === "div" || nodeName === "span") {
                    inline = $target.children("." + this._inlineClass);
                    inline.children().addClass("ui-state-disabled");
                    inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", true);
                }
                this._disabledInputs = $.map(this._disabledInputs, function(value) {
                    return value === target ? null : value;
                });
                // delete entry
                this._disabledInputs[this._disabledInputs.length] = target;
            },
            /* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
            _isDisabledDatepicker: function(target) {
                if (!target) {
                    return false;
                }
                for (var i = 0; i < this._disabledInputs.length; i++) {
                    if (this._disabledInputs[i] === target) {
                        return true;
                    }
                }
                return false;
            },
            /* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
            _getInst: function(target) {
                try {
                    return $.data(target, PROP_NAME);
                } catch (err) {
                    throw "Missing instance data for this datepicker";
                }
            },
            /* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
            _optionDatepicker: function(target, name, value) {
                var settings, date, minDate, maxDate, inst = this._getInst(target);
                if (arguments.length === 2 && typeof name === "string") {
                    return name === "defaults" ? $.extend({}, $.datepicker._defaults) : inst ? name === "all" ? $.extend({}, inst.settings) : this._get(inst, name) : null;
                }
                settings = name || {};
                if (typeof name === "string") {
                    settings = {};
                    settings[name] = value;
                }
                if (inst) {
                    if (this._curInst === inst) {
                        this._hideDatepicker();
                    }
                    date = this._getDateDatepicker(target, true);
                    minDate = this._getMinMaxDate(inst, "min");
                    maxDate = this._getMinMaxDate(inst, "max");
                    extendRemove(inst.settings, settings);
                    // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
                    if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
                        inst.settings.minDate = this._formatDate(inst, minDate);
                    }
                    if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
                        inst.settings.maxDate = this._formatDate(inst, maxDate);
                    }
                    if ("disabled" in settings) {
                        if (settings.disabled) {
                            this._disableDatepicker(target);
                        } else {
                            this._enableDatepicker(target);
                        }
                    }
                    this._attachments($(target), inst);
                    this._autoSize(inst);
                    this._setDate(inst, date);
                    this._updateAlternate(inst);
                    this._updateDatepicker(inst);
                }
            },
            // change method deprecated
            _changeDatepicker: function(target, name, value) {
                this._optionDatepicker(target, name, value);
            },
            /* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
            _refreshDatepicker: function(target) {
                var inst = this._getInst(target);
                if (inst) {
                    this._updateDatepicker(inst);
                }
            },
            /* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
            _setDateDatepicker: function(target, date) {
                var inst = this._getInst(target);
                if (inst) {
                    this._setDate(inst, date);
                    this._updateDatepicker(inst);
                    this._updateAlternate(inst);
                }
            },
            /* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
            _getDateDatepicker: function(target, noDefault) {
                var inst = this._getInst(target);
                if (inst && !inst.inline) {
                    this._setDateFromField(inst, noDefault);
                }
                return inst ? this._getDate(inst) : null;
            },
            /* Handle keystrokes. */
            _doKeyDown: function(event) {
                var onSelect, dateStr, sel, inst = $.datepicker._getInst(event.target), handled = true, isRTL = inst.dpDiv.is(".ui-datepicker-rtl");
                inst._keyEvent = true;
                if ($.datepicker._datepickerShowing) {
                    switch (event.keyCode) {
                      case 9:
                        $.datepicker._hideDatepicker();
                        handled = false;
                        break;

                      // hide on tab out
                        case 13:
                        sel = $("td." + $.datepicker._dayOverClass + ":not(." + $.datepicker._currentClass + ")", inst.dpDiv);
                        if (sel[0]) {
                            $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
                        }
                        onSelect = $.datepicker._get(inst, "onSelect");
                        if (onSelect) {
                            dateStr = $.datepicker._formatDate(inst);
                            // trigger custom callback
                            onSelect.apply(inst.input ? inst.input[0] : null, [ dateStr, inst ]);
                        } else {
                            $.datepicker._hideDatepicker();
                        }
                        return false;

                      // don't submit the form
                        case 27:
                        $.datepicker._hideDatepicker();
                        break;

                      // hide on escape
                        case 33:
                        $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
                        break;

                      // previous month/year on page up/+ ctrl
                        case 34:
                        $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
                        break;

                      // next month/year on page down/+ ctrl
                        case 35:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._clearDate(event.target);
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break;

                      // clear on ctrl or command +end
                        case 36:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._gotoToday(event.target);
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break;

                      // current on ctrl or command +home
                        case 37:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, isRTL ? +1 : -1, "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        // -1 day on ctrl or command +left
                        if (event.originalEvent.altKey) {
                            $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
                        }
                        // next month/year on alt +left on Mac
                        break;

                      case 38:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, -7, "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break;

                      // -1 week on ctrl or command +up
                        case 39:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, isRTL ? -1 : +1, "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        // +1 day on ctrl or command +right
                        if (event.originalEvent.altKey) {
                            $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
                        }
                        // next month/year on alt +right
                        break;

                      case 40:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, +7, "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break;

                      // +1 week on ctrl or command +down
                        default:
                        handled = false;
                    }
                } else if (event.keyCode === 36 && event.ctrlKey) {
                    // display the date picker on ctrl+home
                    $.datepicker._showDatepicker(this);
                } else {
                    handled = false;
                }
                if (handled) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            },
            /* Filter entered characters - based on date format. */
            _doKeyPress: function(event) {
                var chars, chr, inst = $.datepicker._getInst(event.target);
                if ($.datepicker._get(inst, "constrainInput")) {
                    chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
                    chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
                    return event.ctrlKey || event.metaKey || chr < " " || !chars || chars.indexOf(chr) > -1;
                }
            },
            /* Synchronise manual entry and field/alternate field. */
            _doKeyUp: function(event) {
                var date, inst = $.datepicker._getInst(event.target);
                if (inst.input.val() !== inst.lastVal) {
                    try {
                        date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), inst.input ? inst.input.val() : null, $.datepicker._getFormatConfig(inst));
                        if (date) {
                            // only if valid
                            $.datepicker._setDateFromField(inst);
                            $.datepicker._updateAlternate(inst);
                            $.datepicker._updateDatepicker(inst);
                        }
                    } catch (err) {}
                }
                return true;
            },
            /* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
            _showDatepicker: function(input) {
                input = input.target || input;
                if (input.nodeName.toLowerCase() !== "input") {
                    // find from button/image trigger
                    input = $("input", input.parentNode)[0];
                }
                if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {
                    // already here
                    return;
                }
                var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;
                inst = $.datepicker._getInst(input);
                if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
                    $.datepicker._curInst.dpDiv.stop(true, true);
                    if (inst && $.datepicker._datepickerShowing) {
                        $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
                    }
                }
                beforeShow = $.datepicker._get(inst, "beforeShow");
                beforeShowSettings = beforeShow ? beforeShow.apply(input, [ input, inst ]) : {};
                if (beforeShowSettings === false) {
                    return;
                }
                extendRemove(inst.settings, beforeShowSettings);
                inst.lastVal = null;
                $.datepicker._lastInput = input;
                $.datepicker._setDateFromField(inst);
                if ($.datepicker._inDialog) {
                    // hide cursor
                    input.value = "";
                }
                if (!$.datepicker._pos) {
                    // position below input
                    $.datepicker._pos = $.datepicker._findPos(input);
                    $.datepicker._pos[1] += input.offsetHeight;
                }
                isFixed = false;
                $(input).parents().each(function() {
                    isFixed |= $(this).css("position") === "fixed";
                    return !isFixed;
                });
                offset = {
                    left: $.datepicker._pos[0],
                    top: $.datepicker._pos[1]
                };
                $.datepicker._pos = null;
                //to avoid flashes on Firefox
                inst.dpDiv.empty();
                // determine sizing offscreen
                inst.dpDiv.css({
                    position: "absolute",
                    display: "block",
                    top: "-1000px"
                });
                $.datepicker._updateDatepicker(inst);
                // fix width for dynamic number of date pickers
                // and adjust position before showing
                offset = $.datepicker._checkOffset(inst, offset, isFixed);
                inst.dpDiv.css({
                    position: $.datepicker._inDialog && $.blockUI ? "static" : isFixed ? "fixed" : "absolute",
                    display: "none",
                    left: offset.left + "px",
                    top: offset.top + "px"
                });
                if (!inst.inline) {
                    showAnim = $.datepicker._get(inst, "showAnim");
                    duration = $.datepicker._get(inst, "duration");
                    inst.dpDiv.zIndex($(input).zIndex() + 1);
                    $.datepicker._datepickerShowing = true;
                    if ($.effects && $.effects.effect[showAnim]) {
                        inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
                    } else {
                        inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
                    }
                    if ($.datepicker._shouldFocusInput(inst)) {
                        inst.input.focus();
                    }
                    $.datepicker._curInst = inst;
                }
            },
            /* Generate the date picker content. */
            _updateDatepicker: function(inst) {
                this.maxRows = 4;
                //Reset the max number of rows being displayed (see #7043)
                instActive = inst;
                // for delegate hover events
                inst.dpDiv.empty().append(this._generateHTML(inst));
                this._attachHandlers(inst);
                inst.dpDiv.find("." + this._dayOverClass + " a").mouseover();
                var origyearshtml, numMonths = this._getNumberOfMonths(inst), cols = numMonths[1], width = 17;
                inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
                if (cols > 1) {
                    inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", width * cols + "em");
                }
                inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") + "Class"]("ui-datepicker-multi");
                inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl");
                if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
                    inst.input.focus();
                }
                // deffered render of the years select (to avoid flashes on Firefox)
                if (inst.yearshtml) {
                    origyearshtml = inst.yearshtml;
                    setTimeout(function() {
                        //assure that inst.yearshtml didn't change.
                        if (origyearshtml === inst.yearshtml && inst.yearshtml) {
                            inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
                        }
                        origyearshtml = inst.yearshtml = null;
                    }, 0);
                }
            },
            // #6694 - don't focus the input if it's already focused
            // this breaks the change event in IE
            // Support: IE and jQuery <1.9
            _shouldFocusInput: function(inst) {
                return inst.input && inst.input.is(":visible") && !inst.input.is(":disabled") && !inst.input.is(":focus");
            },
            /* Check positioning to remain on screen. */
            _checkOffset: function(inst, offset, isFixed) {
                var dpWidth = inst.dpDiv.outerWidth(), dpHeight = inst.dpDiv.outerHeight(), inputWidth = inst.input ? inst.input.outerWidth() : 0, inputHeight = inst.input ? inst.input.outerHeight() : 0, viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()), viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
                offset.left -= this._get(inst, "isRTL") ? dpWidth - inputWidth : 0;
                offset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0;
                offset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0;
                // now check if datepicker is showing outside window viewport - move to a better place if so.
                offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
                offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0);
                return offset;
            },
            /* Find an object's position on the screen. */
            _findPos: function(obj) {
                var position, inst = this._getInst(obj), isRTL = this._get(inst, "isRTL");
                while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
                    obj = obj[isRTL ? "previousSibling" : "nextSibling"];
                }
                position = $(obj).offset();
                return [ position.left, position.top ];
            },
            /* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
            _hideDatepicker: function(input) {
                var showAnim, duration, postProcess, onClose, inst = this._curInst;
                if (!inst || input && inst !== $.data(input, PROP_NAME)) {
                    return;
                }
                if (this._datepickerShowing) {
                    showAnim = this._get(inst, "showAnim");
                    duration = this._get(inst, "duration");
                    postProcess = function() {
                        $.datepicker._tidyDialog(inst);
                    };
                    // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
                    if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
                        inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
                    } else {
                        inst.dpDiv[showAnim === "slideDown" ? "slideUp" : showAnim === "fadeIn" ? "fadeOut" : "hide"](showAnim ? duration : null, postProcess);
                    }
                    if (!showAnim) {
                        postProcess();
                    }
                    this._datepickerShowing = false;
                    onClose = this._get(inst, "onClose");
                    if (onClose) {
                        onClose.apply(inst.input ? inst.input[0] : null, [ inst.input ? inst.input.val() : "", inst ]);
                    }
                    this._lastInput = null;
                    if (this._inDialog) {
                        this._dialogInput.css({
                            position: "absolute",
                            left: "0",
                            top: "-100px"
                        });
                        if ($.blockUI) {
                            $.unblockUI();
                            $("body").append(this.dpDiv);
                        }
                    }
                    this._inDialog = false;
                }
            },
            /* Tidy up after a dialog display. */
            _tidyDialog: function(inst) {
                inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
            },
            /* Close date picker if clicked elsewhere. */
            _checkExternalClick: function(event) {
                if (!$.datepicker._curInst) {
                    return;
                }
                var $target = $(event.target), inst = $.datepicker._getInst($target[0]);
                if ($target[0].id !== $.datepicker._mainDivId && $target.parents("#" + $.datepicker._mainDivId).length === 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest("." + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) || $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst) {
                    $.datepicker._hideDatepicker();
                }
            },
            /* Adjust one of the date sub-fields. */
            _adjustDate: function(id, offset, period) {
                var target = $(id), inst = this._getInst(target[0]);
                if (this._isDisabledDatepicker(target[0])) {
                    return;
                }
                this._adjustInstDate(inst, offset + (period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
                period);
                this._updateDatepicker(inst);
            },
            /* Action for current link. */
            _gotoToday: function(id) {
                var date, target = $(id), inst = this._getInst(target[0]);
                if (this._get(inst, "gotoCurrent") && inst.currentDay) {
                    inst.selectedDay = inst.currentDay;
                    inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                    inst.drawYear = inst.selectedYear = inst.currentYear;
                } else {
                    date = new Date();
                    inst.selectedDay = date.getDate();
                    inst.drawMonth = inst.selectedMonth = date.getMonth();
                    inst.drawYear = inst.selectedYear = date.getFullYear();
                }
                this._notifyChange(inst);
                this._adjustDate(target);
            },
            /* Action for selecting a new month/year. */
            _selectMonthYear: function(id, select, period) {
                var target = $(id), inst = this._getInst(target[0]);
                inst["selected" + (period === "M" ? "Month" : "Year")] = inst["draw" + (period === "M" ? "Month" : "Year")] = parseInt(select.options[select.selectedIndex].value, 10);
                this._notifyChange(inst);
                this._adjustDate(target);
            },
            /* Action for selecting a day. */
            _selectDay: function(id, month, year, td) {
                var inst, target = $(id);
                if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
                    return;
                }
                inst = this._getInst(target[0]);
                inst.selectedDay = inst.currentDay = $("a", td).html();
                inst.selectedMonth = inst.currentMonth = month;
                inst.selectedYear = inst.currentYear = year;
                this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));
            },
            /* Erase the input field and hide the date picker. */
            _clearDate: function(id) {
                var target = $(id);
                this._selectDate(target, "");
            },
            /* Update the input field with the selected date. */
            _selectDate: function(id, dateStr) {
                var onSelect, target = $(id), inst = this._getInst(target[0]);
                dateStr = dateStr != null ? dateStr : this._formatDate(inst);
                if (inst.input) {
                    inst.input.val(dateStr);
                }
                this._updateAlternate(inst);
                onSelect = this._get(inst, "onSelect");
                if (onSelect) {
                    onSelect.apply(inst.input ? inst.input[0] : null, [ dateStr, inst ]);
                } else if (inst.input) {
                    inst.input.trigger("change");
                }
                if (inst.inline) {
                    this._updateDatepicker(inst);
                } else {
                    this._hideDatepicker();
                    this._lastInput = inst.input[0];
                    if (typeof inst.input[0] !== "object") {
                        inst.input.focus();
                    }
                    this._lastInput = null;
                }
            },
            /* Update any alternate field to synchronise with the main field. */
            _updateAlternate: function(inst) {
                var altFormat, date, dateStr, altField = this._get(inst, "altField");
                if (altField) {
                    // update alternate field too
                    altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
                    date = this._getDate(inst);
                    dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
                    $(altField).each(function() {
                        $(this).val(dateStr);
                    });
                }
            },
            /* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
            noWeekends: function(date) {
                var day = date.getDay();
                return [ day > 0 && day < 6, "" ];
            },
            /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
            iso8601Week: function(date) {
                var time, checkDate = new Date(date.getTime());
                // Find Thursday of this week starting on Monday
                checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
                time = checkDate.getTime();
                checkDate.setMonth(0);
                // Compare with Jan 1
                checkDate.setDate(1);
                return Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1;
            },
            /* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
            parseDate: function(format, value, settings) {
                if (format == null || value == null) {
                    throw "Invalid arguments";
                }
                value = typeof value === "object" ? value.toString() : value + "";
                if (value === "") {
                    return null;
                }
                var iFormat, dim, extra, iValue = 0, shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff, shortYearCutoff = typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10), dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, year = -1, month = -1, day = -1, doy = -1, literal = false, date, // Check whether a format character is doubled
                lookAhead = function(match) {
                    var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                }, // Extract a number from the string value
                getNumber = function(match) {
                    var isDoubled = lookAhead(match), size = match === "@" ? 14 : match === "!" ? 20 : match === "y" && isDoubled ? 4 : match === "o" ? 3 : 2, digits = new RegExp("^\\d{1," + size + "}"), num = value.substring(iValue).match(digits);
                    if (!num) {
                        throw "Missing number at position " + iValue;
                    }
                    iValue += num[0].length;
                    return parseInt(num[0], 10);
                }, // Extract a name from the string value and convert to an index
                getName = function(match, shortNames, longNames) {
                    var index = -1, names = $.map(lookAhead(match) ? longNames : shortNames, function(v, k) {
                        return [ [ k, v ] ];
                    }).sort(function(a, b) {
                        return -(a[1].length - b[1].length);
                    });
                    $.each(names, function(i, pair) {
                        var name = pair[1];
                        if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                            index = pair[0];
                            iValue += name.length;
                            return false;
                        }
                    });
                    if (index !== -1) {
                        return index + 1;
                    } else {
                        throw "Unknown name at position " + iValue;
                    }
                }, // Confirm that a literal character matches the string value
                checkLiteral = function() {
                    if (value.charAt(iValue) !== format.charAt(iFormat)) {
                        throw "Unexpected literal at position " + iValue;
                    }
                    iValue++;
                };
                for (iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                            literal = false;
                        } else {
                            checkLiteral();
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                          case "d":
                            day = getNumber("d");
                            break;

                          case "D":
                            getName("D", dayNamesShort, dayNames);
                            break;

                          case "o":
                            doy = getNumber("o");
                            break;

                          case "m":
                            month = getNumber("m");
                            break;

                          case "M":
                            month = getName("M", monthNamesShort, monthNames);
                            break;

                          case "y":
                            year = getNumber("y");
                            break;

                          case "@":
                            date = new Date(getNumber("@"));
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;

                          case "!":
                            date = new Date((getNumber("!") - this._ticksTo1970) / 1e4);
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;

                          case "'":
                            if (lookAhead("'")) {
                                checkLiteral();
                            } else {
                                literal = true;
                            }
                            break;

                          default:
                            checkLiteral();
                        }
                    }
                }
                if (iValue < value.length) {
                    extra = value.substr(iValue);
                    if (!/^\s+/.test(extra)) {
                        throw "Extra/unparsed characters found in date: " + extra;
                    }
                }
                if (year === -1) {
                    year = new Date().getFullYear();
                } else if (year < 100) {
                    year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
                }
                if (doy > -1) {
                    month = 1;
                    day = doy;
                    do {
                        dim = this._getDaysInMonth(year, month - 1);
                        if (day <= dim) {
                            break;
                        }
                        month++;
                        day -= dim;
                    } while (true);
                }
                date = this._daylightSavingAdjust(new Date(year, month - 1, day));
                if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
                    throw "Invalid date";
                }
                return date;
            },
            /* Standard date formats. */
            ATOM: "yy-mm-dd",
            // RFC 3339 (ISO 8601)
            COOKIE: "D, dd M yy",
            ISO_8601: "yy-mm-dd",
            RFC_822: "D, d M y",
            RFC_850: "DD, dd-M-y",
            RFC_1036: "D, d M y",
            RFC_1123: "D, d M yy",
            RFC_2822: "D, d M yy",
            RSS: "D, d M y",
            // RFC 822
            TICKS: "!",
            TIMESTAMP: "@",
            W3C: "yy-mm-dd",
            // ISO 8601
            _ticksTo1970: ((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 1e7,
            /* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
            formatDate: function(format, date, settings) {
                if (!date) {
                    return "";
                }
                var iFormat, dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, // Check whether a format character is doubled
                lookAhead = function(match) {
                    var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                }, // Format a number, with leading zero if necessary
                formatNumber = function(match, value, len) {
                    var num = "" + value;
                    if (lookAhead(match)) {
                        while (num.length < len) {
                            num = "0" + num;
                        }
                    }
                    return num;
                }, // Format a name, short or long as requested
                formatName = function(match, value, shortNames, longNames) {
                    return lookAhead(match) ? longNames[value] : shortNames[value];
                }, output = "", literal = false;
                if (date) {
                    for (iFormat = 0; iFormat < format.length; iFormat++) {
                        if (literal) {
                            if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                                literal = false;
                            } else {
                                output += format.charAt(iFormat);
                            }
                        } else {
                            switch (format.charAt(iFormat)) {
                              case "d":
                                output += formatNumber("d", date.getDate(), 2);
                                break;

                              case "D":
                                output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                                break;

                              case "o":
                                output += formatNumber("o", Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 864e5), 3);
                                break;

                              case "m":
                                output += formatNumber("m", date.getMonth() + 1, 2);
                                break;

                              case "M":
                                output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                                break;

                              case "y":
                                output += lookAhead("y") ? date.getFullYear() : (date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100;
                                break;

                              case "@":
                                output += date.getTime();
                                break;

                              case "!":
                                output += date.getTime() * 1e4 + this._ticksTo1970;
                                break;

                              case "'":
                                if (lookAhead("'")) {
                                    output += "'";
                                } else {
                                    literal = true;
                                }
                                break;

                              default:
                                output += format.charAt(iFormat);
                            }
                        }
                    }
                }
                return output;
            },
            /* Extract all possible characters from the date format. */
            _possibleChars: function(format) {
                var iFormat, chars = "", literal = false, // Check whether a format character is doubled
                lookAhead = function(match) {
                    var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                };
                for (iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                            literal = false;
                        } else {
                            chars += format.charAt(iFormat);
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                          case "d":
                          case "m":
                          case "y":
                          case "@":
                            chars += "0123456789";
                            break;

                          case "D":
                          case "M":
                            return null;

                          // Accept anything
                            case "'":
                            if (lookAhead("'")) {
                                chars += "'";
                            } else {
                                literal = true;
                            }
                            break;

                          default:
                            chars += format.charAt(iFormat);
                        }
                    }
                }
                return chars;
            },
            /* Get a setting value, defaulting if necessary. */
            _get: function(inst, name) {
                return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];
            },
            /* Parse existing date and initialise date picker. */
            _setDateFromField: function(inst, noDefault) {
                if (inst.input.val() === inst.lastVal) {
                    return;
                }
                var dateFormat = this._get(inst, "dateFormat"), dates = inst.lastVal = inst.input ? inst.input.val() : null, defaultDate = this._getDefaultDate(inst), date = defaultDate, settings = this._getFormatConfig(inst);
                try {
                    date = this.parseDate(dateFormat, dates, settings) || defaultDate;
                } catch (event) {
                    dates = noDefault ? "" : dates;
                }
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
                inst.currentDay = dates ? date.getDate() : 0;
                inst.currentMonth = dates ? date.getMonth() : 0;
                inst.currentYear = dates ? date.getFullYear() : 0;
                this._adjustInstDate(inst);
            },
            /* Retrieve the default date shown on opening. */
            _getDefaultDate: function(inst) {
                return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
            },
            /* A date may be specified as an exact value or a relative one. */
            _determineDate: function(inst, date, defaultDate) {
                var offsetNumeric = function(offset) {
                    var date = new Date();
                    date.setDate(date.getDate() + offset);
                    return date;
                }, offsetString = function(offset) {
                    try {
                        return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), offset, $.datepicker._getFormatConfig(inst));
                    } catch (e) {}
                    var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(), year = date.getFullYear(), month = date.getMonth(), day = date.getDate(), pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, matches = pattern.exec(offset);
                    while (matches) {
                        switch (matches[2] || "d") {
                          case "d":
                          case "D":
                            day += parseInt(matches[1], 10);
                            break;

                          case "w":
                          case "W":
                            day += parseInt(matches[1], 10) * 7;
                            break;

                          case "m":
                          case "M":
                            month += parseInt(matches[1], 10);
                            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                            break;

                          case "y":
                          case "Y":
                            year += parseInt(matches[1], 10);
                            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                            break;
                        }
                        matches = pattern.exec(offset);
                    }
                    return new Date(year, month, day);
                }, newDate = date == null || date === "" ? defaultDate : typeof date === "string" ? offsetString(date) : typeof date === "number" ? isNaN(date) ? defaultDate : offsetNumeric(date) : new Date(date.getTime());
                newDate = newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate;
                if (newDate) {
                    newDate.setHours(0);
                    newDate.setMinutes(0);
                    newDate.setSeconds(0);
                    newDate.setMilliseconds(0);
                }
                return this._daylightSavingAdjust(newDate);
            },
            /* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
            _daylightSavingAdjust: function(date) {
                if (!date) {
                    return null;
                }
                date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
                return date;
            },
            /* Set the date(s) directly. */
            _setDate: function(inst, date, noChange) {
                var clear = !date, origMonth = inst.selectedMonth, origYear = inst.selectedYear, newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
                inst.selectedDay = inst.currentDay = newDate.getDate();
                inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
                inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
                if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
                    this._notifyChange(inst);
                }
                this._adjustInstDate(inst);
                if (inst.input) {
                    inst.input.val(clear ? "" : this._formatDate(inst));
                }
            },
            /* Retrieve the date(s) directly. */
            _getDate: function(inst) {
                var startDate = !inst.currentYear || inst.input && inst.input.val() === "" ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
                return startDate;
            },
            /* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
            _attachHandlers: function(inst) {
                var stepMonths = this._get(inst, "stepMonths"), id = "#" + inst.id.replace(/\\\\/g, "\\");
                inst.dpDiv.find("[data-handler]").map(function() {
                    var handler = {
                        prev: function() {
                            $.datepicker._adjustDate(id, -stepMonths, "M");
                        },
                        next: function() {
                            $.datepicker._adjustDate(id, +stepMonths, "M");
                        },
                        hide: function() {
                            $.datepicker._hideDatepicker();
                        },
                        today: function() {
                            $.datepicker._gotoToday(id);
                        },
                        selectDay: function() {
                            $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
                            return false;
                        },
                        selectMonth: function() {
                            $.datepicker._selectMonthYear(id, this, "M");
                            return false;
                        },
                        selectYear: function() {
                            $.datepicker._selectMonthYear(id, this, "Y");
                            return false;
                        }
                    };
                    $(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
                });
            },
            /* Generate the HTML for the current state of the date picker. */
            _generateHTML: function(inst) {
                var maxDraw, prevText, prev, nextText, next, currentText, gotoDate, controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin, monthNames, monthNamesShort, beforeShowDay, showOtherMonths, selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate, cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows, printDate, dRow, tbody, daySettings, otherMonth, unselectable, tempDate = new Date(), today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
                isRTL = this._get(inst, "isRTL"), showButtonPanel = this._get(inst, "showButtonPanel"), hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"), navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"), numMonths = this._getNumberOfMonths(inst), showCurrentAtPos = this._get(inst, "showCurrentAtPos"), stepMonths = this._get(inst, "stepMonths"), isMultiMonth = numMonths[0] !== 1 || numMonths[1] !== 1, currentDate = this._daylightSavingAdjust(!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay)), minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), drawMonth = inst.drawMonth - showCurrentAtPos, drawYear = inst.drawYear;
                if (drawMonth < 0) {
                    drawMonth += 12;
                    drawYear--;
                }
                if (maxDate) {
                    maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate()));
                    maxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;
                    while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                        drawMonth--;
                        if (drawMonth < 0) {
                            drawMonth = 11;
                            drawYear--;
                        }
                    }
                }
                inst.drawMonth = drawMonth;
                inst.drawYear = drawYear;
                prevText = this._get(inst, "prevText");
                prevText = !navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst));
                prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" + " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>";
                nextText = this._get(inst, "nextText");
                nextText = !navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst));
                next = this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" + " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>";
                currentText = this._get(inst, "currentText");
                gotoDate = this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today;
                currentText = !navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst));
                controls = !inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" + this._get(inst, "closeText") + "</button>" : "";
                buttonPanel = showButtonPanel ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") + (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" + ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";
                firstDay = parseInt(this._get(inst, "firstDay"), 10);
                firstDay = isNaN(firstDay) ? 0 : firstDay;
                showWeek = this._get(inst, "showWeek");
                dayNames = this._get(inst, "dayNames");
                dayNamesMin = this._get(inst, "dayNamesMin");
                monthNames = this._get(inst, "monthNames");
                monthNamesShort = this._get(inst, "monthNamesShort");
                beforeShowDay = this._get(inst, "beforeShowDay");
                showOtherMonths = this._get(inst, "showOtherMonths");
                selectOtherMonths = this._get(inst, "selectOtherMonths");
                defaultDate = this._getDefaultDate(inst);
                html = "";
                dow;
                for (row = 0; row < numMonths[0]; row++) {
                    group = "";
                    this.maxRows = 4;
                    for (col = 0; col < numMonths[1]; col++) {
                        selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                        cornerClass = " ui-corner-all";
                        calender = "";
                        if (isMultiMonth) {
                            calender += "<div class='ui-datepicker-group";
                            if (numMonths[1] > 1) {
                                switch (col) {
                                  case 0:
                                    calender += " ui-datepicker-group-first";
                                    cornerClass = " ui-corner-" + (isRTL ? "right" : "left");
                                    break;

                                  case numMonths[1] - 1:
                                    calender += " ui-datepicker-group-last";
                                    cornerClass = " ui-corner-" + (isRTL ? "left" : "right");
                                    break;

                                  default:
                                    calender += " ui-datepicker-group-middle";
                                    cornerClass = "";
                                    break;
                                }
                            }
                            calender += "'>";
                        }
                        calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" + (/all|left/.test(cornerClass) && row === 0 ? isRTL ? next : prev : "") + (/all|right/.test(cornerClass) && row === 0 ? isRTL ? prev : next : "") + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
                        "</div><table class='ui-datepicker-calendar'><thead>" + "<tr>";
                        thead = showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "";
                        for (dow = 0; dow < 7; dow++) {
                            // days of the week
                            day = (dow + firstDay) % 7;
                            thead += "<th" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" + "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
                        }
                        calender += thead + "</tr></thead><tbody>";
                        daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                        if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                            inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                        }
                        leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                        curRows = Math.ceil((leadDays + daysInMonth) / 7);
                        // calculate the number of rows to generate
                        numRows = isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows;
                        //If multiple months, use the higher number of rows (see #7043)
                        this.maxRows = numRows;
                        printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                        for (dRow = 0; dRow < numRows; dRow++) {
                            // create date picker rows
                            calender += "<tr>";
                            tbody = !showWeek ? "" : "<td class='ui-datepicker-week-col'>" + this._get(inst, "calculateWeek")(printDate) + "</td>";
                            for (dow = 0; dow < 7; dow++) {
                                // create date picker days
                                daySettings = beforeShowDay ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [ printDate ]) : [ true, "" ];
                                otherMonth = printDate.getMonth() !== drawMonth;
                                unselectable = otherMonth && !selectOtherMonths || !daySettings[0] || minDate && printDate < minDate || maxDate && printDate > maxDate;
                                tbody += "<td class='" + ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + (// highlight weekends
                                otherMonth ? " ui-datepicker-other-month" : "") + (// highlight days from other months
                                printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent || // user pressed key
                                defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ? // or defaultDate is current printedDate and defaultDate is selectedDate
                                " " + this._dayOverClass : "") + (// highlight selected day
                                unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "") + (// highlight unselectable days
                                otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + (// highlight custom dates
                                printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + (// highlight selected day
                                printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + (// highlight today (if different)
                                (!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + (// cell title
                                unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + (// actions
                                otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
                                unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" + (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") + (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + (// highlight selected day
                                otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
                                "' href='#'>" + printDate.getDate() + "</a>") + "</td>";
                                // display selectable date
                                printDate.setDate(printDate.getDate() + 1);
                                printDate = this._daylightSavingAdjust(printDate);
                            }
                            calender += tbody + "</tr>";
                        }
                        drawMonth++;
                        if (drawMonth > 11) {
                            drawMonth = 0;
                            drawYear++;
                        }
                        calender += "</tbody></table>" + (isMultiMonth ? "</div>" + (numMonths[0] > 0 && col === numMonths[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
                        group += calender;
                    }
                    html += group;
                }
                html += buttonPanel;
                inst._keyEvent = false;
                return html;
            },
            /* Generate the month and year header. */
            _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {
                var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear, changeMonth = this._get(inst, "changeMonth"), changeYear = this._get(inst, "changeYear"), showMonthAfterYear = this._get(inst, "showMonthAfterYear"), html = "<div class='ui-datepicker-title'>", monthHtml = "";
                // month selection
                if (secondary || !changeMonth) {
                    monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
                } else {
                    inMinYear = minDate && minDate.getFullYear() === drawYear;
                    inMaxYear = maxDate && maxDate.getFullYear() === drawYear;
                    monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
                    for (month = 0; month < 12; month++) {
                        if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                            monthHtml += "<option value='" + month + "'" + (month === drawMonth ? " selected='selected'" : "") + ">" + monthNamesShort[month] + "</option>";
                        }
                    }
                    monthHtml += "</select>";
                }
                if (!showMonthAfterYear) {
                    html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
                }
                // year selection
                if (!inst.yearshtml) {
                    inst.yearshtml = "";
                    if (secondary || !changeYear) {
                        html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
                    } else {
                        // determine range of years to display
                        years = this._get(inst, "yearRange").split(":");
                        thisYear = new Date().getFullYear();
                        determineYear = function(value) {
                            var year = value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10);
                            return isNaN(year) ? thisYear : year;
                        };
                        year = determineYear(years[0]);
                        endYear = Math.max(year, determineYear(years[1] || ""));
                        year = minDate ? Math.max(year, minDate.getFullYear()) : year;
                        endYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear;
                        inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
                        for (;year <= endYear; year++) {
                            inst.yearshtml += "<option value='" + year + "'" + (year === drawYear ? " selected='selected'" : "") + ">" + year + "</option>";
                        }
                        inst.yearshtml += "</select>";
                        html += inst.yearshtml;
                        inst.yearshtml = null;
                    }
                }
                html += this._get(inst, "yearSuffix");
                if (showMonthAfterYear) {
                    html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
                }
                html += "</div>";
                // Close datepicker_header
                return html;
            },
            /* Adjust one of the date sub-fields. */
            _adjustInstDate: function(inst, offset, period) {
                var year = inst.drawYear + (period === "Y" ? offset : 0), month = inst.drawMonth + (period === "M" ? offset : 0), day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0), date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
                if (period === "M" || period === "Y") {
                    this._notifyChange(inst);
                }
            },
            /* Ensure a date is within any min/max bounds. */
            _restrictMinMax: function(inst, date) {
                var minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), newDate = minDate && date < minDate ? minDate : date;
                return maxDate && newDate > maxDate ? maxDate : newDate;
            },
            /* Notify change of month/year. */
            _notifyChange: function(inst) {
                var onChange = this._get(inst, "onChangeMonthYear");
                if (onChange) {
                    onChange.apply(inst.input ? inst.input[0] : null, [ inst.selectedYear, inst.selectedMonth + 1, inst ]);
                }
            },
            /* Determine the number of months to show. */
            _getNumberOfMonths: function(inst) {
                var numMonths = this._get(inst, "numberOfMonths");
                return numMonths == null ? [ 1, 1 ] : typeof numMonths === "number" ? [ 1, numMonths ] : numMonths;
            },
            /* Determine the current maximum date - ensure no time components are set. */
            _getMinMaxDate: function(inst, minMax) {
                return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
            },
            /* Find the number of days in a given month. */
            _getDaysInMonth: function(year, month) {
                return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
            },
            /* Find the day of the week of the first of a month. */
            _getFirstDayOfMonth: function(year, month) {
                return new Date(year, month, 1).getDay();
            },
            /* Determines if we should allow a "next/prev" month display change. */
            _canAdjustMonth: function(inst, offset, curYear, curMonth) {
                var numMonths = this._getNumberOfMonths(inst), date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
                if (offset < 0) {
                    date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
                }
                return this._isInRange(inst, date);
            },
            /* Is the given date in the accepted range? */
            _isInRange: function(inst, date) {
                var yearSplit, currentYear, minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), minYear = null, maxYear = null, years = this._get(inst, "yearRange");
                if (years) {
                    yearSplit = years.split(":");
                    currentYear = new Date().getFullYear();
                    minYear = parseInt(yearSplit[0], 10);
                    maxYear = parseInt(yearSplit[1], 10);
                    if (yearSplit[0].match(/[+\-].*/)) {
                        minYear += currentYear;
                    }
                    if (yearSplit[1].match(/[+\-].*/)) {
                        maxYear += currentYear;
                    }
                }
                return (!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear);
            },
            /* Provide the configuration settings for formatting/parsing. */
            _getFormatConfig: function(inst) {
                var shortYearCutoff = this._get(inst, "shortYearCutoff");
                shortYearCutoff = typeof shortYearCutoff !== "string" ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10);
                return {
                    shortYearCutoff: shortYearCutoff,
                    dayNamesShort: this._get(inst, "dayNamesShort"),
                    dayNames: this._get(inst, "dayNames"),
                    monthNamesShort: this._get(inst, "monthNamesShort"),
                    monthNames: this._get(inst, "monthNames")
                };
            },
            /* Format the given date for display. */
            _formatDate: function(inst, day, month, year) {
                if (!day) {
                    inst.currentDay = inst.selectedDay;
                    inst.currentMonth = inst.selectedMonth;
                    inst.currentYear = inst.selectedYear;
                }
                var date = day ? typeof day === "object" ? day : this._daylightSavingAdjust(new Date(year, month, day)) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
                return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
            }
        });
        /*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
        function bindHover(dpDiv) {
            var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
            return dpDiv.delegate(selector, "mouseout", function() {
                $(this).removeClass("ui-state-hover");
                if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                    $(this).removeClass("ui-datepicker-prev-hover");
                }
                if (this.className.indexOf("ui-datepicker-next") !== -1) {
                    $(this).removeClass("ui-datepicker-next-hover");
                }
            }).delegate(selector, "mouseover", function() {
                if (!$.datepicker._isDisabledDatepicker(instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
                    $(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
                    $(this).addClass("ui-state-hover");
                    if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                        $(this).addClass("ui-datepicker-prev-hover");
                    }
                    if (this.className.indexOf("ui-datepicker-next") !== -1) {
                        $(this).addClass("ui-datepicker-next-hover");
                    }
                }
            });
        }
        /* jQuery extend now ignores nulls! */
        function extendRemove(target, props) {
            $.extend(target, props);
            for (var name in props) {
                if (props[name] == null) {
                    target[name] = props[name];
                }
            }
            return target;
        }
        /* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
        $.fn.datepicker = function(options) {
            /* Verify an empty collection wasn't passed - Fixes #6976 */
            if (!this.length) {
                return this;
            }
            /* Initialise the date picker. */
            if (!$.datepicker.initialized) {
                $(document).mousedown($.datepicker._checkExternalClick);
                $.datepicker.initialized = true;
            }
            /* Append datepicker main container to body if not exist. */
            if ($("#" + $.datepicker._mainDivId).length === 0) {
                $("body").append($.datepicker.dpDiv);
            }
            var otherArgs = Array.prototype.slice.call(arguments, 1);
            if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
                return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this[0] ].concat(otherArgs));
            }
            if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
                return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this[0] ].concat(otherArgs));
            }
            return this.each(function() {
                typeof options === "string" ? $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this ].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);
            });
        };
        $.datepicker = new Datepicker();
        // singleton instance
        $.datepicker.initialized = false;
        $.datepicker.uuid = new Date().getTime();
        $.datepicker.version = "1.10.3";
    })(jQuery);
    (function($, undefined) {
        var sizeRelatedOptions = {
            buttons: true,
            height: true,
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true,
            width: true
        }, resizableRelatedOptions = {
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true
        };
        $.widget("ui.dialog", {
            version: "1.10.3",
            options: {
                appendTo: "body",
                autoOpen: true,
                buttons: [],
                closeOnEscape: true,
                closeText: "close",
                dialogClass: "",
                draggable: true,
                hide: null,
                height: "auto",
                maxHeight: null,
                maxWidth: null,
                minHeight: 150,
                minWidth: 150,
                modal: false,
                position: {
                    my: "center",
                    at: "center",
                    of: window,
                    collision: "fit",
                    // Ensure the titlebar is always visible
                    using: function(pos) {
                        var topOffset = $(this).css(pos).offset().top;
                        if (topOffset < 0) {
                            $(this).css("top", pos.top - topOffset);
                        }
                    }
                },
                resizable: true,
                show: null,
                title: null,
                width: 300,
                // callbacks
                beforeClose: null,
                close: null,
                drag: null,
                dragStart: null,
                dragStop: null,
                focus: null,
                open: null,
                resize: null,
                resizeStart: null,
                resizeStop: null
            },
            _create: function() {
                this.originalCss = {
                    display: this.element[0].style.display,
                    width: this.element[0].style.width,
                    minHeight: this.element[0].style.minHeight,
                    maxHeight: this.element[0].style.maxHeight,
                    height: this.element[0].style.height
                };
                this.originalPosition = {
                    parent: this.element.parent(),
                    index: this.element.parent().children().index(this.element)
                };
                this.originalTitle = this.element.attr("title");
                this.options.title = this.options.title || this.originalTitle;
                this._createWrapper();
                this.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(this.uiDialog);
                this._createTitlebar();
                this._createButtonPane();
                if (this.options.draggable && $.fn.draggable) {
                    this._makeDraggable();
                }
                if (this.options.resizable && $.fn.resizable) {
                    this._makeResizable();
                }
                this._isOpen = false;
            },
            _init: function() {
                if (this.options.autoOpen) {
                    this.open();
                }
            },
            _appendTo: function() {
                var element = this.options.appendTo;
                if (element && (element.jquery || element.nodeType)) {
                    return $(element);
                }
                return this.document.find(element || "body").eq(0);
            },
            _destroy: function() {
                var next, originalPosition = this.originalPosition;
                this._destroyOverlay();
                this.element.removeUniqueId().removeClass("ui-dialog-content ui-widget-content").css(this.originalCss).detach();
                this.uiDialog.stop(true, true).remove();
                if (this.originalTitle) {
                    this.element.attr("title", this.originalTitle);
                }
                next = originalPosition.parent.children().eq(originalPosition.index);
                // Don't try to place the dialog next to itself (#8613)
                if (next.length && next[0] !== this.element[0]) {
                    next.before(this.element);
                } else {
                    originalPosition.parent.append(this.element);
                }
            },
            widget: function() {
                return this.uiDialog;
            },
            disable: $.noop,
            enable: $.noop,
            close: function(event) {
                var that = this;
                if (!this._isOpen || this._trigger("beforeClose", event) === false) {
                    return;
                }
                this._isOpen = false;
                this._destroyOverlay();
                if (!this.opener.filter(":focusable").focus().length) {
                    // Hiding a focused element doesn't trigger blur in WebKit
                    // so in case we have nothing to focus on, explicitly blur the active element
                    // https://bugs.webkit.org/show_bug.cgi?id=47182
                    $(this.document[0].activeElement).blur();
                }
                this._hide(this.uiDialog, this.options.hide, function() {
                    that._trigger("close", event);
                });
            },
            isOpen: function() {
                return this._isOpen;
            },
            moveToTop: function() {
                this._moveToTop();
            },
            _moveToTop: function(event, silent) {
                var moved = !!this.uiDialog.nextAll(":visible").insertBefore(this.uiDialog).length;
                if (moved && !silent) {
                    this._trigger("focus", event);
                }
                return moved;
            },
            open: function() {
                var that = this;
                if (this._isOpen) {
                    if (this._moveToTop()) {
                        this._focusTabbable();
                    }
                    return;
                }
                this._isOpen = true;
                this.opener = $(this.document[0].activeElement);
                this._size();
                this._position();
                this._createOverlay();
                this._moveToTop(null, true);
                this._show(this.uiDialog, this.options.show, function() {
                    that._focusTabbable();
                    that._trigger("focus");
                });
                this._trigger("open");
            },
            _focusTabbable: function() {
                // Set focus to the first match:
                // 1. First element inside the dialog matching [autofocus]
                // 2. Tabbable element inside the content element
                // 3. Tabbable element inside the buttonpane
                // 4. The close button
                // 5. The dialog itself
                var hasFocus = this.element.find("[autofocus]");
                if (!hasFocus.length) {
                    hasFocus = this.element.find(":tabbable");
                }
                if (!hasFocus.length) {
                    hasFocus = this.uiDialogButtonPane.find(":tabbable");
                }
                if (!hasFocus.length) {
                    hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
                }
                if (!hasFocus.length) {
                    hasFocus = this.uiDialog;
                }
                hasFocus.eq(0).focus();
            },
            _keepFocus: function(event) {
                function checkFocus() {
                    var activeElement = this.document[0].activeElement, isActive = this.uiDialog[0] === activeElement || $.contains(this.uiDialog[0], activeElement);
                    if (!isActive) {
                        this._focusTabbable();
                    }
                }
                event.preventDefault();
                checkFocus.call(this);
                // support: IE
                // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
                // so we check again later
                this._delay(checkFocus);
            },
            _createWrapper: function() {
                this.uiDialog = $("<div>").addClass("ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " + this.options.dialogClass).hide().attr({
                    // Setting tabIndex makes the div focusable
                    tabIndex: -1,
                    role: "dialog"
                }).appendTo(this._appendTo());
                this._on(this.uiDialog, {
                    keydown: function(event) {
                        if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) {
                            event.preventDefault();
                            this.close(event);
                            return;
                        }
                        // prevent tabbing out of dialogs
                        if (event.keyCode !== $.ui.keyCode.TAB) {
                            return;
                        }
                        var tabbables = this.uiDialog.find(":tabbable"), first = tabbables.filter(":first"), last = tabbables.filter(":last");
                        if ((event.target === last[0] || event.target === this.uiDialog[0]) && !event.shiftKey) {
                            first.focus(1);
                            event.preventDefault();
                        } else if ((event.target === first[0] || event.target === this.uiDialog[0]) && event.shiftKey) {
                            last.focus(1);
                            event.preventDefault();
                        }
                    },
                    mousedown: function(event) {
                        if (this._moveToTop(event)) {
                            this._focusTabbable();
                        }
                    }
                });
                // We assume that any existing aria-describedby attribute means
                // that the dialog content is marked up properly
                // otherwise we brute force the content as the description
                if (!this.element.find("[aria-describedby]").length) {
                    this.uiDialog.attr({
                        "aria-describedby": this.element.uniqueId().attr("id")
                    });
                }
            },
            _createTitlebar: function() {
                var uiDialogTitle;
                this.uiDialogTitlebar = $("<div>").addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(this.uiDialog);
                this._on(this.uiDialogTitlebar, {
                    mousedown: function(event) {
                        // Don't prevent click on close button (#8838)
                        // Focusing a dialog that is partially scrolled out of view
                        // causes the browser to scroll it into view, preventing the click event
                        if (!$(event.target).closest(".ui-dialog-titlebar-close")) {
                            // Dialog isn't getting focus when dragging (#8063)
                            this.uiDialog.focus();
                        }
                    }
                });
                this.uiDialogTitlebarClose = $("<button></button>").button({
                    label: this.options.closeText,
                    icons: {
                        primary: "ui-icon-closethick"
                    },
                    text: false
                }).addClass("ui-dialog-titlebar-close").appendTo(this.uiDialogTitlebar);
                this._on(this.uiDialogTitlebarClose, {
                    click: function(event) {
                        event.preventDefault();
                        this.close(event);
                    }
                });
                uiDialogTitle = $("<span>").uniqueId().addClass("ui-dialog-title").prependTo(this.uiDialogTitlebar);
                this._title(uiDialogTitle);
                this.uiDialog.attr({
                    "aria-labelledby": uiDialogTitle.attr("id")
                });
            },
            _title: function(title) {
                if (!this.options.title) {
                    title.html("&#160;");
                }
                title.text(this.options.title);
            },
            _createButtonPane: function() {
                this.uiDialogButtonPane = $("<div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix");
                this.uiButtonSet = $("<div>").addClass("ui-dialog-buttonset").appendTo(this.uiDialogButtonPane);
                this._createButtons();
            },
            _createButtons: function() {
                var that = this, buttons = this.options.buttons;
                // if we already have a button pane, remove it
                this.uiDialogButtonPane.remove();
                this.uiButtonSet.empty();
                if ($.isEmptyObject(buttons) || $.isArray(buttons) && !buttons.length) {
                    this.uiDialog.removeClass("ui-dialog-buttons");
                    return;
                }
                $.each(buttons, function(name, props) {
                    var click, buttonOptions;
                    props = $.isFunction(props) ? {
                        click: props,
                        text: name
                    } : props;
                    // Default to a non-submitting button
                    props = $.extend({
                        type: "button"
                    }, props);
                    // Change the context for the click callback to be the main element
                    click = props.click;
                    props.click = function() {
                        click.apply(that.element[0], arguments);
                    };
                    buttonOptions = {
                        icons: props.icons,
                        text: props.showText
                    };
                    delete props.icons;
                    delete props.showText;
                    $("<button></button>", props).button(buttonOptions).appendTo(that.uiButtonSet);
                });
                this.uiDialog.addClass("ui-dialog-buttons");
                this.uiDialogButtonPane.appendTo(this.uiDialog);
            },
            _makeDraggable: function() {
                var that = this, options = this.options;
                function filteredUi(ui) {
                    return {
                        position: ui.position,
                        offset: ui.offset
                    };
                }
                this.uiDialog.draggable({
                    cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                    handle: ".ui-dialog-titlebar",
                    containment: "document",
                    start: function(event, ui) {
                        $(this).addClass("ui-dialog-dragging");
                        that._blockFrames();
                        that._trigger("dragStart", event, filteredUi(ui));
                    },
                    drag: function(event, ui) {
                        that._trigger("drag", event, filteredUi(ui));
                    },
                    stop: function(event, ui) {
                        options.position = [ ui.position.left - that.document.scrollLeft(), ui.position.top - that.document.scrollTop() ];
                        $(this).removeClass("ui-dialog-dragging");
                        that._unblockFrames();
                        that._trigger("dragStop", event, filteredUi(ui));
                    }
                });
            },
            _makeResizable: function() {
                var that = this, options = this.options, handles = options.resizable, // .ui-resizable has position: relative defined in the stylesheet
                // but dialogs have to use absolute or fixed positioning
                position = this.uiDialog.css("position"), resizeHandles = typeof handles === "string" ? handles : "n,e,s,w,se,sw,ne,nw";
                function filteredUi(ui) {
                    return {
                        originalPosition: ui.originalPosition,
                        originalSize: ui.originalSize,
                        position: ui.position,
                        size: ui.size
                    };
                }
                this.uiDialog.resizable({
                    cancel: ".ui-dialog-content",
                    containment: "document",
                    alsoResize: this.element,
                    maxWidth: options.maxWidth,
                    maxHeight: options.maxHeight,
                    minWidth: options.minWidth,
                    minHeight: this._minHeight(),
                    handles: resizeHandles,
                    start: function(event, ui) {
                        $(this).addClass("ui-dialog-resizing");
                        that._blockFrames();
                        that._trigger("resizeStart", event, filteredUi(ui));
                    },
                    resize: function(event, ui) {
                        that._trigger("resize", event, filteredUi(ui));
                    },
                    stop: function(event, ui) {
                        options.height = $(this).height();
                        options.width = $(this).width();
                        $(this).removeClass("ui-dialog-resizing");
                        that._unblockFrames();
                        that._trigger("resizeStop", event, filteredUi(ui));
                    }
                }).css("position", position);
            },
            _minHeight: function() {
                var options = this.options;
                return options.height === "auto" ? options.minHeight : Math.min(options.minHeight, options.height);
            },
            _position: function() {
                // Need to show the dialog to get the actual offset in the position plugin
                var isVisible = this.uiDialog.is(":visible");
                if (!isVisible) {
                    this.uiDialog.show();
                }
                this.uiDialog.position(this.options.position);
                if (!isVisible) {
                    this.uiDialog.hide();
                }
            },
            _setOptions: function(options) {
                var that = this, resize = false, resizableOptions = {};
                $.each(options, function(key, value) {
                    that._setOption(key, value);
                    if (key in sizeRelatedOptions) {
                        resize = true;
                    }
                    if (key in resizableRelatedOptions) {
                        resizableOptions[key] = value;
                    }
                });
                if (resize) {
                    this._size();
                    this._position();
                }
                if (this.uiDialog.is(":data(ui-resizable)")) {
                    this.uiDialog.resizable("option", resizableOptions);
                }
            },
            _setOption: function(key, value) {
                /*jshint maxcomplexity:15*/
                var isDraggable, isResizable, uiDialog = this.uiDialog;
                if (key === "dialogClass") {
                    uiDialog.removeClass(this.options.dialogClass).addClass(value);
                }
                if (key === "disabled") {
                    return;
                }
                this._super(key, value);
                if (key === "appendTo") {
                    this.uiDialog.appendTo(this._appendTo());
                }
                if (key === "buttons") {
                    this._createButtons();
                }
                if (key === "closeText") {
                    this.uiDialogTitlebarClose.button({
                        // Ensure that we always pass a string
                        label: "" + value
                    });
                }
                if (key === "draggable") {
                    isDraggable = uiDialog.is(":data(ui-draggable)");
                    if (isDraggable && !value) {
                        uiDialog.draggable("destroy");
                    }
                    if (!isDraggable && value) {
                        this._makeDraggable();
                    }
                }
                if (key === "position") {
                    this._position();
                }
                if (key === "resizable") {
                    // currently resizable, becoming non-resizable
                    isResizable = uiDialog.is(":data(ui-resizable)");
                    if (isResizable && !value) {
                        uiDialog.resizable("destroy");
                    }
                    // currently resizable, changing handles
                    if (isResizable && typeof value === "string") {
                        uiDialog.resizable("option", "handles", value);
                    }
                    // currently non-resizable, becoming resizable
                    if (!isResizable && value !== false) {
                        this._makeResizable();
                    }
                }
                if (key === "title") {
                    this._title(this.uiDialogTitlebar.find(".ui-dialog-title"));
                }
            },
            _size: function() {
                // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
                // divs will both have width and height set, so we need to reset them
                var nonContentHeight, minContentHeight, maxContentHeight, options = this.options;
                // Reset content sizing
                this.element.show().css({
                    width: "auto",
                    minHeight: 0,
                    maxHeight: "none",
                    height: 0
                });
                if (options.minWidth > options.width) {
                    options.width = options.minWidth;
                }
                // reset wrapper sizing
                // determine the height of all the non-content elements
                nonContentHeight = this.uiDialog.css({
                    height: "auto",
                    width: options.width
                }).outerHeight();
                minContentHeight = Math.max(0, options.minHeight - nonContentHeight);
                maxContentHeight = typeof options.maxHeight === "number" ? Math.max(0, options.maxHeight - nonContentHeight) : "none";
                if (options.height === "auto") {
                    this.element.css({
                        minHeight: minContentHeight,
                        maxHeight: maxContentHeight,
                        height: "auto"
                    });
                } else {
                    this.element.height(Math.max(0, options.height - nonContentHeight));
                }
                if (this.uiDialog.is(":data(ui-resizable)")) {
                    this.uiDialog.resizable("option", "minHeight", this._minHeight());
                }
            },
            _blockFrames: function() {
                this.iframeBlocks = this.document.find("iframe").map(function() {
                    var iframe = $(this);
                    return $("<div>").css({
                        position: "absolute",
                        width: iframe.outerWidth(),
                        height: iframe.outerHeight()
                    }).appendTo(iframe.parent()).offset(iframe.offset())[0];
                });
            },
            _unblockFrames: function() {
                if (this.iframeBlocks) {
                    this.iframeBlocks.remove();
                    delete this.iframeBlocks;
                }
            },
            _allowInteraction: function(event) {
                if ($(event.target).closest(".ui-dialog").length) {
                    return true;
                }
                // TODO: Remove hack when datepicker implements
                // the .ui-front logic (#8989)
                return !!$(event.target).closest(".ui-datepicker").length;
            },
            _createOverlay: function() {
                if (!this.options.modal) {
                    return;
                }
                var that = this, widgetFullName = this.widgetFullName;
                if (!$.ui.dialog.overlayInstances) {
                    // Prevent use of anchors and inputs.
                    // We use a delay in case the overlay is created from an
                    // event that we're going to be cancelling. (#2804)
                    this._delay(function() {
                        // Handle .dialog().dialog("close") (#4065)
                        if ($.ui.dialog.overlayInstances) {
                            this.document.bind("focusin.dialog", function(event) {
                                if (!that._allowInteraction(event)) {
                                    event.preventDefault();
                                    $(".ui-dialog:visible:last .ui-dialog-content").data(widgetFullName)._focusTabbable();
                                }
                            });
                        }
                    });
                }
                this.overlay = $("<div>").addClass("ui-widget-overlay ui-front").appendTo(this._appendTo());
                this._on(this.overlay, {
                    mousedown: "_keepFocus"
                });
                $.ui.dialog.overlayInstances++;
            },
            _destroyOverlay: function() {
                if (!this.options.modal) {
                    return;
                }
                if (this.overlay) {
                    $.ui.dialog.overlayInstances--;
                    if (!$.ui.dialog.overlayInstances) {
                        this.document.unbind("focusin.dialog");
                    }
                    this.overlay.remove();
                    this.overlay = null;
                }
            }
        });
        $.ui.dialog.overlayInstances = 0;
        // DEPRECATED
        if ($.uiBackCompat !== false) {
            // position option with array notation
            // just override with old implementation
            $.widget("ui.dialog", $.ui.dialog, {
                _position: function() {
                    var position = this.options.position, myAt = [], offset = [ 0, 0 ], isVisible;
                    if (position) {
                        if (typeof position === "string" || typeof position === "object" && "0" in position) {
                            myAt = position.split ? position.split(" ") : [ position[0], position[1] ];
                            if (myAt.length === 1) {
                                myAt[1] = myAt[0];
                            }
                            $.each([ "left", "top" ], function(i, offsetPosition) {
                                if (+myAt[i] === myAt[i]) {
                                    offset[i] = myAt[i];
                                    myAt[i] = offsetPosition;
                                }
                            });
                            position = {
                                my: myAt[0] + (offset[0] < 0 ? offset[0] : "+" + offset[0]) + " " + myAt[1] + (offset[1] < 0 ? offset[1] : "+" + offset[1]),
                                at: myAt.join(" ")
                            };
                        }
                        position = $.extend({}, $.ui.dialog.prototype.options.position, position);
                    } else {
                        position = $.ui.dialog.prototype.options.position;
                    }
                    // need to show the dialog to get the actual offset in the position plugin
                    isVisible = this.uiDialog.is(":visible");
                    if (!isVisible) {
                        this.uiDialog.show();
                    }
                    this.uiDialog.position(position);
                    if (!isVisible) {
                        this.uiDialog.hide();
                    }
                }
            });
        }
    })(jQuery);
    (function($, undefined) {
        var rvertical = /up|down|vertical/, rpositivemotion = /up|left|vertical|horizontal/;
        $.effects.effect.blind = function(o, done) {
            // Create element
            var el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "hide"), direction = o.direction || "up", vertical = rvertical.test(direction), ref = vertical ? "height" : "width", ref2 = vertical ? "top" : "left", motion = rpositivemotion.test(direction), animation = {}, show = mode === "show", wrapper, distance, margin;
            // if already wrapped, the wrapper's properties are my property. #6245
            if (el.parent().is(".ui-effects-wrapper")) {
                $.effects.save(el.parent(), props);
            } else {
                $.effects.save(el, props);
            }
            el.show();
            wrapper = $.effects.createWrapper(el).css({
                overflow: "hidden"
            });
            distance = wrapper[ref]();
            margin = parseFloat(wrapper.css(ref2)) || 0;
            animation[ref] = show ? distance : 0;
            if (!motion) {
                el.css(vertical ? "bottom" : "right", 0).css(vertical ? "top" : "left", "auto").css({
                    position: "absolute"
                });
                animation[ref2] = show ? margin : distance + margin;
            }
            // start at 0 if we are showing
            if (show) {
                wrapper.css(ref, 0);
                if (!motion) {
                    wrapper.css(ref2, margin + distance);
                }
            }
            // Animate
            wrapper.animate(animation, {
                duration: o.duration,
                easing: o.easing,
                queue: false,
                complete: function() {
                    if (mode === "hide") {
                        el.hide();
                    }
                    $.effects.restore(el, props);
                    $.effects.removeWrapper(el);
                    done();
                }
            });
        };
    })(jQuery);
    (function($, undefined) {
        $.effects.effect.bounce = function(o, done) {
            var el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], // defaults:
            mode = $.effects.setMode(el, o.mode || "effect"), hide = mode === "hide", show = mode === "show", direction = o.direction || "up", distance = o.distance, times = o.times || 5, // number of internal animations
            anims = times * 2 + (show || hide ? 1 : 0), speed = o.duration / anims, easing = o.easing, // utility:
            ref = direction === "up" || direction === "down" ? "top" : "left", motion = direction === "up" || direction === "left", i, upAnim, downAnim, // we will need to re-assemble the queue to stack our animations in place
            queue = el.queue(), queuelen = queue.length;
            // Avoid touching opacity to prevent clearType and PNG issues in IE
            if (show || hide) {
                props.push("opacity");
            }
            $.effects.save(el, props);
            el.show();
            $.effects.createWrapper(el);
            // Create Wrapper
            // default distance for the BIGGEST bounce is the outer Distance / 3
            if (!distance) {
                distance = el[ref === "top" ? "outerHeight" : "outerWidth"]() / 3;
            }
            if (show) {
                downAnim = {
                    opacity: 1
                };
                downAnim[ref] = 0;
                // if we are showing, force opacity 0 and set the initial position
                // then do the "first" animation
                el.css("opacity", 0).css(ref, motion ? -distance * 2 : distance * 2).animate(downAnim, speed, easing);
            }
            // start at the smallest distance if we are hiding
            if (hide) {
                distance = distance / Math.pow(2, times - 1);
            }
            downAnim = {};
            downAnim[ref] = 0;
            // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
            for (i = 0; i < times; i++) {
                upAnim = {};
                upAnim[ref] = (motion ? "-=" : "+=") + distance;
                el.animate(upAnim, speed, easing).animate(downAnim, speed, easing);
                distance = hide ? distance * 2 : distance / 2;
            }
            // Last Bounce when Hiding
            if (hide) {
                upAnim = {
                    opacity: 0
                };
                upAnim[ref] = (motion ? "-=" : "+=") + distance;
                el.animate(upAnim, speed, easing);
            }
            el.queue(function() {
                if (hide) {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            });
            // inject all the animations we just queued to be first in line (after "inprogress")
            if (queuelen > 1) {
                queue.splice.apply(queue, [ 1, 0 ].concat(queue.splice(queuelen, anims + 1)));
            }
            el.dequeue();
        };
    })(jQuery);
    (function($, undefined) {
        $.effects.effect.clip = function(o, done) {
            // Create element
            var el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "hide"), show = mode === "show", direction = o.direction || "vertical", vert = direction === "vertical", size = vert ? "height" : "width", position = vert ? "top" : "left", animation = {}, wrapper, animate, distance;
            // Save & Show
            $.effects.save(el, props);
            el.show();
            // Create Wrapper
            wrapper = $.effects.createWrapper(el).css({
                overflow: "hidden"
            });
            animate = el[0].tagName === "IMG" ? wrapper : el;
            distance = animate[size]();
            // Shift
            if (show) {
                animate.css(size, 0);
                animate.css(position, distance / 2);
            }
            // Create Animation Object:
            animation[size] = show ? distance : 0;
            animation[position] = show ? 0 : distance / 2;
            // Animate
            animate.animate(animation, {
                queue: false,
                duration: o.duration,
                easing: o.easing,
                complete: function() {
                    if (!show) {
                        el.hide();
                    }
                    $.effects.restore(el, props);
                    $.effects.removeWrapper(el);
                    done();
                }
            });
        };
    })(jQuery);
    (function($, undefined) {
        $.effects.effect.drop = function(o, done) {
            var el = $(this), props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ], mode = $.effects.setMode(el, o.mode || "hide"), show = mode === "show", direction = o.direction || "left", ref = direction === "up" || direction === "down" ? "top" : "left", motion = direction === "up" || direction === "left" ? "pos" : "neg", animation = {
                opacity: show ? 1 : 0
            }, distance;
            // Adjust
            $.effects.save(el, props);
            el.show();
            $.effects.createWrapper(el);
            distance = o.distance || el[ref === "top" ? "outerHeight" : "outerWidth"](true) / 2;
            if (show) {
                el.css("opacity", 0).css(ref, motion === "pos" ? -distance : distance);
            }
            // Animation
            animation[ref] = (show ? motion === "pos" ? "+=" : "-=" : motion === "pos" ? "-=" : "+=") + distance;
            // Animate
            el.animate(animation, {
                queue: false,
                duration: o.duration,
                easing: o.easing,
                complete: function() {
                    if (mode === "hide") {
                        el.hide();
                    }
                    $.effects.restore(el, props);
                    $.effects.removeWrapper(el);
                    done();
                }
            });
        };
    })(jQuery);
    (function($, undefined) {
        $.effects.effect.explode = function(o, done) {
            var rows = o.pieces ? Math.round(Math.sqrt(o.pieces)) : 3, cells = rows, el = $(this), mode = $.effects.setMode(el, o.mode || "hide"), show = mode === "show", // show and then visibility:hidden the element before calculating offset
            offset = el.show().css("visibility", "hidden").offset(), // width and height of a piece
            width = Math.ceil(el.outerWidth() / cells), height = Math.ceil(el.outerHeight() / rows), pieces = [], // loop
            i, j, left, top, mx, my;
            // children animate complete:
            function childComplete() {
                pieces.push(this);
                if (pieces.length === rows * cells) {
                    animComplete();
                }
            }
            // clone the element for each row and cell.
            for (i = 0; i < rows; i++) {
                // ===>
                top = offset.top + i * height;
                my = i - (rows - 1) / 2;
                for (j = 0; j < cells; j++) {
                    // |||
                    left = offset.left + j * width;
                    mx = j - (cells - 1) / 2;
                    // Create a clone of the now hidden main element that will be absolute positioned
                    // within a wrapper div off the -left and -top equal to size of our pieces
                    el.clone().appendTo("body").wrap("<div></div>").css({
                        position: "absolute",
                        visibility: "visible",
                        left: -j * width,
                        top: -i * height
                    }).parent().addClass("ui-effects-explode").css({
                        position: "absolute",
                        overflow: "hidden",
                        width: width,
                        height: height,
                        left: left + (show ? mx * width : 0),
                        top: top + (show ? my * height : 0),
                        opacity: show ? 0 : 1
                    }).animate({
                        left: left + (show ? 0 : mx * width),
                        top: top + (show ? 0 : my * height),
                        opacity: show ? 1 : 0
                    }, o.duration || 500, o.easing, childComplete);
                }
            }
            function animComplete() {
                el.css({
                    visibility: "visible"
                });
                $(pieces).remove();
                if (!show) {
                    el.hide();
                }
                done();
            }
        };
    })(jQuery);
    (function($, undefined) {
        $.effects.effect.fade = function(o, done) {
            var el = $(this), mode = $.effects.setMode(el, o.mode || "toggle");
            el.animate({
                opacity: mode
            }, {
                queue: false,
                duration: o.duration,
                easing: o.easing,
                complete: done
            });
        };
    })(jQuery);
    (function($, undefined) {
        $.effects.effect.fold = function(o, done) {
            // Create element
            var el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "hide"), show = mode === "show", hide = mode === "hide", size = o.size || 15, percent = /([0-9]+)%/.exec(size), horizFirst = !!o.horizFirst, widthFirst = show !== horizFirst, ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ], duration = o.duration / 2, wrapper, distance, animation1 = {}, animation2 = {};
            $.effects.save(el, props);
            el.show();
            // Create Wrapper
            wrapper = $.effects.createWrapper(el).css({
                overflow: "hidden"
            });
            distance = widthFirst ? [ wrapper.width(), wrapper.height() ] : [ wrapper.height(), wrapper.width() ];
            if (percent) {
                size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1];
            }
            if (show) {
                wrapper.css(horizFirst ? {
                    height: 0,
                    width: size
                } : {
                    height: size,
                    width: 0
                });
            }
            // Animation
            animation1[ref[0]] = show ? distance[0] : size;
            animation2[ref[1]] = show ? distance[1] : 0;
            // Animate
            wrapper.animate(animation1, duration, o.easing).animate(animation2, duration, o.easing, function() {
                if (hide) {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            });
        };
    })(jQuery);
    (function($, undefined) {
        $.effects.effect.highlight = function(o, done) {
            var elem = $(this), props = [ "backgroundImage", "backgroundColor", "opacity" ], mode = $.effects.setMode(elem, o.mode || "show"), animation = {
                backgroundColor: elem.css("backgroundColor")
            };
            if (mode === "hide") {
                animation.opacity = 0;
            }
            $.effects.save(elem, props);
            elem.show().css({
                backgroundImage: "none",
                backgroundColor: o.color || "#ffff99"
            }).animate(animation, {
                queue: false,
                duration: o.duration,
                easing: o.easing,
                complete: function() {
                    if (mode === "hide") {
                        elem.hide();
                    }
                    $.effects.restore(elem, props);
                    done();
                }
            });
        };
    })(jQuery);
    (function($, undefined) {
        $.effects.effect.pulsate = function(o, done) {
            var elem = $(this), mode = $.effects.setMode(elem, o.mode || "show"), show = mode === "show", hide = mode === "hide", showhide = show || mode === "hide", // showing or hiding leaves of the "last" animation
            anims = (o.times || 5) * 2 + (showhide ? 1 : 0), duration = o.duration / anims, animateTo = 0, queue = elem.queue(), queuelen = queue.length, i;
            if (show || !elem.is(":visible")) {
                elem.css("opacity", 0).show();
                animateTo = 1;
            }
            // anims - 1 opacity "toggles"
            for (i = 1; i < anims; i++) {
                elem.animate({
                    opacity: animateTo
                }, duration, o.easing);
                animateTo = 1 - animateTo;
            }
            elem.animate({
                opacity: animateTo
            }, duration, o.easing);
            elem.queue(function() {
                if (hide) {
                    elem.hide();
                }
                done();
            });
            // We just queued up "anims" animations, we need to put them next in the queue
            if (queuelen > 1) {
                queue.splice.apply(queue, [ 1, 0 ].concat(queue.splice(queuelen, anims + 1)));
            }
            elem.dequeue();
        };
    })(jQuery);
    (function($, undefined) {
        $.effects.effect.puff = function(o, done) {
            var elem = $(this), mode = $.effects.setMode(elem, o.mode || "hide"), hide = mode === "hide", percent = parseInt(o.percent, 10) || 150, factor = percent / 100, original = {
                height: elem.height(),
                width: elem.width(),
                outerHeight: elem.outerHeight(),
                outerWidth: elem.outerWidth()
            };
            $.extend(o, {
                effect: "scale",
                queue: false,
                fade: true,
                mode: mode,
                complete: done,
                percent: hide ? percent : 100,
                from: hide ? original : {
                    height: original.height * factor,
                    width: original.width * factor,
                    outerHeight: original.outerHeight * factor,
                    outerWidth: original.outerWidth * factor
                }
            });
            elem.effect(o);
        };
        $.effects.effect.scale = function(o, done) {
            // Create element
            var el = $(this), options = $.extend(true, {}, o), mode = $.effects.setMode(el, o.mode || "effect"), percent = parseInt(o.percent, 10) || (parseInt(o.percent, 10) === 0 ? 0 : mode === "hide" ? 0 : 100), direction = o.direction || "both", origin = o.origin, original = {
                height: el.height(),
                width: el.width(),
                outerHeight: el.outerHeight(),
                outerWidth: el.outerWidth()
            }, factor = {
                y: direction !== "horizontal" ? percent / 100 : 1,
                x: direction !== "vertical" ? percent / 100 : 1
            };
            // We are going to pass this effect to the size effect:
            options.effect = "size";
            options.queue = false;
            options.complete = done;
            // Set default origin and restore for show/hide
            if (mode !== "effect") {
                options.origin = origin || [ "middle", "center" ];
                options.restore = true;
            }
            options.from = o.from || (mode === "show" ? {
                height: 0,
                width: 0,
                outerHeight: 0,
                outerWidth: 0
            } : original);
            options.to = {
                height: original.height * factor.y,
                width: original.width * factor.x,
                outerHeight: original.outerHeight * factor.y,
                outerWidth: original.outerWidth * factor.x
            };
            // Fade option to support puff
            if (options.fade) {
                if (mode === "show") {
                    options.from.opacity = 0;
                    options.to.opacity = 1;
                }
                if (mode === "hide") {
                    options.from.opacity = 1;
                    options.to.opacity = 0;
                }
            }
            // Animate
            el.effect(options);
        };
        $.effects.effect.size = function(o, done) {
            // Create element
            var original, baseline, factor, el = $(this), props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ], // Always restore
            props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ], // Copy for children
            props2 = [ "width", "height", "overflow" ], cProps = [ "fontSize" ], vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ], hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ], // Set options
            mode = $.effects.setMode(el, o.mode || "effect"), restore = o.restore || mode !== "effect", scale = o.scale || "both", origin = o.origin || [ "middle", "center" ], position = el.css("position"), props = restore ? props0 : props1, zero = {
                height: 0,
                width: 0,
                outerHeight: 0,
                outerWidth: 0
            };
            if (mode === "show") {
                el.show();
            }
            original = {
                height: el.height(),
                width: el.width(),
                outerHeight: el.outerHeight(),
                outerWidth: el.outerWidth()
            };
            if (o.mode === "toggle" && mode === "show") {
                el.from = o.to || zero;
                el.to = o.from || original;
            } else {
                el.from = o.from || (mode === "show" ? zero : original);
                el.to = o.to || (mode === "hide" ? zero : original);
            }
            // Set scaling factor
            factor = {
                from: {
                    y: el.from.height / original.height,
                    x: el.from.width / original.width
                },
                to: {
                    y: el.to.height / original.height,
                    x: el.to.width / original.width
                }
            };
            // Scale the css box
            if (scale === "box" || scale === "both") {
                // Vertical props scaling
                if (factor.from.y !== factor.to.y) {
                    props = props.concat(vProps);
                    el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
                    el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
                }
                // Horizontal props scaling
                if (factor.from.x !== factor.to.x) {
                    props = props.concat(hProps);
                    el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
                    el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
                }
            }
            // Scale the content
            if (scale === "content" || scale === "both") {
                // Vertical props scaling
                if (factor.from.y !== factor.to.y) {
                    props = props.concat(cProps).concat(props2);
                    el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
                    el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
                }
            }
            $.effects.save(el, props);
            el.show();
            $.effects.createWrapper(el);
            el.css("overflow", "hidden").css(el.from);
            // Adjust
            if (origin) {
                // Calculate baseline shifts
                baseline = $.effects.getBaseline(origin, original);
                el.from.top = (original.outerHeight - el.outerHeight()) * baseline.y;
                el.from.left = (original.outerWidth - el.outerWidth()) * baseline.x;
                el.to.top = (original.outerHeight - el.to.outerHeight) * baseline.y;
                el.to.left = (original.outerWidth - el.to.outerWidth) * baseline.x;
            }
            el.css(el.from);
            // set top & left
            // Animate
            if (scale === "content" || scale === "both") {
                // Scale the children
                // Add margins/font-size
                vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
                hProps = hProps.concat([ "marginLeft", "marginRight" ]);
                props2 = props0.concat(vProps).concat(hProps);
                el.find("*[width]").each(function() {
                    var child = $(this), c_original = {
                        height: child.height(),
                        width: child.width(),
                        outerHeight: child.outerHeight(),
                        outerWidth: child.outerWidth()
                    };
                    if (restore) {
                        $.effects.save(child, props2);
                    }
                    child.from = {
                        height: c_original.height * factor.from.y,
                        width: c_original.width * factor.from.x,
                        outerHeight: c_original.outerHeight * factor.from.y,
                        outerWidth: c_original.outerWidth * factor.from.x
                    };
                    child.to = {
                        height: c_original.height * factor.to.y,
                        width: c_original.width * factor.to.x,
                        outerHeight: c_original.height * factor.to.y,
                        outerWidth: c_original.width * factor.to.x
                    };
                    // Vertical props scaling
                    if (factor.from.y !== factor.to.y) {
                        child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
                        child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
                    }
                    // Horizontal props scaling
                    if (factor.from.x !== factor.to.x) {
                        child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
                        child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
                    }
                    // Animate children
                    child.css(child.from);
                    child.animate(child.to, o.duration, o.easing, function() {
                        // Restore children
                        if (restore) {
                            $.effects.restore(child, props2);
                        }
                    });
                });
            }
            // Animate
            el.animate(el.to, {
                queue: false,
                duration: o.duration,
                easing: o.easing,
                complete: function() {
                    if (el.to.opacity === 0) {
                        el.css("opacity", el.from.opacity);
                    }
                    if (mode === "hide") {
                        el.hide();
                    }
                    $.effects.restore(el, props);
                    if (!restore) {
                        // we need to calculate our new positioning based on the scaling
                        if (position === "static") {
                            el.css({
                                position: "relative",
                                top: el.to.top,
                                left: el.to.left
                            });
                        } else {
                            $.each([ "top", "left" ], function(idx, pos) {
                                el.css(pos, function(_, str) {
                                    var val = parseInt(str, 10), toRef = idx ? el.to.left : el.to.top;
                                    // if original was "auto", recalculate the new value from wrapper
                                    if (str === "auto") {
                                        return toRef + "px";
                                    }
                                    return val + toRef + "px";
                                });
                            });
                        }
                    }
                    $.effects.removeWrapper(el);
                    done();
                }
            });
        };
    })(jQuery);
    (function($, undefined) {
        $.effects.effect.shake = function(o, done) {
            var el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "effect"), direction = o.direction || "left", distance = o.distance || 20, times = o.times || 3, anims = times * 2 + 1, speed = Math.round(o.duration / anims), ref = direction === "up" || direction === "down" ? "top" : "left", positiveMotion = direction === "up" || direction === "left", animation = {}, animation1 = {}, animation2 = {}, i, // we will need to re-assemble the queue to stack our animations in place
            queue = el.queue(), queuelen = queue.length;
            $.effects.save(el, props);
            el.show();
            $.effects.createWrapper(el);
            // Animation
            animation[ref] = (positiveMotion ? "-=" : "+=") + distance;
            animation1[ref] = (positiveMotion ? "+=" : "-=") + distance * 2;
            animation2[ref] = (positiveMotion ? "-=" : "+=") + distance * 2;
            // Animate
            el.animate(animation, speed, o.easing);
            // Shakes
            for (i = 1; i < times; i++) {
                el.animate(animation1, speed, o.easing).animate(animation2, speed, o.easing);
            }
            el.animate(animation1, speed, o.easing).animate(animation, speed / 2, o.easing).queue(function() {
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            });
            // inject all the animations we just queued to be first in line (after "inprogress")
            if (queuelen > 1) {
                queue.splice.apply(queue, [ 1, 0 ].concat(queue.splice(queuelen, anims + 1)));
            }
            el.dequeue();
        };
    })(jQuery);
    (function($, undefined) {
        $.effects.effect.slide = function(o, done) {
            // Create element
            var el = $(this), props = [ "position", "top", "bottom", "left", "right", "width", "height" ], mode = $.effects.setMode(el, o.mode || "show"), show = mode === "show", direction = o.direction || "left", ref = direction === "up" || direction === "down" ? "top" : "left", positiveMotion = direction === "up" || direction === "left", distance, animation = {};
            // Adjust
            $.effects.save(el, props);
            el.show();
            distance = o.distance || el[ref === "top" ? "outerHeight" : "outerWidth"](true);
            $.effects.createWrapper(el).css({
                overflow: "hidden"
            });
            if (show) {
                el.css(ref, positiveMotion ? isNaN(distance) ? "-" + distance : -distance : distance);
            }
            // Animation
            animation[ref] = (show ? positiveMotion ? "+=" : "-=" : positiveMotion ? "-=" : "+=") + distance;
            // Animate
            el.animate(animation, {
                queue: false,
                duration: o.duration,
                easing: o.easing,
                complete: function() {
                    if (mode === "hide") {
                        el.hide();
                    }
                    $.effects.restore(el, props);
                    $.effects.removeWrapper(el);
                    done();
                }
            });
        };
    })(jQuery);
    (function($, undefined) {
        $.effects.effect.transfer = function(o, done) {
            var elem = $(this), target = $(o.to), targetFixed = target.css("position") === "fixed", body = $("body"), fixTop = targetFixed ? body.scrollTop() : 0, fixLeft = targetFixed ? body.scrollLeft() : 0, endPosition = target.offset(), animation = {
                top: endPosition.top - fixTop,
                left: endPosition.left - fixLeft,
                height: target.innerHeight(),
                width: target.innerWidth()
            }, startPosition = elem.offset(), transfer = $("<div class='ui-effects-transfer'></div>").appendTo(document.body).addClass(o.className).css({
                top: startPosition.top - fixTop,
                left: startPosition.left - fixLeft,
                height: elem.innerHeight(),
                width: elem.innerWidth(),
                position: targetFixed ? "fixed" : "absolute"
            }).animate(animation, o.duration, o.easing, function() {
                transfer.remove();
                done();
            });
        };
    })(jQuery);
    (function($, undefined) {
        $.widget("ui.menu", {
            version: "1.10.3",
            defaultElement: "<ul>",
            delay: 300,
            options: {
                icons: {
                    submenu: "ui-icon-carat-1-e"
                },
                menus: "ul",
                position: {
                    my: "left top",
                    at: "right top"
                },
                role: "menu",
                // callbacks
                blur: null,
                focus: null,
                select: null
            },
            _create: function() {
                this.activeMenu = this.element;
                // flag used to prevent firing of the click handler
                // as the event bubbles up through nested menus
                this.mouseHandled = false;
                this.element.uniqueId().addClass("ui-menu ui-widget ui-widget-content ui-corner-all").toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length).attr({
                    role: this.options.role,
                    tabIndex: 0
                }).bind("click" + this.eventNamespace, $.proxy(function(event) {
                    if (this.options.disabled) {
                        event.preventDefault();
                    }
                }, this));
                if (this.options.disabled) {
                    this.element.addClass("ui-state-disabled").attr("aria-disabled", "true");
                }
                this._on({
                    // Prevent focus from sticking to links inside menu after clicking
                    // them (focus should always stay on UL during navigation).
                    "mousedown .ui-menu-item > a": function(event) {
                        event.preventDefault();
                    },
                    "click .ui-state-disabled > a": function(event) {
                        event.preventDefault();
                    },
                    "click .ui-menu-item:has(a)": function(event) {
                        var target = $(event.target).closest(".ui-menu-item");
                        if (!this.mouseHandled && target.not(".ui-state-disabled").length) {
                            this.mouseHandled = true;
                            this.select(event);
                            // Open submenu on click
                            if (target.has(".ui-menu").length) {
                                this.expand(event);
                            } else if (!this.element.is(":focus")) {
                                // Redirect focus to the menu
                                this.element.trigger("focus", [ true ]);
                                // If the active item is on the top level, let it stay active.
                                // Otherwise, blur the active item since it is no longer visible.
                                if (this.active && this.active.parents(".ui-menu").length === 1) {
                                    clearTimeout(this.timer);
                                }
                            }
                        }
                    },
                    "mouseenter .ui-menu-item": function(event) {
                        var target = $(event.currentTarget);
                        // Remove ui-state-active class from siblings of the newly focused menu item
                        // to avoid a jump caused by adjacent elements both having a class with a border
                        target.siblings().children(".ui-state-active").removeClass("ui-state-active");
                        this.focus(event, target);
                    },
                    mouseleave: "collapseAll",
                    "mouseleave .ui-menu": "collapseAll",
                    focus: function(event, keepActiveItem) {
                        // If there's already an active item, keep it active
                        // If not, activate the first item
                        var item = this.active || this.element.children(".ui-menu-item").eq(0);
                        if (!keepActiveItem) {
                            this.focus(event, item);
                        }
                    },
                    blur: function(event) {
                        this._delay(function() {
                            if (!$.contains(this.element[0], this.document[0].activeElement)) {
                                this.collapseAll(event);
                            }
                        });
                    },
                    keydown: "_keydown"
                });
                this.refresh();
                // Clicks outside of a menu collapse any open menus
                this._on(this.document, {
                    click: function(event) {
                        if (!$(event.target).closest(".ui-menu").length) {
                            this.collapseAll(event);
                        }
                        // Reset the mouseHandled flag
                        this.mouseHandled = false;
                    }
                });
            },
            _destroy: function() {
                // Destroy (sub)menus
                this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeClass("ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons").removeAttr("role").removeAttr("tabIndex").removeAttr("aria-labelledby").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-disabled").removeUniqueId().show();
                // Destroy menu items
                this.element.find(".ui-menu-item").removeClass("ui-menu-item").removeAttr("role").removeAttr("aria-disabled").children("a").removeUniqueId().removeClass("ui-corner-all ui-state-hover").removeAttr("tabIndex").removeAttr("role").removeAttr("aria-haspopup").children().each(function() {
                    var elem = $(this);
                    if (elem.data("ui-menu-submenu-carat")) {
                        elem.remove();
                    }
                });
                // Destroy menu dividers
                this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content");
            },
            _keydown: function(event) {
                /*jshint maxcomplexity:20*/
                var match, prev, character, skip, regex, preventDefault = true;
                function escape(value) {
                    return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
                }
                switch (event.keyCode) {
                  case $.ui.keyCode.PAGE_UP:
                    this.previousPage(event);
                    break;

                  case $.ui.keyCode.PAGE_DOWN:
                    this.nextPage(event);
                    break;

                  case $.ui.keyCode.HOME:
                    this._move("first", "first", event);
                    break;

                  case $.ui.keyCode.END:
                    this._move("last", "last", event);
                    break;

                  case $.ui.keyCode.UP:
                    this.previous(event);
                    break;

                  case $.ui.keyCode.DOWN:
                    this.next(event);
                    break;

                  case $.ui.keyCode.LEFT:
                    this.collapse(event);
                    break;

                  case $.ui.keyCode.RIGHT:
                    if (this.active && !this.active.is(".ui-state-disabled")) {
                        this.expand(event);
                    }
                    break;

                  case $.ui.keyCode.ENTER:
                  case $.ui.keyCode.SPACE:
                    this._activate(event);
                    break;

                  case $.ui.keyCode.ESCAPE:
                    this.collapse(event);
                    break;

                  default:
                    preventDefault = false;
                    prev = this.previousFilter || "";
                    character = String.fromCharCode(event.keyCode);
                    skip = false;
                    clearTimeout(this.filterTimer);
                    if (character === prev) {
                        skip = true;
                    } else {
                        character = prev + character;
                    }
                    regex = new RegExp("^" + escape(character), "i");
                    match = this.activeMenu.children(".ui-menu-item").filter(function() {
                        return regex.test($(this).children("a").text());
                    });
                    match = skip && match.index(this.active.next()) !== -1 ? this.active.nextAll(".ui-menu-item") : match;
                    // If no matches on the current filter, reset to the last character pressed
                    // to move down the menu to the first item that starts with that character
                    if (!match.length) {
                        character = String.fromCharCode(event.keyCode);
                        regex = new RegExp("^" + escape(character), "i");
                        match = this.activeMenu.children(".ui-menu-item").filter(function() {
                            return regex.test($(this).children("a").text());
                        });
                    }
                    if (match.length) {
                        this.focus(event, match);
                        if (match.length > 1) {
                            this.previousFilter = character;
                            this.filterTimer = this._delay(function() {
                                delete this.previousFilter;
                            }, 1e3);
                        } else {
                            delete this.previousFilter;
                        }
                    } else {
                        delete this.previousFilter;
                    }
                }
                if (preventDefault) {
                    event.preventDefault();
                }
            },
            _activate: function(event) {
                if (!this.active.is(".ui-state-disabled")) {
                    if (this.active.children("a[aria-haspopup='true']").length) {
                        this.expand(event);
                    } else {
                        this.select(event);
                    }
                }
            },
            refresh: function() {
                var menus, icon = this.options.icons.submenu, submenus = this.element.find(this.options.menus);
                // Initialize nested menus
                submenus.filter(":not(.ui-menu)").addClass("ui-menu ui-widget ui-widget-content ui-corner-all").hide().attr({
                    role: this.options.role,
                    "aria-hidden": "true",
                    "aria-expanded": "false"
                }).each(function() {
                    var menu = $(this), item = menu.prev("a"), submenuCarat = $("<span>").addClass("ui-menu-icon ui-icon " + icon).data("ui-menu-submenu-carat", true);
                    item.attr("aria-haspopup", "true").prepend(submenuCarat);
                    menu.attr("aria-labelledby", item.attr("id"));
                });
                menus = submenus.add(this.element);
                // Don't refresh list items that are already adapted
                menus.children(":not(.ui-menu-item):has(a)").addClass("ui-menu-item").attr("role", "presentation").children("a").uniqueId().addClass("ui-corner-all").attr({
                    tabIndex: -1,
                    role: this._itemRole()
                });
                // Initialize unlinked menu-items containing spaces and/or dashes only as dividers
                menus.children(":not(.ui-menu-item)").each(function() {
                    var item = $(this);
                    // hyphen, em dash, en dash
                    if (!/[^\-\u2014\u2013\s]/.test(item.text())) {
                        item.addClass("ui-widget-content ui-menu-divider");
                    }
                });
                // Add aria-disabled attribute to any disabled menu item
                menus.children(".ui-state-disabled").attr("aria-disabled", "true");
                // If the active item has been removed, blur the menu
                if (this.active && !$.contains(this.element[0], this.active[0])) {
                    this.blur();
                }
            },
            _itemRole: function() {
                return {
                    menu: "menuitem",
                    listbox: "option"
                }[this.options.role];
            },
            _setOption: function(key, value) {
                if (key === "icons") {
                    this.element.find(".ui-menu-icon").removeClass(this.options.icons.submenu).addClass(value.submenu);
                }
                this._super(key, value);
            },
            focus: function(event, item) {
                var nested, focused;
                this.blur(event, event && event.type === "focus");
                this._scrollIntoView(item);
                this.active = item.first();
                focused = this.active.children("a").addClass("ui-state-focus");
                // Only update aria-activedescendant if there's a role
                // otherwise we assume focus is managed elsewhere
                if (this.options.role) {
                    this.element.attr("aria-activedescendant", focused.attr("id"));
                }
                // Highlight active parent menu item, if any
                this.active.parent().closest(".ui-menu-item").children("a:first").addClass("ui-state-active");
                if (event && event.type === "keydown") {
                    this._close();
                } else {
                    this.timer = this._delay(function() {
                        this._close();
                    }, this.delay);
                }
                nested = item.children(".ui-menu");
                if (nested.length && /^mouse/.test(event.type)) {
                    this._startOpening(nested);
                }
                this.activeMenu = item.parent();
                this._trigger("focus", event, {
                    item: item
                });
            },
            _scrollIntoView: function(item) {
                var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
                if (this._hasScroll()) {
                    borderTop = parseFloat($.css(this.activeMenu[0], "borderTopWidth")) || 0;
                    paddingTop = parseFloat($.css(this.activeMenu[0], "paddingTop")) || 0;
                    offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
                    scroll = this.activeMenu.scrollTop();
                    elementHeight = this.activeMenu.height();
                    itemHeight = item.height();
                    if (offset < 0) {
                        this.activeMenu.scrollTop(scroll + offset);
                    } else if (offset + itemHeight > elementHeight) {
                        this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
                    }
                }
            },
            blur: function(event, fromFocus) {
                if (!fromFocus) {
                    clearTimeout(this.timer);
                }
                if (!this.active) {
                    return;
                }
                this.active.children("a").removeClass("ui-state-focus");
                this.active = null;
                this._trigger("blur", event, {
                    item: this.active
                });
            },
            _startOpening: function(submenu) {
                clearTimeout(this.timer);
                // Don't open if already open fixes a Firefox bug that caused a .5 pixel
                // shift in the submenu position when mousing over the carat icon
                if (submenu.attr("aria-hidden") !== "true") {
                    return;
                }
                this.timer = this._delay(function() {
                    this._close();
                    this._open(submenu);
                }, this.delay);
            },
            _open: function(submenu) {
                var position = $.extend({
                    of: this.active
                }, this.options.position);
                clearTimeout(this.timer);
                this.element.find(".ui-menu").not(submenu.parents(".ui-menu")).hide().attr("aria-hidden", "true");
                submenu.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(position);
            },
            collapseAll: function(event, all) {
                clearTimeout(this.timer);
                this.timer = this._delay(function() {
                    // If we were passed an event, look for the submenu that contains the event
                    var currentMenu = all ? this.element : $(event && event.target).closest(this.element.find(".ui-menu"));
                    // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
                    if (!currentMenu.length) {
                        currentMenu = this.element;
                    }
                    this._close(currentMenu);
                    this.blur(event);
                    this.activeMenu = currentMenu;
                }, this.delay);
            },
            // With no arguments, closes the currently active menu - if nothing is active
            // it closes all menus.  If passed an argument, it will search for menus BELOW
            _close: function(startMenu) {
                if (!startMenu) {
                    startMenu = this.active ? this.active.parent() : this.element;
                }
                startMenu.find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false").end().find("a.ui-state-active").removeClass("ui-state-active");
            },
            collapse: function(event) {
                var newItem = this.active && this.active.parent().closest(".ui-menu-item", this.element);
                if (newItem && newItem.length) {
                    this._close();
                    this.focus(event, newItem);
                }
            },
            expand: function(event) {
                var newItem = this.active && this.active.children(".ui-menu ").children(".ui-menu-item").first();
                if (newItem && newItem.length) {
                    this._open(newItem.parent());
                    // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
                    this._delay(function() {
                        this.focus(event, newItem);
                    });
                }
            },
            next: function(event) {
                this._move("next", "first", event);
            },
            previous: function(event) {
                this._move("prev", "last", event);
            },
            isFirstItem: function() {
                return this.active && !this.active.prevAll(".ui-menu-item").length;
            },
            isLastItem: function() {
                return this.active && !this.active.nextAll(".ui-menu-item").length;
            },
            _move: function(direction, filter, event) {
                var next;
                if (this.active) {
                    if (direction === "first" || direction === "last") {
                        next = this.active[direction === "first" ? "prevAll" : "nextAll"](".ui-menu-item").eq(-1);
                    } else {
                        next = this.active[direction + "All"](".ui-menu-item").eq(0);
                    }
                }
                if (!next || !next.length || !this.active) {
                    next = this.activeMenu.children(".ui-menu-item")[filter]();
                }
                this.focus(event, next);
            },
            nextPage: function(event) {
                var item, base, height;
                if (!this.active) {
                    this.next(event);
                    return;
                }
                if (this.isLastItem()) {
                    return;
                }
                if (this._hasScroll()) {
                    base = this.active.offset().top;
                    height = this.element.height();
                    this.active.nextAll(".ui-menu-item").each(function() {
                        item = $(this);
                        return item.offset().top - base - height < 0;
                    });
                    this.focus(event, item);
                } else {
                    this.focus(event, this.activeMenu.children(".ui-menu-item")[!this.active ? "first" : "last"]());
                }
            },
            previousPage: function(event) {
                var item, base, height;
                if (!this.active) {
                    this.next(event);
                    return;
                }
                if (this.isFirstItem()) {
                    return;
                }
                if (this._hasScroll()) {
                    base = this.active.offset().top;
                    height = this.element.height();
                    this.active.prevAll(".ui-menu-item").each(function() {
                        item = $(this);
                        return item.offset().top - base + height > 0;
                    });
                    this.focus(event, item);
                } else {
                    this.focus(event, this.activeMenu.children(".ui-menu-item").first());
                }
            },
            _hasScroll: function() {
                return this.element.outerHeight() < this.element.prop("scrollHeight");
            },
            select: function(event) {
                // TODO: It should never be possible to not have an active item at this
                // point, but the tests don't trigger mouseenter before click.
                this.active = this.active || $(event.target).closest(".ui-menu-item");
                var ui = {
                    item: this.active
                };
                if (!this.active.has(".ui-menu").length) {
                    this.collapseAll(event, true);
                }
                this._trigger("select", event, ui);
            }
        });
    })(jQuery);
    (function($, undefined) {
        $.ui = $.ui || {};
        var cachedScrollbarWidth, max = Math.max, abs = Math.abs, round = Math.round, rhorizontal = /left|center|right/, rvertical = /top|center|bottom/, roffset = /[\+\-]\d+(\.[\d]+)?%?/, rposition = /^\w+/, rpercent = /%$/, _position = $.fn.position;
        function getOffsets(offsets, width, height) {
            return [ parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1), parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1) ];
        }
        function parseCss(element, property) {
            return parseInt($.css(element, property), 10) || 0;
        }
        function getDimensions(elem) {
            var raw = elem[0];
            if (raw.nodeType === 9) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: {
                        top: 0,
                        left: 0
                    }
                };
            }
            if ($.isWindow(raw)) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: {
                        top: elem.scrollTop(),
                        left: elem.scrollLeft()
                    }
                };
            }
            if (raw.preventDefault) {
                return {
                    width: 0,
                    height: 0,
                    offset: {
                        top: raw.pageY,
                        left: raw.pageX
                    }
                };
            }
            return {
                width: elem.outerWidth(),
                height: elem.outerHeight(),
                offset: elem.offset()
            };
        }
        $.position = {
            scrollbarWidth: function() {
                if (cachedScrollbarWidth !== undefined) {
                    return cachedScrollbarWidth;
                }
                var w1, w2, div = $("<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"), innerDiv = div.children()[0];
                $("body").append(div);
                w1 = innerDiv.offsetWidth;
                div.css("overflow", "scroll");
                w2 = innerDiv.offsetWidth;
                if (w1 === w2) {
                    w2 = div[0].clientWidth;
                }
                div.remove();
                return cachedScrollbarWidth = w1 - w2;
            },
            getScrollInfo: function(within) {
                var overflowX = within.isWindow ? "" : within.element.css("overflow-x"), overflowY = within.isWindow ? "" : within.element.css("overflow-y"), hasOverflowX = overflowX === "scroll" || overflowX === "auto" && within.width < within.element[0].scrollWidth, hasOverflowY = overflowY === "scroll" || overflowY === "auto" && within.height < within.element[0].scrollHeight;
                return {
                    width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                    height: hasOverflowX ? $.position.scrollbarWidth() : 0
                };
            },
            getWithinInfo: function(element) {
                var withinElement = $(element || window), isWindow = $.isWindow(withinElement[0]);
                return {
                    element: withinElement,
                    isWindow: isWindow,
                    offset: withinElement.offset() || {
                        left: 0,
                        top: 0
                    },
                    scrollLeft: withinElement.scrollLeft(),
                    scrollTop: withinElement.scrollTop(),
                    width: isWindow ? withinElement.width() : withinElement.outerWidth(),
                    height: isWindow ? withinElement.height() : withinElement.outerHeight()
                };
            }
        };
        $.fn.position = function(options) {
            if (!options || !options.of) {
                return _position.apply(this, arguments);
            }
            // make a copy, we don't want to modify arguments
            options = $.extend({}, options);
            var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions, target = $(options.of), within = $.position.getWithinInfo(options.within), scrollInfo = $.position.getScrollInfo(within), collision = (options.collision || "flip").split(" "), offsets = {};
            dimensions = getDimensions(target);
            if (target[0].preventDefault) {
                // force left top to allow flipping
                options.at = "left top";
            }
            targetWidth = dimensions.width;
            targetHeight = dimensions.height;
            targetOffset = dimensions.offset;
            // clone to reuse original targetOffset later
            basePosition = $.extend({}, targetOffset);
            // force my and at to have valid horizontal and vertical positions
            // if a value is missing or invalid, it will be converted to center
            $.each([ "my", "at" ], function() {
                var pos = (options[this] || "").split(" "), horizontalOffset, verticalOffset;
                if (pos.length === 1) {
                    pos = rhorizontal.test(pos[0]) ? pos.concat([ "center" ]) : rvertical.test(pos[0]) ? [ "center" ].concat(pos) : [ "center", "center" ];
                }
                pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
                pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";
                // calculate offsets
                horizontalOffset = roffset.exec(pos[0]);
                verticalOffset = roffset.exec(pos[1]);
                offsets[this] = [ horizontalOffset ? horizontalOffset[0] : 0, verticalOffset ? verticalOffset[0] : 0 ];
                // reduce to just the positions without the offsets
                options[this] = [ rposition.exec(pos[0])[0], rposition.exec(pos[1])[0] ];
            });
            // normalize collision option
            if (collision.length === 1) {
                collision[1] = collision[0];
            }
            if (options.at[0] === "right") {
                basePosition.left += targetWidth;
            } else if (options.at[0] === "center") {
                basePosition.left += targetWidth / 2;
            }
            if (options.at[1] === "bottom") {
                basePosition.top += targetHeight;
            } else if (options.at[1] === "center") {
                basePosition.top += targetHeight / 2;
            }
            atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
            basePosition.left += atOffset[0];
            basePosition.top += atOffset[1];
            return this.each(function() {
                var collisionPosition, using, elem = $(this), elemWidth = elem.outerWidth(), elemHeight = elem.outerHeight(), marginLeft = parseCss(this, "marginLeft"), marginTop = parseCss(this, "marginTop"), collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width, collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height, position = $.extend({}, basePosition), myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());
                if (options.my[0] === "right") {
                    position.left -= elemWidth;
                } else if (options.my[0] === "center") {
                    position.left -= elemWidth / 2;
                }
                if (options.my[1] === "bottom") {
                    position.top -= elemHeight;
                } else if (options.my[1] === "center") {
                    position.top -= elemHeight / 2;
                }
                position.left += myOffset[0];
                position.top += myOffset[1];
                // if the browser doesn't support fractions, then round for consistent results
                if (!$.support.offsetFractions) {
                    position.left = round(position.left);
                    position.top = round(position.top);
                }
                collisionPosition = {
                    marginLeft: marginLeft,
                    marginTop: marginTop
                };
                $.each([ "left", "top" ], function(i, dir) {
                    if ($.ui.position[collision[i]]) {
                        $.ui.position[collision[i]][dir](position, {
                            targetWidth: targetWidth,
                            targetHeight: targetHeight,
                            elemWidth: elemWidth,
                            elemHeight: elemHeight,
                            collisionPosition: collisionPosition,
                            collisionWidth: collisionWidth,
                            collisionHeight: collisionHeight,
                            offset: [ atOffset[0] + myOffset[0], atOffset[1] + myOffset[1] ],
                            my: options.my,
                            at: options.at,
                            within: within,
                            elem: elem
                        });
                    }
                });
                if (options.using) {
                    // adds feedback as second argument to using callback, if present
                    using = function(props) {
                        var left = targetOffset.left - position.left, right = left + targetWidth - elemWidth, top = targetOffset.top - position.top, bottom = top + targetHeight - elemHeight, feedback = {
                            target: {
                                element: target,
                                left: targetOffset.left,
                                top: targetOffset.top,
                                width: targetWidth,
                                height: targetHeight
                            },
                            element: {
                                element: elem,
                                left: position.left,
                                top: position.top,
                                width: elemWidth,
                                height: elemHeight
                            },
                            horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                            vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                        };
                        if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
                            feedback.horizontal = "center";
                        }
                        if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
                            feedback.vertical = "middle";
                        }
                        if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
                            feedback.important = "horizontal";
                        } else {
                            feedback.important = "vertical";
                        }
                        options.using.call(this, props, feedback);
                    };
                }
                elem.offset($.extend(position, {
                    using: using
                }));
            });
        };
        $.ui.position = {
            fit: {
                left: function(position, data) {
                    var within = data.within, withinOffset = within.isWindow ? within.scrollLeft : within.offset.left, outerWidth = within.width, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = withinOffset - collisionPosLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset, newOverRight;
                    // element is wider than within
                    if (data.collisionWidth > outerWidth) {
                        // element is initially over the left side of within
                        if (overLeft > 0 && overRight <= 0) {
                            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                            position.left += overLeft - newOverRight;
                        } else if (overRight > 0 && overLeft <= 0) {
                            position.left = withinOffset;
                        } else {
                            if (overLeft > overRight) {
                                position.left = withinOffset + outerWidth - data.collisionWidth;
                            } else {
                                position.left = withinOffset;
                            }
                        }
                    } else if (overLeft > 0) {
                        position.left += overLeft;
                    } else if (overRight > 0) {
                        position.left -= overRight;
                    } else {
                        position.left = max(position.left - collisionPosLeft, position.left);
                    }
                },
                top: function(position, data) {
                    var within = data.within, withinOffset = within.isWindow ? within.scrollTop : within.offset.top, outerHeight = data.within.height, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = withinOffset - collisionPosTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset, newOverBottom;
                    // element is taller than within
                    if (data.collisionHeight > outerHeight) {
                        // element is initially over the top of within
                        if (overTop > 0 && overBottom <= 0) {
                            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                            position.top += overTop - newOverBottom;
                        } else if (overBottom > 0 && overTop <= 0) {
                            position.top = withinOffset;
                        } else {
                            if (overTop > overBottom) {
                                position.top = withinOffset + outerHeight - data.collisionHeight;
                            } else {
                                position.top = withinOffset;
                            }
                        }
                    } else if (overTop > 0) {
                        position.top += overTop;
                    } else if (overBottom > 0) {
                        position.top -= overBottom;
                    } else {
                        position.top = max(position.top - collisionPosTop, position.top);
                    }
                }
            },
            flip: {
                left: function(position, data) {
                    var within = data.within, withinOffset = within.offset.left + within.scrollLeft, outerWidth = within.width, offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = collisionPosLeft - offsetLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft, myOffset = data.my[0] === "left" ? -data.elemWidth : data.my[0] === "right" ? data.elemWidth : 0, atOffset = data.at[0] === "left" ? data.targetWidth : data.at[0] === "right" ? -data.targetWidth : 0, offset = -2 * data.offset[0], newOverRight, newOverLeft;
                    if (overLeft < 0) {
                        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
                        if (newOverRight < 0 || newOverRight < abs(overLeft)) {
                            position.left += myOffset + atOffset + offset;
                        }
                    } else if (overRight > 0) {
                        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
                        if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
                            position.left += myOffset + atOffset + offset;
                        }
                    }
                },
                top: function(position, data) {
                    var within = data.within, withinOffset = within.offset.top + within.scrollTop, outerHeight = within.height, offsetTop = within.isWindow ? within.scrollTop : within.offset.top, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = collisionPosTop - offsetTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop, top = data.my[1] === "top", myOffset = top ? -data.elemHeight : data.my[1] === "bottom" ? data.elemHeight : 0, atOffset = data.at[1] === "top" ? data.targetHeight : data.at[1] === "bottom" ? -data.targetHeight : 0, offset = -2 * data.offset[1], newOverTop, newOverBottom;
                    if (overTop < 0) {
                        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                        if (position.top + myOffset + atOffset + offset > overTop && (newOverBottom < 0 || newOverBottom < abs(overTop))) {
                            position.top += myOffset + atOffset + offset;
                        }
                    } else if (overBottom > 0) {
                        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                        if (position.top + myOffset + atOffset + offset > overBottom && (newOverTop > 0 || abs(newOverTop) < overBottom)) {
                            position.top += myOffset + atOffset + offset;
                        }
                    }
                }
            },
            flipfit: {
                left: function() {
                    $.ui.position.flip.left.apply(this, arguments);
                    $.ui.position.fit.left.apply(this, arguments);
                },
                top: function() {
                    $.ui.position.flip.top.apply(this, arguments);
                    $.ui.position.fit.top.apply(this, arguments);
                }
            }
        };
        // fraction support test
        (function() {
            var testElement, testElementParent, testElementStyle, offsetLeft, i, body = document.getElementsByTagName("body")[0], div = document.createElement("div");
            //Create a "fake body" for testing based on method used in jQuery.support
            testElement = document.createElement(body ? "div" : "body");
            testElementStyle = {
                visibility: "hidden",
                width: 0,
                height: 0,
                border: 0,
                margin: 0,
                background: "none"
            };
            if (body) {
                $.extend(testElementStyle, {
                    position: "absolute",
                    left: "-1000px",
                    top: "-1000px"
                });
            }
            for (i in testElementStyle) {
                testElement.style[i] = testElementStyle[i];
            }
            testElement.appendChild(div);
            testElementParent = body || document.documentElement;
            testElementParent.insertBefore(testElement, testElementParent.firstChild);
            div.style.cssText = "position: absolute; left: 10.7432222px;";
            offsetLeft = $(div).offset().left;
            $.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;
            testElement.innerHTML = "";
            testElementParent.removeChild(testElement);
        })();
    })(jQuery);
    (function($, undefined) {
        $.widget("ui.progressbar", {
            version: "1.10.3",
            options: {
                max: 100,
                value: 0,
                change: null,
                complete: null
            },
            min: 0,
            _create: function() {
                // Constrain initial value
                this.oldValue = this.options.value = this._constrainedValue();
                this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({
                    // Only set static values, aria-valuenow and aria-valuemax are
                    // set inside _refreshValue()
                    role: "progressbar",
                    "aria-valuemin": this.min
                });
                this.valueDiv = $("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element);
                this._refreshValue();
            },
            _destroy: function() {
                this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow");
                this.valueDiv.remove();
            },
            value: function(newValue) {
                if (newValue === undefined) {
                    return this.options.value;
                }
                this.options.value = this._constrainedValue(newValue);
                this._refreshValue();
            },
            _constrainedValue: function(newValue) {
                if (newValue === undefined) {
                    newValue = this.options.value;
                }
                this.indeterminate = newValue === false;
                // sanitize value
                if (typeof newValue !== "number") {
                    newValue = 0;
                }
                return this.indeterminate ? false : Math.min(this.options.max, Math.max(this.min, newValue));
            },
            _setOptions: function(options) {
                // Ensure "value" option is set after other values (like max)
                var value = options.value;
                delete options.value;
                this._super(options);
                this.options.value = this._constrainedValue(value);
                this._refreshValue();
            },
            _setOption: function(key, value) {
                if (key === "max") {
                    // Don't allow a max less than min
                    value = Math.max(this.min, value);
                }
                this._super(key, value);
            },
            _percentage: function() {
                return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);
            },
            _refreshValue: function() {
                var value = this.options.value, percentage = this._percentage();
                this.valueDiv.toggle(this.indeterminate || value > this.min).toggleClass("ui-corner-right", value === this.options.max).width(percentage.toFixed(0) + "%");
                this.element.toggleClass("ui-progressbar-indeterminate", this.indeterminate);
                if (this.indeterminate) {
                    this.element.removeAttr("aria-valuenow");
                    if (!this.overlayDiv) {
                        this.overlayDiv = $("<div class='ui-progressbar-overlay'></div>").appendTo(this.valueDiv);
                    }
                } else {
                    this.element.attr({
                        "aria-valuemax": this.options.max,
                        "aria-valuenow": value
                    });
                    if (this.overlayDiv) {
                        this.overlayDiv.remove();
                        this.overlayDiv = null;
                    }
                }
                if (this.oldValue !== value) {
                    this.oldValue = value;
                    this._trigger("change");
                }
                if (value === this.options.max) {
                    this._trigger("complete");
                }
            }
        });
    })(jQuery);
    (function($, undefined) {
        // number of pages in a slider
        // (how many times can you page up/down to go through the whole range)
        var numPages = 5;
        $.widget("ui.slider", $.ui.mouse, {
            version: "1.10.3",
            widgetEventPrefix: "slide",
            options: {
                animate: false,
                distance: 0,
                max: 100,
                min: 0,
                orientation: "horizontal",
                range: false,
                step: 1,
                value: 0,
                values: null,
                // callbacks
                change: null,
                slide: null,
                start: null,
                stop: null
            },
            _create: function() {
                this._keySliding = false;
                this._mouseSliding = false;
                this._animateOff = true;
                this._handleIndex = null;
                this._detectOrientation();
                this._mouseInit();
                this.element.addClass("ui-slider" + " ui-slider-" + this.orientation + " ui-widget" + " ui-widget-content" + " ui-corner-all");
                this._refresh();
                this._setOption("disabled", this.options.disabled);
                this._animateOff = false;
            },
            _refresh: function() {
                this._createRange();
                this._createHandles();
                this._setupEvents();
                this._refreshValue();
            },
            _createHandles: function() {
                var i, handleCount, options = this.options, existingHandles = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"), handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>", handles = [];
                handleCount = options.values && options.values.length || 1;
                if (existingHandles.length > handleCount) {
                    existingHandles.slice(handleCount).remove();
                    existingHandles = existingHandles.slice(0, handleCount);
                }
                for (i = existingHandles.length; i < handleCount; i++) {
                    handles.push(handle);
                }
                this.handles = existingHandles.add($(handles.join("")).appendTo(this.element));
                this.handle = this.handles.eq(0);
                this.handles.each(function(i) {
                    $(this).data("ui-slider-handle-index", i);
                });
            },
            _createRange: function() {
                var options = this.options, classes = "";
                if (options.range) {
                    if (options.range === true) {
                        if (!options.values) {
                            options.values = [ this._valueMin(), this._valueMin() ];
                        } else if (options.values.length && options.values.length !== 2) {
                            options.values = [ options.values[0], options.values[0] ];
                        } else if ($.isArray(options.values)) {
                            options.values = options.values.slice(0);
                        }
                    }
                    if (!this.range || !this.range.length) {
                        this.range = $("<div></div>").appendTo(this.element);
                        classes = "ui-slider-range" + // note: this isn't the most fittingly semantic framework class for this element,
                        // but worked best visually with a variety of themes
                        " ui-widget-header ui-corner-all";
                    } else {
                        this.range.removeClass("ui-slider-range-min ui-slider-range-max").css({
                            left: "",
                            bottom: ""
                        });
                    }
                    this.range.addClass(classes + (options.range === "min" || options.range === "max" ? " ui-slider-range-" + options.range : ""));
                } else {
                    this.range = $([]);
                }
            },
            _setupEvents: function() {
                var elements = this.handles.add(this.range).filter("a");
                this._off(elements);
                this._on(elements, this._handleEvents);
                this._hoverable(elements);
                this._focusable(elements);
            },
            _destroy: function() {
                this.handles.remove();
                this.range.remove();
                this.element.removeClass("ui-slider" + " ui-slider-horizontal" + " ui-slider-vertical" + " ui-widget" + " ui-widget-content" + " ui-corner-all");
                this._mouseDestroy();
            },
            _mouseCapture: function(event) {
                var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle, that = this, o = this.options;
                if (o.disabled) {
                    return false;
                }
                this.elementSize = {
                    width: this.element.outerWidth(),
                    height: this.element.outerHeight()
                };
                this.elementOffset = this.element.offset();
                position = {
                    x: event.pageX,
                    y: event.pageY
                };
                normValue = this._normValueFromMouse(position);
                distance = this._valueMax() - this._valueMin() + 1;
                this.handles.each(function(i) {
                    var thisDistance = Math.abs(normValue - that.values(i));
                    if (distance > thisDistance || distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min)) {
                        distance = thisDistance;
                        closestHandle = $(this);
                        index = i;
                    }
                });
                allowed = this._start(event, index);
                if (allowed === false) {
                    return false;
                }
                this._mouseSliding = true;
                this._handleIndex = index;
                closestHandle.addClass("ui-state-active").focus();
                offset = closestHandle.offset();
                mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle");
                this._clickOffset = mouseOverHandle ? {
                    left: 0,
                    top: 0
                } : {
                    left: event.pageX - offset.left - closestHandle.width() / 2,
                    top: event.pageY - offset.top - closestHandle.height() / 2 - (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) - (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) + (parseInt(closestHandle.css("marginTop"), 10) || 0)
                };
                if (!this.handles.hasClass("ui-state-hover")) {
                    this._slide(event, index, normValue);
                }
                this._animateOff = true;
                return true;
            },
            _mouseStart: function() {
                return true;
            },
            _mouseDrag: function(event) {
                var position = {
                    x: event.pageX,
                    y: event.pageY
                }, normValue = this._normValueFromMouse(position);
                this._slide(event, this._handleIndex, normValue);
                return false;
            },
            _mouseStop: function(event) {
                this.handles.removeClass("ui-state-active");
                this._mouseSliding = false;
                this._stop(event, this._handleIndex);
                this._change(event, this._handleIndex);
                this._handleIndex = null;
                this._clickOffset = null;
                this._animateOff = false;
                return false;
            },
            _detectOrientation: function() {
                this.orientation = this.options.orientation === "vertical" ? "vertical" : "horizontal";
            },
            _normValueFromMouse: function(position) {
                var pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse;
                if (this.orientation === "horizontal") {
                    pixelTotal = this.elementSize.width;
                    pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
                } else {
                    pixelTotal = this.elementSize.height;
                    pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
                }
                percentMouse = pixelMouse / pixelTotal;
                if (percentMouse > 1) {
                    percentMouse = 1;
                }
                if (percentMouse < 0) {
                    percentMouse = 0;
                }
                if (this.orientation === "vertical") {
                    percentMouse = 1 - percentMouse;
                }
                valueTotal = this._valueMax() - this._valueMin();
                valueMouse = this._valueMin() + percentMouse * valueTotal;
                return this._trimAlignValue(valueMouse);
            },
            _start: function(event, index) {
                var uiHash = {
                    handle: this.handles[index],
                    value: this.value()
                };
                if (this.options.values && this.options.values.length) {
                    uiHash.value = this.values(index);
                    uiHash.values = this.values();
                }
                return this._trigger("start", event, uiHash);
            },
            _slide: function(event, index, newVal) {
                var otherVal, newValues, allowed;
                if (this.options.values && this.options.values.length) {
                    otherVal = this.values(index ? 0 : 1);
                    if (this.options.values.length === 2 && this.options.range === true && (index === 0 && newVal > otherVal || index === 1 && newVal < otherVal)) {
                        newVal = otherVal;
                    }
                    if (newVal !== this.values(index)) {
                        newValues = this.values();
                        newValues[index] = newVal;
                        // A slide can be canceled by returning false from the slide callback
                        allowed = this._trigger("slide", event, {
                            handle: this.handles[index],
                            value: newVal,
                            values: newValues
                        });
                        otherVal = this.values(index ? 0 : 1);
                        if (allowed !== false) {
                            this.values(index, newVal, true);
                        }
                    }
                } else {
                    if (newVal !== this.value()) {
                        // A slide can be canceled by returning false from the slide callback
                        allowed = this._trigger("slide", event, {
                            handle: this.handles[index],
                            value: newVal
                        });
                        if (allowed !== false) {
                            this.value(newVal);
                        }
                    }
                }
            },
            _stop: function(event, index) {
                var uiHash = {
                    handle: this.handles[index],
                    value: this.value()
                };
                if (this.options.values && this.options.values.length) {
                    uiHash.value = this.values(index);
                    uiHash.values = this.values();
                }
                this._trigger("stop", event, uiHash);
            },
            _change: function(event, index) {
                if (!this._keySliding && !this._mouseSliding) {
                    var uiHash = {
                        handle: this.handles[index],
                        value: this.value()
                    };
                    if (this.options.values && this.options.values.length) {
                        uiHash.value = this.values(index);
                        uiHash.values = this.values();
                    }
                    //store the last changed value index for reference when handles overlap
                    this._lastChangedValue = index;
                    this._trigger("change", event, uiHash);
                }
            },
            value: function(newValue) {
                if (arguments.length) {
                    this.options.value = this._trimAlignValue(newValue);
                    this._refreshValue();
                    this._change(null, 0);
                    return;
                }
                return this._value();
            },
            values: function(index, newValue) {
                var vals, newValues, i;
                if (arguments.length > 1) {
                    this.options.values[index] = this._trimAlignValue(newValue);
                    this._refreshValue();
                    this._change(null, index);
                    return;
                }
                if (arguments.length) {
                    if ($.isArray(arguments[0])) {
                        vals = this.options.values;
                        newValues = arguments[0];
                        for (i = 0; i < vals.length; i += 1) {
                            vals[i] = this._trimAlignValue(newValues[i]);
                            this._change(null, i);
                        }
                        this._refreshValue();
                    } else {
                        if (this.options.values && this.options.values.length) {
                            return this._values(index);
                        } else {
                            return this.value();
                        }
                    }
                } else {
                    return this._values();
                }
            },
            _setOption: function(key, value) {
                var i, valsLength = 0;
                if (key === "range" && this.options.range === true) {
                    if (value === "min") {
                        this.options.value = this._values(0);
                        this.options.values = null;
                    } else if (value === "max") {
                        this.options.value = this._values(this.options.values.length - 1);
                        this.options.values = null;
                    }
                }
                if ($.isArray(this.options.values)) {
                    valsLength = this.options.values.length;
                }
                $.Widget.prototype._setOption.apply(this, arguments);
                switch (key) {
                  case "orientation":
                    this._detectOrientation();
                    this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-" + this.orientation);
                    this._refreshValue();
                    break;

                  case "value":
                    this._animateOff = true;
                    this._refreshValue();
                    this._change(null, 0);
                    this._animateOff = false;
                    break;

                  case "values":
                    this._animateOff = true;
                    this._refreshValue();
                    for (i = 0; i < valsLength; i += 1) {
                        this._change(null, i);
                    }
                    this._animateOff = false;
                    break;

                  case "min":
                  case "max":
                    this._animateOff = true;
                    this._refreshValue();
                    this._animateOff = false;
                    break;

                  case "range":
                    this._animateOff = true;
                    this._refresh();
                    this._animateOff = false;
                    break;
                }
            },
            //internal value getter
            // _value() returns value trimmed by min and max, aligned by step
            _value: function() {
                var val = this.options.value;
                val = this._trimAlignValue(val);
                return val;
            },
            //internal values getter
            // _values() returns array of values trimmed by min and max, aligned by step
            // _values( index ) returns single value trimmed by min and max, aligned by step
            _values: function(index) {
                var val, vals, i;
                if (arguments.length) {
                    val = this.options.values[index];
                    val = this._trimAlignValue(val);
                    return val;
                } else if (this.options.values && this.options.values.length) {
                    // .slice() creates a copy of the array
                    // this copy gets trimmed by min and max and then returned
                    vals = this.options.values.slice();
                    for (i = 0; i < vals.length; i += 1) {
                        vals[i] = this._trimAlignValue(vals[i]);
                    }
                    return vals;
                } else {
                    return [];
                }
            },
            // returns the step-aligned value that val is closest to, between (inclusive) min and max
            _trimAlignValue: function(val) {
                if (val <= this._valueMin()) {
                    return this._valueMin();
                }
                if (val >= this._valueMax()) {
                    return this._valueMax();
                }
                var step = this.options.step > 0 ? this.options.step : 1, valModStep = (val - this._valueMin()) % step, alignValue = val - valModStep;
                if (Math.abs(valModStep) * 2 >= step) {
                    alignValue += valModStep > 0 ? step : -step;
                }
                // Since JavaScript has problems with large floats, round
                // the final value to 5 digits after the decimal point (see #4124)
                return parseFloat(alignValue.toFixed(5));
            },
            _valueMin: function() {
                return this.options.min;
            },
            _valueMax: function() {
                return this.options.max;
            },
            _refreshValue: function() {
                var lastValPercent, valPercent, value, valueMin, valueMax, oRange = this.options.range, o = this.options, that = this, animate = !this._animateOff ? o.animate : false, _set = {};
                if (this.options.values && this.options.values.length) {
                    this.handles.each(function(i) {
                        valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
                        _set[that.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                        $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
                        if (that.options.range === true) {
                            if (that.orientation === "horizontal") {
                                if (i === 0) {
                                    that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                        left: valPercent + "%"
                                    }, o.animate);
                                }
                                if (i === 1) {
                                    that.range[animate ? "animate" : "css"]({
                                        width: valPercent - lastValPercent + "%"
                                    }, {
                                        queue: false,
                                        duration: o.animate
                                    });
                                }
                            } else {
                                if (i === 0) {
                                    that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                        bottom: valPercent + "%"
                                    }, o.animate);
                                }
                                if (i === 1) {
                                    that.range[animate ? "animate" : "css"]({
                                        height: valPercent - lastValPercent + "%"
                                    }, {
                                        queue: false,
                                        duration: o.animate
                                    });
                                }
                            }
                        }
                        lastValPercent = valPercent;
                    });
                } else {
                    value = this.value();
                    valueMin = this._valueMin();
                    valueMax = this._valueMax();
                    valPercent = valueMax !== valueMin ? (value - valueMin) / (valueMax - valueMin) * 100 : 0;
                    _set[this.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                    this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
                    if (oRange === "min" && this.orientation === "horizontal") {
                        this.range.stop(1, 1)[animate ? "animate" : "css"]({
                            width: valPercent + "%"
                        }, o.animate);
                    }
                    if (oRange === "max" && this.orientation === "horizontal") {
                        this.range[animate ? "animate" : "css"]({
                            width: 100 - valPercent + "%"
                        }, {
                            queue: false,
                            duration: o.animate
                        });
                    }
                    if (oRange === "min" && this.orientation === "vertical") {
                        this.range.stop(1, 1)[animate ? "animate" : "css"]({
                            height: valPercent + "%"
                        }, o.animate);
                    }
                    if (oRange === "max" && this.orientation === "vertical") {
                        this.range[animate ? "animate" : "css"]({
                            height: 100 - valPercent + "%"
                        }, {
                            queue: false,
                            duration: o.animate
                        });
                    }
                }
            },
            _handleEvents: {
                keydown: function(event) {
                    /*jshint maxcomplexity:25*/
                    var allowed, curVal, newVal, step, index = $(event.target).data("ui-slider-handle-index");
                    switch (event.keyCode) {
                      case $.ui.keyCode.HOME:
                      case $.ui.keyCode.END:
                      case $.ui.keyCode.PAGE_UP:
                      case $.ui.keyCode.PAGE_DOWN:
                      case $.ui.keyCode.UP:
                      case $.ui.keyCode.RIGHT:
                      case $.ui.keyCode.DOWN:
                      case $.ui.keyCode.LEFT:
                        event.preventDefault();
                        if (!this._keySliding) {
                            this._keySliding = true;
                            $(event.target).addClass("ui-state-active");
                            allowed = this._start(event, index);
                            if (allowed === false) {
                                return;
                            }
                        }
                        break;
                    }
                    step = this.options.step;
                    if (this.options.values && this.options.values.length) {
                        curVal = newVal = this.values(index);
                    } else {
                        curVal = newVal = this.value();
                    }
                    switch (event.keyCode) {
                      case $.ui.keyCode.HOME:
                        newVal = this._valueMin();
                        break;

                      case $.ui.keyCode.END:
                        newVal = this._valueMax();
                        break;

                      case $.ui.keyCode.PAGE_UP:
                        newVal = this._trimAlignValue(curVal + (this._valueMax() - this._valueMin()) / numPages);
                        break;

                      case $.ui.keyCode.PAGE_DOWN:
                        newVal = this._trimAlignValue(curVal - (this._valueMax() - this._valueMin()) / numPages);
                        break;

                      case $.ui.keyCode.UP:
                      case $.ui.keyCode.RIGHT:
                        if (curVal === this._valueMax()) {
                            return;
                        }
                        newVal = this._trimAlignValue(curVal + step);
                        break;

                      case $.ui.keyCode.DOWN:
                      case $.ui.keyCode.LEFT:
                        if (curVal === this._valueMin()) {
                            return;
                        }
                        newVal = this._trimAlignValue(curVal - step);
                        break;
                    }
                    this._slide(event, index, newVal);
                },
                click: function(event) {
                    event.preventDefault();
                },
                keyup: function(event) {
                    var index = $(event.target).data("ui-slider-handle-index");
                    if (this._keySliding) {
                        this._keySliding = false;
                        this._stop(event, index);
                        this._change(event, index);
                        $(event.target).removeClass("ui-state-active");
                    }
                }
            }
        });
    })(jQuery);
    (function($) {
        function modifier(fn) {
            return function() {
                var previous = this.element.val();
                fn.apply(this, arguments);
                this._refresh();
                if (previous !== this.element.val()) {
                    this._trigger("change");
                }
            };
        }
        $.widget("ui.spinner", {
            version: "1.10.3",
            defaultElement: "<input>",
            widgetEventPrefix: "spin",
            options: {
                culture: null,
                icons: {
                    down: "ui-icon-triangle-1-s",
                    up: "ui-icon-triangle-1-n"
                },
                incremental: true,
                max: null,
                min: null,
                numberFormat: null,
                page: 10,
                step: 1,
                change: null,
                spin: null,
                start: null,
                stop: null
            },
            _create: function() {
                // handle string values that need to be parsed
                this._setOption("max", this.options.max);
                this._setOption("min", this.options.min);
                this._setOption("step", this.options.step);
                // format the value, but don't constrain
                this._value(this.element.val(), true);
                this._draw();
                this._on(this._events);
                this._refresh();
                // turning off autocomplete prevents the browser from remembering the
                // value when navigating through history, so we re-enable autocomplete
                // if the page is unloaded before the widget is destroyed. #7790
                this._on(this.window, {
                    beforeunload: function() {
                        this.element.removeAttr("autocomplete");
                    }
                });
            },
            _getCreateOptions: function() {
                var options = {}, element = this.element;
                $.each([ "min", "max", "step" ], function(i, option) {
                    var value = element.attr(option);
                    if (value !== undefined && value.length) {
                        options[option] = value;
                    }
                });
                return options;
            },
            _events: {
                keydown: function(event) {
                    if (this._start(event) && this._keydown(event)) {
                        event.preventDefault();
                    }
                },
                keyup: "_stop",
                focus: function() {
                    this.previous = this.element.val();
                },
                blur: function(event) {
                    if (this.cancelBlur) {
                        delete this.cancelBlur;
                        return;
                    }
                    this._stop();
                    this._refresh();
                    if (this.previous !== this.element.val()) {
                        this._trigger("change", event);
                    }
                },
                mousewheel: function(event, delta) {
                    if (!delta) {
                        return;
                    }
                    if (!this.spinning && !this._start(event)) {
                        return false;
                    }
                    this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
                    clearTimeout(this.mousewheelTimer);
                    this.mousewheelTimer = this._delay(function() {
                        if (this.spinning) {
                            this._stop(event);
                        }
                    }, 100);
                    event.preventDefault();
                },
                "mousedown .ui-spinner-button": function(event) {
                    var previous;
                    // We never want the buttons to have focus; whenever the user is
                    // interacting with the spinner, the focus should be on the input.
                    // If the input is focused then this.previous is properly set from
                    // when the input first received focus. If the input is not focused
                    // then we need to set this.previous based on the value before spinning.
                    previous = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val();
                    function checkFocus() {
                        var isActive = this.element[0] === this.document[0].activeElement;
                        if (!isActive) {
                            this.element.focus();
                            this.previous = previous;
                            // support: IE
                            // IE sets focus asynchronously, so we need to check if focus
                            // moved off of the input because the user clicked on the button.
                            this._delay(function() {
                                this.previous = previous;
                            });
                        }
                    }
                    // ensure focus is on (or stays on) the text field
                    event.preventDefault();
                    checkFocus.call(this);
                    // support: IE
                    // IE doesn't prevent moving focus even with event.preventDefault()
                    // so we set a flag to know when we should ignore the blur event
                    // and check (again) if focus moved off of the input.
                    this.cancelBlur = true;
                    this._delay(function() {
                        delete this.cancelBlur;
                        checkFocus.call(this);
                    });
                    if (this._start(event) === false) {
                        return;
                    }
                    this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
                },
                "mouseup .ui-spinner-button": "_stop",
                "mouseenter .ui-spinner-button": function(event) {
                    // button will add ui-state-active if mouse was down while mouseleave and kept down
                    if (!$(event.currentTarget).hasClass("ui-state-active")) {
                        return;
                    }
                    if (this._start(event) === false) {
                        return false;
                    }
                    this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
                },
                // TODO: do we really want to consider this a stop?
                // shouldn't we just stop the repeater and wait until mouseup before
                // we trigger the stop event?
                "mouseleave .ui-spinner-button": "_stop"
            },
            _draw: function() {
                var uiSpinner = this.uiSpinner = this.element.addClass("ui-spinner-input").attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());
                this.element.attr("role", "spinbutton");
                // button bindings
                this.buttons = uiSpinner.find(".ui-spinner-button").attr("tabIndex", -1).button().removeClass("ui-corner-all");
                // IE 6 doesn't understand height: 50% for the buttons
                // unless the wrapper has an explicit height
                if (this.buttons.height() > Math.ceil(uiSpinner.height() * .5) && uiSpinner.height() > 0) {
                    uiSpinner.height(uiSpinner.height());
                }
                // disable spinner if element was already disabled
                if (this.options.disabled) {
                    this.disable();
                }
            },
            _keydown: function(event) {
                var options = this.options, keyCode = $.ui.keyCode;
                switch (event.keyCode) {
                  case keyCode.UP:
                    this._repeat(null, 1, event);
                    return true;

                  case keyCode.DOWN:
                    this._repeat(null, -1, event);
                    return true;

                  case keyCode.PAGE_UP:
                    this._repeat(null, options.page, event);
                    return true;

                  case keyCode.PAGE_DOWN:
                    this._repeat(null, -options.page, event);
                    return true;
                }
                return false;
            },
            _uiSpinnerHtml: function() {
                return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
            },
            _buttonHtml: function() {
                return "" + "<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" + "<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" + "</a>" + "<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" + "<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" + "</a>";
            },
            _start: function(event) {
                if (!this.spinning && this._trigger("start", event) === false) {
                    return false;
                }
                if (!this.counter) {
                    this.counter = 1;
                }
                this.spinning = true;
                return true;
            },
            _repeat: function(i, steps, event) {
                i = i || 500;
                clearTimeout(this.timer);
                this.timer = this._delay(function() {
                    this._repeat(40, steps, event);
                }, i);
                this._spin(steps * this.options.step, event);
            },
            _spin: function(step, event) {
                var value = this.value() || 0;
                if (!this.counter) {
                    this.counter = 1;
                }
                value = this._adjustValue(value + step * this._increment(this.counter));
                if (!this.spinning || this._trigger("spin", event, {
                    value: value
                }) !== false) {
                    this._value(value);
                    this.counter++;
                }
            },
            _increment: function(i) {
                var incremental = this.options.incremental;
                if (incremental) {
                    return $.isFunction(incremental) ? incremental(i) : Math.floor(i * i * i / 5e4 - i * i / 500 + 17 * i / 200 + 1);
                }
                return 1;
            },
            _precision: function() {
                var precision = this._precisionOf(this.options.step);
                if (this.options.min !== null) {
                    precision = Math.max(precision, this._precisionOf(this.options.min));
                }
                return precision;
            },
            _precisionOf: function(num) {
                var str = num.toString(), decimal = str.indexOf(".");
                return decimal === -1 ? 0 : str.length - decimal - 1;
            },
            _adjustValue: function(value) {
                var base, aboveMin, options = this.options;
                // make sure we're at a valid step
                // - find out where we are relative to the base (min or 0)
                base = options.min !== null ? options.min : 0;
                aboveMin = value - base;
                // - round to the nearest step
                aboveMin = Math.round(aboveMin / options.step) * options.step;
                // - rounding is based on 0, so adjust back to our base
                value = base + aboveMin;
                // fix precision from bad JS floating point math
                value = parseFloat(value.toFixed(this._precision()));
                // clamp the value
                if (options.max !== null && value > options.max) {
                    return options.max;
                }
                if (options.min !== null && value < options.min) {
                    return options.min;
                }
                return value;
            },
            _stop: function(event) {
                if (!this.spinning) {
                    return;
                }
                clearTimeout(this.timer);
                clearTimeout(this.mousewheelTimer);
                this.counter = 0;
                this.spinning = false;
                this._trigger("stop", event);
            },
            _setOption: function(key, value) {
                if (key === "culture" || key === "numberFormat") {
                    var prevValue = this._parse(this.element.val());
                    this.options[key] = value;
                    this.element.val(this._format(prevValue));
                    return;
                }
                if (key === "max" || key === "min" || key === "step") {
                    if (typeof value === "string") {
                        value = this._parse(value);
                    }
                }
                if (key === "icons") {
                    this.buttons.first().find(".ui-icon").removeClass(this.options.icons.up).addClass(value.up);
                    this.buttons.last().find(".ui-icon").removeClass(this.options.icons.down).addClass(value.down);
                }
                this._super(key, value);
                if (key === "disabled") {
                    if (value) {
                        this.element.prop("disabled", true);
                        this.buttons.button("disable");
                    } else {
                        this.element.prop("disabled", false);
                        this.buttons.button("enable");
                    }
                }
            },
            _setOptions: modifier(function(options) {
                this._super(options);
                this._value(this.element.val());
            }),
            _parse: function(val) {
                if (typeof val === "string" && val !== "") {
                    val = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(val, 10, this.options.culture) : +val;
                }
                return val === "" || isNaN(val) ? null : val;
            },
            _format: function(value) {
                if (value === "") {
                    return "";
                }
                return window.Globalize && this.options.numberFormat ? Globalize.format(value, this.options.numberFormat, this.options.culture) : value;
            },
            _refresh: function() {
                this.element.attr({
                    "aria-valuemin": this.options.min,
                    "aria-valuemax": this.options.max,
                    // TODO: what should we do with values that can't be parsed?
                    "aria-valuenow": this._parse(this.element.val())
                });
            },
            // update the value without triggering change
            _value: function(value, allowAny) {
                var parsed;
                if (value !== "") {
                    parsed = this._parse(value);
                    if (parsed !== null) {
                        if (!allowAny) {
                            parsed = this._adjustValue(parsed);
                        }
                        value = this._format(parsed);
                    }
                }
                this.element.val(value);
                this._refresh();
            },
            _destroy: function() {
                this.element.removeClass("ui-spinner-input").prop("disabled", false).removeAttr("autocomplete").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow");
                this.uiSpinner.replaceWith(this.element);
            },
            stepUp: modifier(function(steps) {
                this._stepUp(steps);
            }),
            _stepUp: function(steps) {
                if (this._start()) {
                    this._spin((steps || 1) * this.options.step);
                    this._stop();
                }
            },
            stepDown: modifier(function(steps) {
                this._stepDown(steps);
            }),
            _stepDown: function(steps) {
                if (this._start()) {
                    this._spin((steps || 1) * -this.options.step);
                    this._stop();
                }
            },
            pageUp: modifier(function(pages) {
                this._stepUp((pages || 1) * this.options.page);
            }),
            pageDown: modifier(function(pages) {
                this._stepDown((pages || 1) * this.options.page);
            }),
            value: function(newVal) {
                if (!arguments.length) {
                    return this._parse(this.element.val());
                }
                modifier(this._value).call(this, newVal);
            },
            widget: function() {
                return this.uiSpinner;
            }
        });
    })(jQuery);
    (function($, undefined) {
        var tabId = 0, rhash = /#.*$/;
        function getNextTabId() {
            return ++tabId;
        }
        function isLocal(anchor) {
            return anchor.hash.length > 1 && decodeURIComponent(anchor.href.replace(rhash, "")) === decodeURIComponent(location.href.replace(rhash, ""));
        }
        $.widget("ui.tabs", {
            version: "1.10.3",
            delay: 300,
            options: {
                active: null,
                collapsible: false,
                event: "click",
                heightStyle: "content",
                hide: null,
                show: null,
                // callbacks
                activate: null,
                beforeActivate: null,
                beforeLoad: null,
                load: null
            },
            _create: function() {
                var that = this, options = this.options;
                this.running = false;
                this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible", options.collapsible).delegate(".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function(event) {
                    if ($(this).is(".ui-state-disabled")) {
                        event.preventDefault();
                    }
                }).delegate(".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
                    if ($(this).closest("li").is(".ui-state-disabled")) {
                        this.blur();
                    }
                });
                this._processTabs();
                options.active = this._initialActive();
                // Take disabling tabs via class attribute from HTML
                // into account and update option properly.
                if ($.isArray(options.disabled)) {
                    options.disabled = $.unique(options.disabled.concat($.map(this.tabs.filter(".ui-state-disabled"), function(li) {
                        return that.tabs.index(li);
                    }))).sort();
                }
                // check for length avoids error when initializing empty list
                if (this.options.active !== false && this.anchors.length) {
                    this.active = this._findActive(options.active);
                } else {
                    this.active = $();
                }
                this._refresh();
                if (this.active.length) {
                    this.load(options.active);
                }
            },
            _initialActive: function() {
                var active = this.options.active, collapsible = this.options.collapsible, locationHash = location.hash.substring(1);
                if (active === null) {
                    // check the fragment identifier in the URL
                    if (locationHash) {
                        this.tabs.each(function(i, tab) {
                            if ($(tab).attr("aria-controls") === locationHash) {
                                active = i;
                                return false;
                            }
                        });
                    }
                    // check for a tab marked active via a class
                    if (active === null) {
                        active = this.tabs.index(this.tabs.filter(".ui-tabs-active"));
                    }
                    // no active tab, set to false
                    if (active === null || active === -1) {
                        active = this.tabs.length ? 0 : false;
                    }
                }
                // handle numbers: negative, out of range
                if (active !== false) {
                    active = this.tabs.index(this.tabs.eq(active));
                    if (active === -1) {
                        active = collapsible ? false : 0;
                    }
                }
                // don't allow collapsible: false and active: false
                if (!collapsible && active === false && this.anchors.length) {
                    active = 0;
                }
                return active;
            },
            _getCreateEventData: function() {
                return {
                    tab: this.active,
                    panel: !this.active.length ? $() : this._getPanelForTab(this.active)
                };
            },
            _tabKeydown: function(event) {
                /*jshint maxcomplexity:15*/
                var focusedTab = $(this.document[0].activeElement).closest("li"), selectedIndex = this.tabs.index(focusedTab), goingForward = true;
                if (this._handlePageNav(event)) {
                    return;
                }
                switch (event.keyCode) {
                  case $.ui.keyCode.RIGHT:
                  case $.ui.keyCode.DOWN:
                    selectedIndex++;
                    break;

                  case $.ui.keyCode.UP:
                  case $.ui.keyCode.LEFT:
                    goingForward = false;
                    selectedIndex--;
                    break;

                  case $.ui.keyCode.END:
                    selectedIndex = this.anchors.length - 1;
                    break;

                  case $.ui.keyCode.HOME:
                    selectedIndex = 0;
                    break;

                  case $.ui.keyCode.SPACE:
                    // Activate only, no collapsing
                    event.preventDefault();
                    clearTimeout(this.activating);
                    this._activate(selectedIndex);
                    return;

                  case $.ui.keyCode.ENTER:
                    // Toggle (cancel delayed activation, allow collapsing)
                    event.preventDefault();
                    clearTimeout(this.activating);
                    // Determine if we should collapse or activate
                    this._activate(selectedIndex === this.options.active ? false : selectedIndex);
                    return;

                  default:
                    return;
                }
                // Focus the appropriate tab, based on which key was pressed
                event.preventDefault();
                clearTimeout(this.activating);
                selectedIndex = this._focusNextTab(selectedIndex, goingForward);
                // Navigating with control key will prevent automatic activation
                if (!event.ctrlKey) {
                    // Update aria-selected immediately so that AT think the tab is already selected.
                    // Otherwise AT may confuse the user by stating that they need to activate the tab,
                    // but the tab will already be activated by the time the announcement finishes.
                    focusedTab.attr("aria-selected", "false");
                    this.tabs.eq(selectedIndex).attr("aria-selected", "true");
                    this.activating = this._delay(function() {
                        this.option("active", selectedIndex);
                    }, this.delay);
                }
            },
            _panelKeydown: function(event) {
                if (this._handlePageNav(event)) {
                    return;
                }
                // Ctrl+up moves focus to the current tab
                if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
                    event.preventDefault();
                    this.active.focus();
                }
            },
            // Alt+page up/down moves focus to the previous/next tab (and activates)
            _handlePageNav: function(event) {
                if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
                    this._activate(this._focusNextTab(this.options.active - 1, false));
                    return true;
                }
                if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
                    this._activate(this._focusNextTab(this.options.active + 1, true));
                    return true;
                }
            },
            _findNextTab: function(index, goingForward) {
                var lastTabIndex = this.tabs.length - 1;
                function constrain() {
                    if (index > lastTabIndex) {
                        index = 0;
                    }
                    if (index < 0) {
                        index = lastTabIndex;
                    }
                    return index;
                }
                while ($.inArray(constrain(), this.options.disabled) !== -1) {
                    index = goingForward ? index + 1 : index - 1;
                }
                return index;
            },
            _focusNextTab: function(index, goingForward) {
                index = this._findNextTab(index, goingForward);
                this.tabs.eq(index).focus();
                return index;
            },
            _setOption: function(key, value) {
                if (key === "active") {
                    // _activate() will handle invalid values and update this.options
                    this._activate(value);
                    return;
                }
                if (key === "disabled") {
                    // don't use the widget factory's disabled handling
                    this._setupDisabled(value);
                    return;
                }
                this._super(key, value);
                if (key === "collapsible") {
                    this.element.toggleClass("ui-tabs-collapsible", value);
                    // Setting collapsible: false while collapsed; open first panel
                    if (!value && this.options.active === false) {
                        this._activate(0);
                    }
                }
                if (key === "event") {
                    this._setupEvents(value);
                }
                if (key === "heightStyle") {
                    this._setupHeightStyle(value);
                }
            },
            _tabId: function(tab) {
                return tab.attr("aria-controls") || "ui-tabs-" + getNextTabId();
            },
            _sanitizeSelector: function(hash) {
                return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
            },
            refresh: function() {
                var options = this.options, lis = this.tablist.children(":has(a[href])");
                // get disabled tabs from class attribute from HTML
                // this will get converted to a boolean if needed in _refresh()
                options.disabled = $.map(lis.filter(".ui-state-disabled"), function(tab) {
                    return lis.index(tab);
                });
                this._processTabs();
                // was collapsed or no tabs
                if (options.active === false || !this.anchors.length) {
                    options.active = false;
                    this.active = $();
                } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {
                    // all remaining tabs are disabled
                    if (this.tabs.length === options.disabled.length) {
                        options.active = false;
                        this.active = $();
                    } else {
                        this._activate(this._findNextTab(Math.max(0, options.active - 1), false));
                    }
                } else {
                    // make sure active index is correct
                    options.active = this.tabs.index(this.active);
                }
                this._refresh();
            },
            _refresh: function() {
                this._setupDisabled(this.options.disabled);
                this._setupEvents(this.options.event);
                this._setupHeightStyle(this.options.heightStyle);
                this.tabs.not(this.active).attr({
                    "aria-selected": "false",
                    tabIndex: -1
                });
                this.panels.not(this._getPanelForTab(this.active)).hide().attr({
                    "aria-expanded": "false",
                    "aria-hidden": "true"
                });
                // Make sure one tab is in the tab order
                if (!this.active.length) {
                    this.tabs.eq(0).attr("tabIndex", 0);
                } else {
                    this.active.addClass("ui-tabs-active ui-state-active").attr({
                        "aria-selected": "true",
                        tabIndex: 0
                    });
                    this._getPanelForTab(this.active).show().attr({
                        "aria-expanded": "true",
                        "aria-hidden": "false"
                    });
                }
            },
            _processTabs: function() {
                var that = this;
                this.tablist = this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role", "tablist");
                this.tabs = this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({
                    role: "tab",
                    tabIndex: -1
                });
                this.anchors = this.tabs.map(function() {
                    return $("a", this)[0];
                }).addClass("ui-tabs-anchor").attr({
                    role: "presentation",
                    tabIndex: -1
                });
                this.panels = $();
                this.anchors.each(function(i, anchor) {
                    var selector, panel, panelId, anchorId = $(anchor).uniqueId().attr("id"), tab = $(anchor).closest("li"), originalAriaControls = tab.attr("aria-controls");
                    // inline tab
                    if (isLocal(anchor)) {
                        selector = anchor.hash;
                        panel = that.element.find(that._sanitizeSelector(selector));
                    } else {
                        panelId = that._tabId(tab);
                        selector = "#" + panelId;
                        panel = that.element.find(selector);
                        if (!panel.length) {
                            panel = that._createPanel(panelId);
                            panel.insertAfter(that.panels[i - 1] || that.tablist);
                        }
                        panel.attr("aria-live", "polite");
                    }
                    if (panel.length) {
                        that.panels = that.panels.add(panel);
                    }
                    if (originalAriaControls) {
                        tab.data("ui-tabs-aria-controls", originalAriaControls);
                    }
                    tab.attr({
                        "aria-controls": selector.substring(1),
                        "aria-labelledby": anchorId
                    });
                    panel.attr("aria-labelledby", anchorId);
                });
                this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role", "tabpanel");
            },
            // allow overriding how to find the list for rare usage scenarios (#7715)
            _getList: function() {
                return this.element.find("ol,ul").eq(0);
            },
            _createPanel: function(id) {
                return $("<div>").attr("id", id).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy", true);
            },
            _setupDisabled: function(disabled) {
                if ($.isArray(disabled)) {
                    if (!disabled.length) {
                        disabled = false;
                    } else if (disabled.length === this.anchors.length) {
                        disabled = true;
                    }
                }
                // disable tabs
                for (var i = 0, li; li = this.tabs[i]; i++) {
                    if (disabled === true || $.inArray(i, disabled) !== -1) {
                        $(li).addClass("ui-state-disabled").attr("aria-disabled", "true");
                    } else {
                        $(li).removeClass("ui-state-disabled").removeAttr("aria-disabled");
                    }
                }
                this.options.disabled = disabled;
            },
            _setupEvents: function(event) {
                var events = {
                    click: function(event) {
                        event.preventDefault();
                    }
                };
                if (event) {
                    $.each(event.split(" "), function(index, eventName) {
                        events[eventName] = "_eventHandler";
                    });
                }
                this._off(this.anchors.add(this.tabs).add(this.panels));
                this._on(this.anchors, events);
                this._on(this.tabs, {
                    keydown: "_tabKeydown"
                });
                this._on(this.panels, {
                    keydown: "_panelKeydown"
                });
                this._focusable(this.tabs);
                this._hoverable(this.tabs);
            },
            _setupHeightStyle: function(heightStyle) {
                var maxHeight, parent = this.element.parent();
                if (heightStyle === "fill") {
                    maxHeight = parent.height();
                    maxHeight -= this.element.outerHeight() - this.element.height();
                    this.element.siblings(":visible").each(function() {
                        var elem = $(this), position = elem.css("position");
                        if (position === "absolute" || position === "fixed") {
                            return;
                        }
                        maxHeight -= elem.outerHeight(true);
                    });
                    this.element.children().not(this.panels).each(function() {
                        maxHeight -= $(this).outerHeight(true);
                    });
                    this.panels.each(function() {
                        $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
                    }).css("overflow", "auto");
                } else if (heightStyle === "auto") {
                    maxHeight = 0;
                    this.panels.each(function() {
                        maxHeight = Math.max(maxHeight, $(this).height("").height());
                    }).height(maxHeight);
                }
            },
            _eventHandler: function(event) {
                var options = this.options, active = this.active, anchor = $(event.currentTarget), tab = anchor.closest("li"), clickedIsActive = tab[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : this._getPanelForTab(tab), toHide = !active.length ? $() : this._getPanelForTab(active), eventData = {
                    oldTab: active,
                    oldPanel: toHide,
                    newTab: collapsing ? $() : tab,
                    newPanel: toShow
                };
                event.preventDefault();
                if (tab.hasClass("ui-state-disabled") || // tab is already loading
                tab.hasClass("ui-tabs-loading") || // can't switch durning an animation
                this.running || // click on active header, but not collapsible
                clickedIsActive && !options.collapsible || // allow canceling activation
                this._trigger("beforeActivate", event, eventData) === false) {
                    return;
                }
                options.active = collapsing ? false : this.tabs.index(tab);
                this.active = clickedIsActive ? $() : tab;
                if (this.xhr) {
                    this.xhr.abort();
                }
                if (!toHide.length && !toShow.length) {
                    $.error("jQuery UI Tabs: Mismatching fragment identifier.");
                }
                if (toShow.length) {
                    this.load(this.tabs.index(tab), event);
                }
                this._toggle(event, eventData);
            },
            // handles show/hide for selecting tabs
            _toggle: function(event, eventData) {
                var that = this, toShow = eventData.newPanel, toHide = eventData.oldPanel;
                this.running = true;
                function complete() {
                    that.running = false;
                    that._trigger("activate", event, eventData);
                }
                function show() {
                    eventData.newTab.closest("li").addClass("ui-tabs-active ui-state-active");
                    if (toShow.length && that.options.show) {
                        that._show(toShow, that.options.show, complete);
                    } else {
                        toShow.show();
                        complete();
                    }
                }
                // start out by hiding, then showing, then completing
                if (toHide.length && this.options.hide) {
                    this._hide(toHide, this.options.hide, function() {
                        eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
                        show();
                    });
                } else {
                    eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
                    toHide.hide();
                    show();
                }
                toHide.attr({
                    "aria-expanded": "false",
                    "aria-hidden": "true"
                });
                eventData.oldTab.attr("aria-selected", "false");
                // If we're switching tabs, remove the old tab from the tab order.
                // If we're opening from collapsed state, remove the previous tab from the tab order.
                // If we're collapsing, then keep the collapsing tab in the tab order.
                if (toShow.length && toHide.length) {
                    eventData.oldTab.attr("tabIndex", -1);
                } else if (toShow.length) {
                    this.tabs.filter(function() {
                        return $(this).attr("tabIndex") === 0;
                    }).attr("tabIndex", -1);
                }
                toShow.attr({
                    "aria-expanded": "true",
                    "aria-hidden": "false"
                });
                eventData.newTab.attr({
                    "aria-selected": "true",
                    tabIndex: 0
                });
            },
            _activate: function(index) {
                var anchor, active = this._findActive(index);
                // trying to activate the already active panel
                if (active[0] === this.active[0]) {
                    return;
                }
                // trying to collapse, simulate a click on the current active header
                if (!active.length) {
                    active = this.active;
                }
                anchor = active.find(".ui-tabs-anchor")[0];
                this._eventHandler({
                    target: anchor,
                    currentTarget: anchor,
                    preventDefault: $.noop
                });
            },
            _findActive: function(index) {
                return index === false ? $() : this.tabs.eq(index);
            },
            _getIndex: function(index) {
                // meta-function to give users option to provide a href string instead of a numerical index.
                if (typeof index === "string") {
                    index = this.anchors.index(this.anchors.filter("[href$='" + index + "']"));
                }
                return index;
            },
            _destroy: function() {
                if (this.xhr) {
                    this.xhr.abort();
                }
                this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible");
                this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role");
                this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeUniqueId();
                this.tabs.add(this.panels).each(function() {
                    if ($.data(this, "ui-tabs-destroy")) {
                        $(this).remove();
                    } else {
                        $(this).removeClass("ui-state-default ui-state-active ui-state-disabled " + "ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role");
                    }
                });
                this.tabs.each(function() {
                    var li = $(this), prev = li.data("ui-tabs-aria-controls");
                    if (prev) {
                        li.attr("aria-controls", prev).removeData("ui-tabs-aria-controls");
                    } else {
                        li.removeAttr("aria-controls");
                    }
                });
                this.panels.show();
                if (this.options.heightStyle !== "content") {
                    this.panels.css("height", "");
                }
            },
            enable: function(index) {
                var disabled = this.options.disabled;
                if (disabled === false) {
                    return;
                }
                if (index === undefined) {
                    disabled = false;
                } else {
                    index = this._getIndex(index);
                    if ($.isArray(disabled)) {
                        disabled = $.map(disabled, function(num) {
                            return num !== index ? num : null;
                        });
                    } else {
                        disabled = $.map(this.tabs, function(li, num) {
                            return num !== index ? num : null;
                        });
                    }
                }
                this._setupDisabled(disabled);
            },
            disable: function(index) {
                var disabled = this.options.disabled;
                if (disabled === true) {
                    return;
                }
                if (index === undefined) {
                    disabled = true;
                } else {
                    index = this._getIndex(index);
                    if ($.inArray(index, disabled) !== -1) {
                        return;
                    }
                    if ($.isArray(disabled)) {
                        disabled = $.merge([ index ], disabled).sort();
                    } else {
                        disabled = [ index ];
                    }
                }
                this._setupDisabled(disabled);
            },
            load: function(index, event) {
                index = this._getIndex(index);
                var that = this, tab = this.tabs.eq(index), anchor = tab.find(".ui-tabs-anchor"), panel = this._getPanelForTab(tab), eventData = {
                    tab: tab,
                    panel: panel
                };
                // not remote
                if (isLocal(anchor[0])) {
                    return;
                }
                this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));
                // support: jQuery <1.8
                // jQuery <1.8 returns false if the request is canceled in beforeSend,
                // but as of 1.8, $.ajax() always returns a jqXHR object.
                if (this.xhr && this.xhr.statusText !== "canceled") {
                    tab.addClass("ui-tabs-loading");
                    panel.attr("aria-busy", "true");
                    this.xhr.success(function(response) {
                        // support: jQuery <1.8
                        // http://bugs.jquery.com/ticket/11778
                        setTimeout(function() {
                            panel.html(response);
                            that._trigger("load", event, eventData);
                        }, 1);
                    }).complete(function(jqXHR, status) {
                        // support: jQuery <1.8
                        // http://bugs.jquery.com/ticket/11778
                        setTimeout(function() {
                            if (status === "abort") {
                                that.panels.stop(false, true);
                            }
                            tab.removeClass("ui-tabs-loading");
                            panel.removeAttr("aria-busy");
                            if (jqXHR === that.xhr) {
                                delete that.xhr;
                            }
                        }, 1);
                    });
                }
            },
            _ajaxSettings: function(anchor, event, eventData) {
                var that = this;
                return {
                    url: anchor.attr("href"),
                    beforeSend: function(jqXHR, settings) {
                        return that._trigger("beforeLoad", event, $.extend({
                            jqXHR: jqXHR,
                            ajaxSettings: settings
                        }, eventData));
                    }
                };
            },
            _getPanelForTab: function(tab) {
                var id = $(tab).attr("aria-controls");
                return this.element.find(this._sanitizeSelector("#" + id));
            }
        });
    })(jQuery);
    (function($) {
        var increments = 0;
        function addDescribedBy(elem, id) {
            var describedby = (elem.attr("aria-describedby") || "").split(/\s+/);
            describedby.push(id);
            elem.data("ui-tooltip-id", id).attr("aria-describedby", $.trim(describedby.join(" ")));
        }
        function removeDescribedBy(elem) {
            var id = elem.data("ui-tooltip-id"), describedby = (elem.attr("aria-describedby") || "").split(/\s+/), index = $.inArray(id, describedby);
            if (index !== -1) {
                describedby.splice(index, 1);
            }
            elem.removeData("ui-tooltip-id");
            describedby = $.trim(describedby.join(" "));
            if (describedby) {
                elem.attr("aria-describedby", describedby);
            } else {
                elem.removeAttr("aria-describedby");
            }
        }
        $.widget("ui.tooltip", {
            version: "1.10.3",
            options: {
                content: function() {
                    // support: IE<9, Opera in jQuery <1.7
                    // .text() can't accept undefined, so coerce to a string
                    var title = $(this).attr("title") || "";
                    // Escape title, since we're going from an attribute to raw HTML
                    return $("<a>").text(title).html();
                },
                hide: true,
                // Disabled elements have inconsistent behavior across browsers (#8661)
                items: "[title]:not([disabled])",
                position: {
                    my: "left top+15",
                    at: "left bottom",
                    collision: "flipfit flip"
                },
                show: true,
                tooltipClass: null,
                track: false,
                // callbacks
                close: null,
                open: null
            },
            _create: function() {
                this._on({
                    mouseover: "open",
                    focusin: "open"
                });
                // IDs of generated tooltips, needed for destroy
                this.tooltips = {};
                // IDs of parent tooltips where we removed the title attribute
                this.parents = {};
                if (this.options.disabled) {
                    this._disable();
                }
            },
            _setOption: function(key, value) {
                var that = this;
                if (key === "disabled") {
                    this[value ? "_disable" : "_enable"]();
                    this.options[key] = value;
                    // disable element style changes
                    return;
                }
                this._super(key, value);
                if (key === "content") {
                    $.each(this.tooltips, function(id, element) {
                        that._updateContent(element);
                    });
                }
            },
            _disable: function() {
                var that = this;
                // close open tooltips
                $.each(this.tooltips, function(id, element) {
                    var event = $.Event("blur");
                    event.target = event.currentTarget = element[0];
                    that.close(event, true);
                });
                // remove title attributes to prevent native tooltips
                this.element.find(this.options.items).addBack().each(function() {
                    var element = $(this);
                    if (element.is("[title]")) {
                        element.data("ui-tooltip-title", element.attr("title")).attr("title", "");
                    }
                });
            },
            _enable: function() {
                // restore title attributes
                this.element.find(this.options.items).addBack().each(function() {
                    var element = $(this);
                    if (element.data("ui-tooltip-title")) {
                        element.attr("title", element.data("ui-tooltip-title"));
                    }
                });
            },
            open: function(event) {
                var that = this, target = $(event ? event.target : this.element).closest(this.options.items);
                // No element to show a tooltip for or the tooltip is already open
                if (!target.length || target.data("ui-tooltip-id")) {
                    return;
                }
                if (target.attr("title")) {
                    target.data("ui-tooltip-title", target.attr("title"));
                }
                target.data("ui-tooltip-open", true);
                // kill parent tooltips, custom or native, for hover
                if (event && event.type === "mouseover") {
                    target.parents().each(function() {
                        var parent = $(this), blurEvent;
                        if (parent.data("ui-tooltip-open")) {
                            blurEvent = $.Event("blur");
                            blurEvent.target = blurEvent.currentTarget = this;
                            that.close(blurEvent, true);
                        }
                        if (parent.attr("title")) {
                            parent.uniqueId();
                            that.parents[this.id] = {
                                element: this,
                                title: parent.attr("title")
                            };
                            parent.attr("title", "");
                        }
                    });
                }
                this._updateContent(target, event);
            },
            _updateContent: function(target, event) {
                var content, contentOption = this.options.content, that = this, eventType = event ? event.type : null;
                if (typeof contentOption === "string") {
                    return this._open(event, target, contentOption);
                }
                content = contentOption.call(target[0], function(response) {
                    // ignore async response if tooltip was closed already
                    if (!target.data("ui-tooltip-open")) {
                        return;
                    }
                    // IE may instantly serve a cached response for ajax requests
                    // delay this call to _open so the other call to _open runs first
                    that._delay(function() {
                        // jQuery creates a special event for focusin when it doesn't
                        // exist natively. To improve performance, the native event
                        // object is reused and the type is changed. Therefore, we can't
                        // rely on the type being correct after the event finished
                        // bubbling, so we set it back to the previous value. (#8740)
                        if (event) {
                            event.type = eventType;
                        }
                        this._open(event, target, response);
                    });
                });
                if (content) {
                    this._open(event, target, content);
                }
            },
            _open: function(event, target, content) {
                var tooltip, events, delayedShow, positionOption = $.extend({}, this.options.position);
                if (!content) {
                    return;
                }
                // Content can be updated multiple times. If the tooltip already
                // exists, then just update the content and bail.
                tooltip = this._find(target);
                if (tooltip.length) {
                    tooltip.find(".ui-tooltip-content").html(content);
                    return;
                }
                // if we have a title, clear it to prevent the native tooltip
                // we have to check first to avoid defining a title if none exists
                // (we don't want to cause an element to start matching [title])
                //
                // We use removeAttr only for key events, to allow IE to export the correct
                // accessible attributes. For mouse events, set to empty string to avoid
                // native tooltip showing up (happens only when removing inside mouseover).
                if (target.is("[title]")) {
                    if (event && event.type === "mouseover") {
                        target.attr("title", "");
                    } else {
                        target.removeAttr("title");
                    }
                }
                tooltip = this._tooltip(target);
                addDescribedBy(target, tooltip.attr("id"));
                tooltip.find(".ui-tooltip-content").html(content);
                function position(event) {
                    positionOption.of = event;
                    if (tooltip.is(":hidden")) {
                        return;
                    }
                    tooltip.position(positionOption);
                }
                if (this.options.track && event && /^mouse/.test(event.type)) {
                    this._on(this.document, {
                        mousemove: position
                    });
                    // trigger once to override element-relative positioning
                    position(event);
                } else {
                    tooltip.position($.extend({
                        of: target
                    }, this.options.position));
                }
                tooltip.hide();
                this._show(tooltip, this.options.show);
                // Handle tracking tooltips that are shown with a delay (#8644). As soon
                // as the tooltip is visible, position the tooltip using the most recent
                // event.
                if (this.options.show && this.options.show.delay) {
                    delayedShow = this.delayedShow = setInterval(function() {
                        if (tooltip.is(":visible")) {
                            position(positionOption.of);
                            clearInterval(delayedShow);
                        }
                    }, $.fx.interval);
                }
                this._trigger("open", event, {
                    tooltip: tooltip
                });
                events = {
                    keyup: function(event) {
                        if (event.keyCode === $.ui.keyCode.ESCAPE) {
                            var fakeEvent = $.Event(event);
                            fakeEvent.currentTarget = target[0];
                            this.close(fakeEvent, true);
                        }
                    },
                    remove: function() {
                        this._removeTooltip(tooltip);
                    }
                };
                if (!event || event.type === "mouseover") {
                    events.mouseleave = "close";
                }
                if (!event || event.type === "focusin") {
                    events.focusout = "close";
                }
                this._on(true, target, events);
            },
            close: function(event) {
                var that = this, target = $(event ? event.currentTarget : this.element), tooltip = this._find(target);
                // disabling closes the tooltip, so we need to track when we're closing
                // to avoid an infinite loop in case the tooltip becomes disabled on close
                if (this.closing) {
                    return;
                }
                // Clear the interval for delayed tracking tooltips
                clearInterval(this.delayedShow);
                // only set title if we had one before (see comment in _open())
                if (target.data("ui-tooltip-title")) {
                    target.attr("title", target.data("ui-tooltip-title"));
                }
                removeDescribedBy(target);
                tooltip.stop(true);
                this._hide(tooltip, this.options.hide, function() {
                    that._removeTooltip($(this));
                });
                target.removeData("ui-tooltip-open");
                this._off(target, "mouseleave focusout keyup");
                // Remove 'remove' binding only on delegated targets
                if (target[0] !== this.element[0]) {
                    this._off(target, "remove");
                }
                this._off(this.document, "mousemove");
                if (event && event.type === "mouseleave") {
                    $.each(this.parents, function(id, parent) {
                        $(parent.element).attr("title", parent.title);
                        delete that.parents[id];
                    });
                }
                this.closing = true;
                this._trigger("close", event, {
                    tooltip: tooltip
                });
                this.closing = false;
            },
            _tooltip: function(element) {
                var id = "ui-tooltip-" + increments++, tooltip = $("<div>").attr({
                    id: id,
                    role: "tooltip"
                }).addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content " + (this.options.tooltipClass || ""));
                $("<div>").addClass("ui-tooltip-content").appendTo(tooltip);
                tooltip.appendTo(this.document[0].body);
                this.tooltips[id] = element;
                return tooltip;
            },
            _find: function(target) {
                var id = target.data("ui-tooltip-id");
                return id ? $("#" + id) : $();
            },
            _removeTooltip: function(tooltip) {
                tooltip.remove();
                delete this.tooltips[tooltip.attr("id")];
            },
            _destroy: function() {
                var that = this;
                // close open tooltips
                $.each(this.tooltips, function(id, element) {
                    // Delegate to close method to handle common cleanup
                    var event = $.Event("blur");
                    event.target = event.currentTarget = element[0];
                    that.close(event, true);
                    // Remove immediately; destroying an open tooltip doesn't use the
                    // hide animation
                    $("#" + id).remove();
                    // Restore the title
                    if (element.data("ui-tooltip-title")) {
                        element.attr("title", element.data("ui-tooltip-title"));
                        element.removeData("ui-tooltip-title");
                    }
                });
            }
        });
    })(jQuery);
});

/**
 * noty - jQuery Notification Plugin v2.1.0
 * Contributors: https://github.com/needim/noty/graphs/contributors
 *
 * Examples and Documentation - http://needim.github.com/noty/
 *
 * Licensed under the MIT licenses:
 * http://www.opensource.org/licenses/mit-license.php
 *
 **/
define("sarike/jquery-noty/2.1.0/jquery-noty-debug", [ "$-debug", "./layouts/top-debug", "./layouts/topCenter-debug", "./layouts/topLeft-debug", "./layouts/center-debug", "./themes/default-debug" ], function(require, exports, module) {
    var jQuery = require("$-debug");
    if (typeof Object.create !== "function") {
        Object.create = function(o) {
            function F() {}
            F.prototype = o;
            return new F();
        };
    }
    (function($) {
        var NotyObject = {
            init: function(options) {
                // Mix in the passed in options with the default options
                this.options = $.extend({}, $.noty.defaults, options);
                this.options.layout = this.options.custom ? $.noty.layouts["inline"] : $.noty.layouts[this.options.layout];
                this.options.theme = $.noty.themes[this.options.theme];
                delete options.layout;
                delete options.theme;
                this.options = $.extend({}, this.options, this.options.layout.options);
                this.options.id = "noty_" + new Date().getTime() * Math.floor(Math.random() * 1e6);
                this.options = $.extend({}, this.options, options);
                // Build the noty dom initial structure
                this._build();
                // return this so we can chain/use the bridge with less code.
                return this;
            },
            // end init
            _build: function() {
                // Generating noty bar
                var $bar = $('<div class="noty_bar"></div>').attr("id", this.options.id);
                $bar.append(this.options.template).find(".noty_text").html(this.options.text);
                this.$bar = this.options.layout.parent.object !== null ? $(this.options.layout.parent.object).css(this.options.layout.parent.css).append($bar) : $bar;
                // Set buttons if available
                if (this.options.buttons) {
                    // If we have button disable closeWith & timeout options
                    this.options.closeWith = [];
                    this.options.timeout = false;
                    var $buttons = $("<div/>").addClass("noty_buttons");
                    this.options.layout.parent.object !== null ? this.$bar.find(".noty_bar").append($buttons) : this.$bar.append($buttons);
                    var self = this;
                    $.each(this.options.buttons, function(i, button) {
                        var $button = $("<button/>").addClass(button.addClass ? button.addClass : "gray").html(button.text).appendTo(self.$bar.find(".noty_buttons")).bind("click", function() {
                            if ($.isFunction(button.onClick)) {
                                button.onClick.call($button, self);
                            }
                        });
                    });
                }
                // For easy access
                this.$message = this.$bar.find(".noty_message");
                this.$closeButton = this.$bar.find(".noty_close");
                this.$buttons = this.$bar.find(".noty_buttons");
                $.noty.store[this.options.id] = this;
            },
            // end _build
            show: function() {
                var self = this;
                $(self.options.layout.container.selector).append(self.$bar);
                self.options.theme.style.apply(self);
                $.type(self.options.layout.css) === "function" ? this.options.layout.css.apply(self.$bar) : self.$bar.css(this.options.layout.css || {});
                self.$bar.addClass(self.options.layout.addClass);
                self.options.layout.container.style.apply($(self.options.layout.container.selector));
                self.options.theme.callback.onShow.apply(this);
                if ($.inArray("click", self.options.closeWith) > -1) self.$bar.css("cursor", "pointer").one("click", function(evt) {
                    self.stopPropagation(evt);
                    if (self.options.callback.onCloseClick) {
                        self.options.callback.onCloseClick.apply(self);
                    }
                    self.close();
                });
                if ($.inArray("hover", self.options.closeWith) > -1) self.$bar.one("mouseenter", function() {
                    self.close();
                });
                if ($.inArray("button", self.options.closeWith) > -1) self.$closeButton.one("click", function(evt) {
                    self.stopPropagation(evt);
                    self.close();
                });
                if ($.inArray("button", self.options.closeWith) == -1) self.$closeButton.remove();
                if (self.options.callback.onShow) self.options.callback.onShow.apply(self);
                self.$bar.animate(self.options.animation.open, self.options.animation.speed, self.options.animation.easing, function() {
                    if (self.options.callback.afterShow) self.options.callback.afterShow.apply(self);
                    self.shown = true;
                });
                // If noty is have a timeout option
                if (self.options.timeout) self.$bar.delay(self.options.timeout).promise().done(function() {
                    self.close();
                });
                return this;
            },
            // end show
            close: function() {
                if (this.closed) return;
                if (this.$bar && this.$bar.hasClass("i-am-closing-now")) return;
                var self = this;
                if (!this.shown) {
                    // If we are still waiting in the queue just delete from queue
                    var queue = [];
                    $.each($.noty.queue, function(i, n) {
                        if (n.options.id != self.options.id) {
                            queue.push(n);
                        }
                    });
                    $.noty.queue = queue;
                    return;
                }
                self.$bar.addClass("i-am-closing-now");
                if (self.options.callback.onClose) {
                    self.options.callback.onClose.apply(self);
                }
                self.$bar.clearQueue().stop().animate(self.options.animation.close, self.options.animation.speed, self.options.animation.easing, function() {
                    if (self.options.callback.afterClose) self.options.callback.afterClose.apply(self);
                }).promise().done(function() {
                    // Modal Cleaning
                    if (self.options.modal) {
                        $.notyRenderer.setModalCount(-1);
                        if ($.notyRenderer.getModalCount() == 0) $(".noty_modal").fadeOut("fast", function() {
                            $(this).remove();
                        });
                    }
                    // Layout Cleaning
                    $.notyRenderer.setLayoutCountFor(self, -1);
                    if ($.notyRenderer.getLayoutCountFor(self) == 0) $(self.options.layout.container.selector).remove();
                    // Make sure self.$bar has not been removed before attempting to remove it
                    if (typeof self.$bar !== "undefined" && self.$bar !== null) {
                        self.$bar.remove();
                        self.$bar = null;
                        self.closed = true;
                    }
                    delete $.noty.store[self.options.id];
                    // deleting noty from store
                    self.options.theme.callback.onClose.apply(self);
                    if (!self.options.dismissQueue) {
                        // Queue render
                        $.noty.ontap = true;
                        $.notyRenderer.render();
                    }
                    if (self.options.maxVisible > 0 && self.options.dismissQueue) {
                        $.notyRenderer.render();
                    }
                });
            },
            // end close
            setText: function(text) {
                if (!this.closed) {
                    this.options.text = text;
                    this.$bar.find(".noty_text").html(text);
                }
                return this;
            },
            setType: function(type) {
                if (!this.closed) {
                    this.options.type = type;
                    this.options.theme.style.apply(this);
                    this.options.theme.callback.onShow.apply(this);
                }
                return this;
            },
            setTimeout: function(time) {
                if (!this.closed) {
                    var self = this;
                    this.options.timeout = time;
                    self.$bar.delay(self.options.timeout).promise().done(function() {
                        self.close();
                    });
                }
                return this;
            },
            stopPropagation: function(evt) {
                evt = evt || window.event;
                if (typeof evt.stopPropagation !== "undefined") {
                    evt.stopPropagation();
                } else {
                    evt.cancelBubble = true;
                }
            },
            closed: false,
            shown: false
        };
        // end NotyObject
        $.notyRenderer = {};
        $.notyRenderer.init = function(options) {
            // Renderer creates a new noty
            var notification = Object.create(NotyObject).init(options);
            notification.options.force ? $.noty.queue.unshift(notification) : $.noty.queue.push(notification);
            $.notyRenderer.render();
            return $.noty.returns == "object" ? notification : notification.options.id;
        };
        $.notyRenderer.render = function() {
            var instance = $.noty.queue[0];
            if ($.type(instance) === "object") {
                if (instance.options.dismissQueue) {
                    if (instance.options.maxVisible > 0) {
                        if ($(instance.options.layout.container.selector + " li").length < instance.options.maxVisible) {
                            $.notyRenderer.show($.noty.queue.shift());
                        } else {}
                    } else {
                        $.notyRenderer.show($.noty.queue.shift());
                    }
                } else {
                    if ($.noty.ontap) {
                        $.notyRenderer.show($.noty.queue.shift());
                        $.noty.ontap = false;
                    }
                }
            } else {
                $.noty.ontap = true;
            }
        };
        $.notyRenderer.show = function(notification) {
            if (notification.options.modal) {
                $.notyRenderer.createModalFor(notification);
                $.notyRenderer.setModalCount(+1);
            }
            // Where is the container?
            if ($(notification.options.layout.container.selector).length == 0) {
                if (notification.options.custom) {
                    notification.options.custom.append($(notification.options.layout.container.object).addClass("i-am-new"));
                } else {
                    $("body").append($(notification.options.layout.container.object).addClass("i-am-new"));
                }
            } else {
                $(notification.options.layout.container.selector).removeClass("i-am-new");
            }
            $.notyRenderer.setLayoutCountFor(notification, +1);
            notification.show();
        };
        $.notyRenderer.createModalFor = function(notification) {
            if ($(".noty_modal").length == 0) $("<div/>").addClass("noty_modal").data("noty_modal_count", 0).css(notification.options.theme.modal.css).prependTo($("body")).fadeIn("fast");
        };
        $.notyRenderer.getLayoutCountFor = function(notification) {
            return $(notification.options.layout.container.selector).data("noty_layout_count") || 0;
        };
        $.notyRenderer.setLayoutCountFor = function(notification, arg) {
            return $(notification.options.layout.container.selector).data("noty_layout_count", $.notyRenderer.getLayoutCountFor(notification) + arg);
        };
        $.notyRenderer.getModalCount = function() {
            return $(".noty_modal").data("noty_modal_count") || 0;
        };
        $.notyRenderer.setModalCount = function(arg) {
            return $(".noty_modal").data("noty_modal_count", $.notyRenderer.getModalCount() + arg);
        };
        // This is for custom container
        $.fn.noty = function(options) {
            options.custom = $(this);
            return $.notyRenderer.init(options);
        };
        $.noty = {};
        $.noty.queue = [];
        $.noty.ontap = true;
        $.noty.layouts = {};
        $.noty.themes = {};
        $.noty.returns = "object";
        $.noty.store = {};
        $.noty.get = function(id) {
            return $.noty.store.hasOwnProperty(id) ? $.noty.store[id] : false;
        };
        $.noty.close = function(id) {
            return $.noty.get(id) ? $.noty.get(id).close() : false;
        };
        $.noty.setText = function(id, text) {
            return $.noty.get(id) ? $.noty.get(id).setText(text) : false;
        };
        $.noty.setType = function(id, type) {
            return $.noty.get(id) ? $.noty.get(id).setType(type) : false;
        };
        $.noty.clearQueue = function() {
            $.noty.queue = [];
        };
        $.noty.closeAll = function() {
            $.noty.clearQueue();
            $.each($.noty.store, function(id, noty) {
                noty.close();
            });
        };
        var windowAlert = window.alert;
        $.noty.consumeAlert = function(options) {
            window.alert = function(text) {
                if (options) options.text = text; else options = {
                    text: text
                };
                $.notyRenderer.init(options);
            };
        };
        $.noty.stopConsumeAlert = function() {
            window.alert = windowAlert;
        };
        $.noty.defaults = {
            layout: "top",
            theme: "defaultTheme",
            type: "alert",
            text: "",
            dismissQueue: true,
            template: '<div class="noty_message"><span class="noty_text"></span><div class="noty_close"></div></div>',
            animation: {
                open: {
                    height: "toggle"
                },
                close: {
                    height: "toggle"
                },
                easing: "swing",
                speed: 500
            },
            timeout: false,
            force: false,
            modal: false,
            maxVisible: 5,
            closeWith: [ "click" ],
            callback: {
                onShow: function() {},
                afterShow: function() {},
                onClose: function() {},
                afterClose: function() {},
                onCloseClick: function() {}
            },
            buttons: false
        };
        $(window).resize(function() {
            $.each($.noty.layouts, function(index, layout) {
                layout.container.style.apply($(layout.container.selector));
            });
        });
    })(jQuery);
    // Helpers
    module.exports = function noty(options) {
        // This is for BC  -  Will be deleted on v2.2.0
        var using_old = 0, old_to_new = {
            animateOpen: "animation.open",
            animateClose: "animation.close",
            easing: "animation.easing",
            speed: "animation.speed",
            onShow: "callback.onShow",
            onShown: "callback.afterShow",
            onClose: "callback.onClose",
            onCloseClick: "callback.onCloseClick",
            onClosed: "callback.afterClose"
        };
        jQuery.each(options, function(key, value) {
            if (old_to_new[key]) {
                using_old++;
                var _new = old_to_new[key].split(".");
                if (!options[_new[0]]) options[_new[0]] = {};
                options[_new[0]][_new[1]] = value ? value : function() {};
                delete options[key];
            }
        });
        if (!options.closeWith) {
            options.closeWith = jQuery.noty.defaults.closeWith;
        }
        if (options.hasOwnProperty("closeButton")) {
            using_old++;
            if (options.closeButton) options.closeWith.push("button");
            delete options.closeButton;
        }
        if (options.hasOwnProperty("closeOnSelfClick")) {
            using_old++;
            if (options.closeOnSelfClick) options.closeWith.push("click");
            delete options.closeOnSelfClick;
        }
        if (options.hasOwnProperty("closeOnSelfOver")) {
            using_old++;
            if (options.closeOnSelfOver) options.closeWith.push("hover");
            delete options.closeOnSelfOver;
        }
        if (options.hasOwnProperty("custom")) {
            using_old++;
            if (options.custom.container != "null") options.custom = options.custom.container;
        }
        if (options.hasOwnProperty("cssPrefix")) {
            using_old++;
            delete options.cssPrefix;
        }
        if (options.theme == "noty_theme_default") {
            using_old++;
            options.theme = "defaultTheme";
        }
        if (!options.hasOwnProperty("dismissQueue")) {
            options.dismissQueue = jQuery.noty.defaults.dismissQueue;
        }
        if (!options.hasOwnProperty("maxVisible")) {
            options.maxVisible = jQuery.noty.defaults.maxVisible;
        }
        if (options.buttons) {
            jQuery.each(options.buttons, function(i, button) {
                if (button.click) {
                    using_old++;
                    button.onClick = button.click;
                    delete button.click;
                }
                if (button.type) {
                    using_old++;
                    button.addClass = button.type;
                    delete button.type;
                }
            });
        }
        if (using_old) {
            if (typeof console !== "undefined" && console.warn) {
                console.warn("You are using noty v2 with v1.x.x options. @deprecated until v2.2.0 - Please update your options.");
            }
        }
        // console.log(options);
        // End of the BC
        return jQuery.notyRenderer.init(options);
    };
    require("./layouts/top-debug");
    require("./layouts/topCenter-debug");
    require("./layouts/topLeft-debug");
    require("./layouts/center-debug");
    require("./themes/default-debug");
});

define("sarike/jquery-noty/2.1.0/layouts/top-debug", [ "$-debug" ], function(require, exports, module) {
    var jQuery = require("$-debug");
    (function($) {
        $.noty.layouts.top = {
            name: "top",
            options: {},
            container: {
                object: '<ul id="noty_top_layout_container" />',
                selector: "ul#noty_top_layout_container",
                style: function() {
                    $(this).css({
                        top: 0,
                        left: "5%",
                        position: "fixed",
                        width: "90%",
                        height: "auto",
                        margin: 0,
                        padding: 0,
                        listStyleType: "none",
                        zIndex: 9999999
                    });
                }
            },
            parent: {
                object: "<li />",
                selector: "li",
                css: {}
            },
            css: {
                display: "none"
            },
            addClass: ""
        };
    })(jQuery);
});

define("sarike/jquery-noty/2.1.0/layouts/topCenter-debug", [ "$-debug" ], function(require, exports, module) {
    var jQuery = require("$-debug");
    (function($) {
        $.noty.layouts.topCenter = {
            name: "topCenter",
            options: {},
            container: {
                object: '<ul id="noty_topCenter_layout_container" />',
                selector: "ul#noty_topCenter_layout_container",
                style: function() {
                    $(this).css({
                        top: 20,
                        left: 0,
                        position: "fixed",
                        width: "310px",
                        height: "auto",
                        margin: 0,
                        padding: 0,
                        listStyleType: "none",
                        zIndex: 1e7
                    });
                    $(this).css({
                        left: ($(window).width() - $(this).outerWidth(false)) / 2 + "px"
                    });
                }
            },
            parent: {
                object: "<li />",
                selector: "li",
                css: {}
            },
            css: {
                display: "none",
                width: "310px"
            },
            addClass: ""
        };
    })(jQuery);
});

define("sarike/jquery-noty/2.1.0/layouts/topLeft-debug", [ "$-debug" ], function(require, exports, module) {
    var jQuery = require("$-debug");
    (function($) {
        $.noty.layouts.topLeft = {
            name: "topLeft",
            options: {},
            container: {
                object: '<ul id="noty_topLeft_layout_container" />',
                selector: "ul#noty_topLeft_layout_container",
                style: function() {
                    $(this).css({
                        top: 20,
                        left: 20,
                        position: "fixed",
                        width: "310px",
                        height: "auto",
                        margin: 0,
                        padding: 0,
                        listStyleType: "none",
                        zIndex: 1e7
                    });
                    if (window.innerWidth < 600) {
                        $(this).css({
                            left: 5
                        });
                    }
                }
            },
            parent: {
                object: "<li />",
                selector: "li",
                css: {}
            },
            css: {
                display: "none",
                width: "310px"
            },
            addClass: ""
        };
    })(jQuery);
});

define("sarike/jquery-noty/2.1.0/layouts/center-debug", [ "$-debug" ], function(require, exports, module) {
    var jQuery = require("$-debug");
    (function($) {
        $.noty.layouts.center = {
            name: "center",
            options: {},
            container: {
                object: '<ul id="noty_center_layout_container" />',
                selector: "ul#noty_center_layout_container",
                style: function() {
                    $(this).css({
                        position: "fixed",
                        width: "310px",
                        height: "auto",
                        margin: 0,
                        padding: 0,
                        listStyleType: "none",
                        zIndex: 1e7
                    });
                    // getting hidden height
                    var dupe = $(this).clone().css({
                        visibility: "hidden",
                        display: "block",
                        position: "absolute",
                        top: 0,
                        left: 0
                    }).attr("id", "dupe");
                    $("body").append(dupe);
                    dupe.find(".i-am-closing-now").remove();
                    dupe.find("li").css("display", "block");
                    var actual_height = dupe.height();
                    dupe.remove();
                    if ($(this).hasClass("i-am-new")) {
                        $(this).css({
                            left: ($(window).width() - $(this).outerWidth(false)) / 2 + "px",
                            top: ($(window).height() - actual_height) / 2 + "px"
                        });
                    } else {
                        $(this).animate({
                            left: ($(window).width() - $(this).outerWidth(false)) / 2 + "px",
                            top: ($(window).height() - actual_height) / 2 + "px"
                        }, 500);
                    }
                }
            },
            parent: {
                object: "<li />",
                selector: "li",
                css: {}
            },
            css: {
                display: "none",
                width: "310px"
            },
            addClass: ""
        };
    })(jQuery);
});

define("sarike/jquery-noty/2.1.0/themes/default-debug", [ "$-debug" ], function(require, exports, module) {
    var jQuery = require("$-debug");
    (function($) {
        $.noty.themes.defaultTheme = {
            name: "defaultTheme",
            helpers: {
                borderFix: function() {
                    if (this.options.dismissQueue) {
                        var selector = this.options.layout.container.selector + " " + this.options.layout.parent.selector;
                        switch (this.options.layout.name) {
                          case "top":
                            $(selector).css({
                                borderRadius: "0px 0px 0px 0px"
                            });
                            $(selector).last().css({
                                borderRadius: "0px 0px 5px 5px"
                            });
                            break;

                          case "topCenter":
                          case "topLeft":
                          case "topRight":
                          case "bottomCenter":
                          case "bottomLeft":
                          case "bottomRight":
                          case "center":
                          case "centerLeft":
                          case "centerRight":
                          case "inline":
                            $(selector).css({
                                borderRadius: "0px 0px 0px 0px"
                            });
                            $(selector).first().css({
                                "border-top-left-radius": "5px",
                                "border-top-right-radius": "5px"
                            });
                            $(selector).last().css({
                                "border-bottom-left-radius": "5px",
                                "border-bottom-right-radius": "5px"
                            });
                            break;

                          case "bottom":
                            $(selector).css({
                                borderRadius: "0px 0px 0px 0px"
                            });
                            $(selector).first().css({
                                borderRadius: "5px 5px 0px 0px"
                            });
                            break;

                          default:
                            break;
                        }
                    }
                }
            },
            modal: {
                css: {
                    position: "fixed",
                    width: "100%",
                    height: "100%",
                    backgroundColor: "#000",
                    zIndex: 1e4,
                    opacity: .6,
                    display: "none",
                    left: 0,
                    top: 0
                }
            },
            style: function() {
                this.$bar.css({
                    overflow: "hidden",
                    background: "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAoCAYAAAAPOoFWAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAPZJREFUeNq81tsOgjAMANB2ov7/7ypaN7IlIwi9rGuT8QSc9EIDAsAznxvY4pXPKr05RUE5MEVB+TyWfCEl9LZApYopCmo9C4FKSMtYoI8Bwv79aQJU4l6hXXCZrQbokJEksxHo9KMOgc6w1atHXM8K9DVC7FQnJ0i8iK3QooGgbnyKgMDygBWyYFZoqx4qS27KqLZJjA1D0jK6QJcYEQEiWv9PGkTsbqxQ8oT+ZtZB6AkdsJnQDnMoHXHLGKOgDYuCWmYhEERCI5gaamW0bnHdA3k2ltlIN+2qKRyCND0bhqSYCyTB3CAOc4WusBEIpkeBuPgJMAAX8Hs1NfqHRgAAAABJRU5ErkJggg==') repeat-x scroll left top #fff"
                });
                this.$message.css({
                    fontSize: "13px",
                    lineHeight: "16px",
                    textAlign: "center",
                    padding: "8px 10px 9px",
                    width: "auto",
                    position: "relative"
                });
                this.$closeButton.css({
                    position: "absolute",
                    top: 4,
                    right: 4,
                    width: 10,
                    height: 10,
                    background: "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAATpJREFUeNoszrFqVFEUheG19zlz7sQ7ijMQBAvfYBqbpJCoZSAQbOwEE1IHGytbLQUJ8SUktW8gCCFJMSGSNxCmFBJO7j5rpXD6n5/P5vM53H3b3T9LOiB5AQDuDjM7BnA7DMPHDGBH0nuSzwHsRcRVRNRSysuU0i6AOwA/02w2+9Fae00SEbEh6SGAR5K+k3zWWptKepCm0+kpyRoRGyRBcpPkDsn1iEBr7drdP2VJZyQXERGSPpiZAViTBACXKaV9kqd5uVzCzO5KKb/d/UZSDwD/eyxqree1VqSu6zKAF2Z2RPJJaw0rAkjOJT0m+SuT/AbgDcmnkmBmfwAsJL1dXQ8lWY6IGwB1ZbrOOb8zs8thGP4COFwx/mE8Ho9Go9ErMzvJOW/1fY/JZIJSypqZfXX3L13X9fcDAKJct1sx3OiuAAAAAElFTkSuQmCC)",
                    display: "none",
                    cursor: "pointer"
                });
                this.$buttons.css({
                    padding: 5,
                    textAlign: "right",
                    borderTop: "1px solid #ccc",
                    backgroundColor: "#fff"
                });
                this.$buttons.find("button").css({
                    marginLeft: 5
                });
                this.$buttons.find("button:first").css({
                    marginLeft: 0
                });
                this.$bar.bind({
                    mouseenter: function() {
                        $(this).find(".noty_close").stop().fadeTo("normal", 1);
                    },
                    mouseleave: function() {
                        $(this).find(".noty_close").stop().fadeTo("normal", 0);
                    }
                });
                switch (this.options.layout.name) {
                  case "top":
                    this.$bar.css({
                        borderRadius: "0px 0px 5px 5px",
                        borderBottom: "2px solid #eee",
                        borderLeft: "2px solid #eee",
                        borderRight: "2px solid #eee",
                        boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                    });
                    break;

                  case "topCenter":
                  case "center":
                  case "bottomCenter":
                  case "inline":
                    this.$bar.css({
                        borderRadius: "5px",
                        border: "1px solid #eee",
                        boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                    });
                    this.$message.css({
                        fontSize: "13px",
                        textAlign: "center"
                    });
                    break;

                  case "topLeft":
                  case "topRight":
                  case "bottomLeft":
                  case "bottomRight":
                  case "centerLeft":
                  case "centerRight":
                    this.$bar.css({
                        borderRadius: "5px",
                        border: "1px solid #eee",
                        boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                    });
                    this.$message.css({
                        fontSize: "13px",
                        textAlign: "left"
                    });
                    break;

                  case "bottom":
                    this.$bar.css({
                        borderRadius: "5px 5px 0px 0px",
                        borderTop: "2px solid #eee",
                        borderLeft: "2px solid #eee",
                        borderRight: "2px solid #eee",
                        boxShadow: "0 -2px 4px rgba(0, 0, 0, 0.1)"
                    });
                    break;

                  default:
                    this.$bar.css({
                        border: "2px solid #eee",
                        boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                    });
                    break;
                }
                switch (this.options.type) {
                  case "alert":
                  case "notification":
                    this.$bar.css({
                        backgroundColor: "#FFF",
                        borderColor: "#CCC",
                        color: "#444"
                    });
                    break;

                  case "warning":
                    this.$bar.css({
                        backgroundColor: "#FFEAA8",
                        borderColor: "#FFC237",
                        color: "#826200"
                    });
                    this.$buttons.css({
                        borderTop: "1px solid #FFC237"
                    });
                    break;

                  case "error":
                    this.$bar.css({
                        backgroundColor: "red",
                        borderColor: "darkred",
                        color: "#FFF"
                    });
                    this.$message.css({
                        fontWeight: "bold"
                    });
                    this.$buttons.css({
                        borderTop: "1px solid darkred"
                    });
                    break;

                  case "information":
                    this.$bar.css({
                        backgroundColor: "#57B7E2",
                        borderColor: "#0B90C4",
                        color: "#FFF"
                    });
                    this.$buttons.css({
                        borderTop: "1px solid #0B90C4"
                    });
                    break;

                  case "success":
                    this.$bar.css({
                        backgroundColor: "lightgreen",
                        borderColor: "#50C24E",
                        color: "darkgreen"
                    });
                    this.$buttons.css({
                        borderTop: "1px solid #50C24E"
                    });
                    break;

                  default:
                    this.$bar.css({
                        backgroundColor: "#FFF",
                        borderColor: "#CCC",
                        color: "#444"
                    });
                    break;
                }
            },
            callback: {
                onShow: function() {
                    $.noty.themes.defaultTheme.helpers.borderFix.apply(this);
                },
                onClose: function() {
                    $.noty.themes.defaultTheme.helpers.borderFix.apply(this);
                }
            }
        };
    })(jQuery);
});

define("sarike/timefly/0.0.1/common/base/base-debug", [ "sarike/timefly/0.0.1/libs/libs-debug", "$-debug", "gallery/underscore/1.4.4/underscore-debug", "gallery/backbone/1.0.0/backbone-debug", "sarike/jquery-ui/1.10.3/jquery-ui-debug", "sarike/jquery-noty/2.1.0/jquery-noty-debug", "sarike/timefly/0.0.1/editor/editor-debug", "sarike/jquery-validate/1.11.1/jquery-validate-debug" ], function(require, exports, module) {
    "use strict";
    var libs = require("sarike/timefly/0.0.1/libs/libs-debug"), Editor = require("sarike/timefly/0.0.1/editor/editor-debug"), $ = require("$-debug"), _ = require("gallery/underscore/1.4.4/underscore-debug"), Backbone = require("gallery/backbone/1.0.0/backbone-debug");
    require("sarike/jquery-validate/1.11.1/jquery-validate-debug");
    // Models
    var BaseModel = Backbone.Model.extend({
        queryString: {}
    });
    var BaseUser = Backbone.Model.extend({
        initialize: function() {
            this.on("update-user-event", this.updateUser, this);
        },
        updateUser: function(data) {
            this.set(data);
        }
    });
    // Collections
    var BaseCollection = Backbone.Collection.extend({
        model: BaseModel,
        initialize: function() {
            this.queryString = {};
        },
        parse: function(res) {
            return res.data.items;
        }
    });
    // Views
    var Item = Backbone.View.extend({
        initialize: function() {
            this.model.bind("change", $.proxy(this.render, this));
        },
        render: function() {
            this.$el.html(this.template(this.model.toJSON()));
            return this;
        }
    });
    var EmptyView = Backbone.View.extend({
        template: _.template(require("sarike/timefly/0.0.1/common/base/templates/common_empty-debug.tpl")),
        render: function() {
            this.$el.html(this.template());
            this.$el.show();
            return this;
        },
        hide: function() {
            this.$el.hide();
        }
    });
    var ItemsContainer = Backbone.View.extend({
        itemContainer: null,
        emptyView: new EmptyView(),
        initialize: function() {
            if (this.collection) {
                this.collection.bind("add", this.addItem, this);
            } else {
                console.error("No collection!");
            }
            this.ItemView = this.ItemView || this.options.ItemView;
        },
        render: function() {
            this.$el.html(this.template());
            return this;
        },
        refresh: function(data) {
            this.$el.empty();
            if (this.collection) {
                this.collection.fetch({
                    success: $.proxy(function(collection) {
                        if (collection.length === 0) {
                            this.renderEmpty();
                        }
                    }, this),
                    data: data || {}
                });
            }
        },
        reRender: function() {
            if (this.itemContainer) {
                this.itemContainer.empty();
            } else {
                this.$el.empty();
            }
            this.collection.each(this.addItem, this);
        },
        renderEmpty: function() {
            this.$el.html(this.emptyView.render().el);
        },
        addItem: function(model) {
            if (this.collection.length > 0) {
                this.emptyView.hide();
            }
            if (!this.ItemView) {
                console.warn("No ItemView!");
                return;
            }
            var itemView = new this.ItemView({
                model: model
            });
            itemView.$el.hide();
            if (this.itemContainer) {
                this.$(this.itemContainer).prepend(itemView.render().el);
            } else {
                this.$el.prepend(itemView.render().el);
            }
            itemView.$el.fadeIn();
        }
    });
    var PlainBox = Backbone.View.extend({
        className: ""
    });
    var ObjectBox = Backbone.View.extend({
        className: "box",
        render: function() {
            this.$el.html(this.template(!this.model ? {} : this.model.toJSON()));
            return this;
        }
    });
    var ArrayBox = ItemsContainer.extend({
        className: "box"
    });
    var ObjectContent = ObjectBox.extend({
        has_title: true,
        base_template: _.template(require("sarike/timefly/0.0.1/common/base/templates/common_content-debug.tpl")),
        render: function() {
            this.renderMainContent();
            this.renderSubContent();
            return this;
        },
        renderMainContent: function() {
            this.$el.html(this.base_template({
                has_title: this.title,
                title: this.title || this.options.title,
                sub_title: this.sub_title || this.options.sub_title
            }));
        },
        renderSubContent: function() {
            if (this.template) {
                if (this.options.data) {
                    this.$el.append(this.template(this.options.data));
                } else if (this.model) {
                    var self = this;
                    this.model.fetch({
                        data: this.model.queryString,
                        success: function(model) {
                            self.$el.append(self.template(model.toJSON()));
                        }
                    });
                } else {
                    this.$el.append(this.template());
                }
            }
        }
    });
    var Content = ArrayBox.extend({
        has_title: true,
        base_template: _.template(require("sarike/timefly/0.0.1/common/base/templates/common_content-debug.tpl")),
        render: function() {
            this.renderMainContent();
            this.renderSubContent();
            return this;
        },
        renderMainContent: function() {
            this.$el.html(this.base_template({
                has_title: this.title,
                title: this.title || this.options.title,
                sub_title: this.sub_title || this.options.sub_title
            }));
        },
        renderSubContent: function() {
            if (this.template) {
                this.$el.append(this.template(this.options.data));
            }
        },
        renderEmpty: function() {
            this.$el.append(this.emptyView.render().el);
        }
    });
    var TodoEditor = Editor.extend({
        text_area_name: "todo_description",
        editor_label: "描述一下该计划打算要完成的事情"
    });
    var AddOrEditTodoView = Backbone.View.extend({
        template: _.template(require("sarike/timefly/0.0.1/common/base/templates/add_edit_todo-debug.tpl")),
        className: "box",
        events: {
            "click button.submit": "submitTodoForm",
            "click button.cancel": "cancel"
        },
        render: function() {
            this.$el.html(this.template());
            this.$(".editor-field").html(this.editor.render().el);
            this.initFormValidation();
            this.initDatePicker();
            return this;
        },
        submitTodoForm: function(e) {
            this.$("#add_todo_form").submit();
            delete this.options.header.addOrEditNewTodoView;
            e.preventDefault();
        },
        destroy: function() {
            this.$el.remove();
        },
        cancel: function() {
            this.$el.slideUp();
            return false;
        },
        initFormValidation: function() {
            var todo_form = this.$("#add_todo_form");
            var self = this;
            todo_form.validate({
                errorClass: "input-error",
                submitHandler: _.once(function(form) {
                    $(form).ajaxSubmit($.proxy(function(res) {
                        if (this.contentView.collection) {
                            this.contentView.collection.add(res.data);
                        }
                        self.destroy();
                    }, self));
                }),
                ignore: "input[type='checkbox']",
                errorPlacement: function(error, element) {},
                rules: {
                    todo_name: {
                        required: true,
                        maxlength: 128
                    },
                    todo_description: "required",
                    todo_start: {
                        required: true,
                        date: true
                    },
                    todo_end: {
                        required: true,
                        date: true
                    }
                }
            });
        },
        initDatePicker: function() {
            var start_date = this.$("#id_todo_start"), end_date = this.$("#id_todo_end");
            start_date.datepicker({
                defaultDate: "+1w",
                minDate: "+0d",
                changeYear: true,
                onClose: function(selectedDate) {
                    end_date.datepicker("option", "minDate", selectedDate);
                }
            });
            end_date.datepicker({
                defaultDate: "+1w",
                minDate: "+0d",
                changeYear: true,
                onClose: function(selectedDate) {
                    start_date.datepicker("option", "maxDate", selectedDate);
                }
            });
        },
        initialize: function() {
            this.editor = new TodoEditor();
            this.contentView = this.options.contentView;
        }
    });
    var Header = Backbone.View.extend({
        template: _.template(require("sarike/timefly/0.0.1/common/base/templates/common_header-debug.tpl")),
        events: {
            "click .add-new-todo": "addNewTodo",
            "click #login-btn": "doLogin",
            "click #reg-btn": "doReg"
        },
        doLogin: function() {
            this.$("#login-form").ajaxSubmit($.proxy(function(res) {
                if (res.response === "ok") {
                    res.data.user.self_home = res.data.user.username === this.user.get("other_home_owner");
                    res.data.user.at_index_page = !res.data.user.self_home;
                    this.user.trigger("update-user-event", res.data.user);
                    this.render();
                    if (res.data.user.self_home) {
                        this.contentView.reRender();
                    }
                } else {
                    libs.Noty.NotyWithRes(res);
                }
            }, this));
        },
        doReg: function() {},
        addNewTodo: function() {
            if (!this.addOrEditNewTodoView) {
                this.addOrEditNewTodoView = new AddOrEditTodoView({
                    contentView: this.contentView,
                    header: this
                });
                this.addOrEditNewTodoView.$el.hide();
                $("#content").prepend(this.addOrEditNewTodoView.render().el);
            }
            this.addOrEditNewTodoView.$el.slideToggle();
        },
        initialize: function() {
            this.user = this.options.user;
            this.contentView = this.options.content;
        },
        render: function() {
            this.$el.html(this.template({
                user: this.user.toJSON()
            }));
            return this;
        }
    });
    var Footer = Backbone.View.extend({});
    module.exports = {
        Models: {
            BaseModel: BaseModel,
            BaseUser: BaseUser
        },
        Collections: {
            BaseCollection: BaseCollection
        },
        Views: {
            Item: Item,
            ItemsContainer: ItemsContainer,
            EmptyView: EmptyView,
            ObjectBox: ObjectBox,
            ArrayBox: ArrayBox,
            PlainBox: PlainBox,
            Content: Content,
            ObjectContent: ObjectContent,
            Header: Header,
            Footer: Footer
        }
    };
});

/**
 * Created by Sarike on 13-12-6.
 */
define("sarike/timefly/0.0.1/editor/editor-debug", [ "$-debug", "gallery/backbone/1.0.0/backbone-debug", "gallery/underscore/1.4.4/underscore-debug" ], function(require) {
    "use strict";
    var $ = require("$-debug"), Backbone = require("gallery/backbone/1.0.0/backbone-debug"), _ = require("gallery/underscore/1.4.4/underscore-debug");
    var editorTemplate = require("sarike/timefly/0.0.1/editor/templates/editor-debug.tpl");
    var EditorView = Backbone.View.extend({
        template: _.template(editorTemplate),
        className: "md-editor",
        text_area_name: "",
        editor_label: "",
        events: {
            "click .op-preview": "preView",
            "click .op-edit": "edit"
        },
        preView: function() {
            this.$(".preview-content").html(window.tf.md.toHTML(this.getValue())).show();
            this.$(".op-edit").show();
            this.$(".op-preview").hide();
            this.$("#md-editor-content").hide();
        },
        edit: function() {
            this.$(".preview-content").empty().hide();
            this.$(".op-edit").hide();
            this.$(".op-preview").show();
            this.$("#md-editor-content").show();
        },
        render: function() {
            this.$el.html(this.template({
                text_area_name: this.text_area_name,
                editor_label: this.editor_label
            }));
            return this;
        },
        getValue: function() {
            return this.$("#md-editor-content").val();
        }
    });
    return EditorView;
});

define("sarike/timefly/0.0.1/editor/templates/editor-debug.tpl", [], '<div class="md-editor-ops">\n    <a class="op-preview" href="javascript:void(0);" title="预览">\n        <i class="icon-search"></i>\n    </a>\n    <a class="op-edit hide" href="javascript:void(0);" title="编辑">\n        <i class="icon-edit"></i>\n    </a>\n</div>\n<label for="md-editor-content"><%=editor_label %></label>\n<textarea cols="40" id="md-editor-content" rows="10" name="<%=text_area_name %>" class="input-block-level"></textarea>\n<div class="preview-content markdown hide"></div>');

/*!
 * jQuery Validation Plugin 1.11.1
 *
 * http://bassistance.de/jquery-plugins/jquery-plugin-validation/
 * http://docs.jquery.com/Plugins/Validation
 *
 * Copyright 2013 Jörn Zaefferer
 * Released under the MIT license:
 *   http://www.opensource.org/licenses/mit-license.php
 */
define("sarike/jquery-validate/1.11.1/jquery-validate-debug", [ "$-debug" ], function(require) {
    var jQuery = require("$-debug");
    (function($) {
        $.extend($.fn, {
            // http://docs.jquery.com/Plugins/Validation/validate
            validate: function(options) {
                // if nothing is selected, return nothing; can't chain anyway
                if (!this.length) {
                    if (options && options.debug && window.console) {
                        console.warn("Nothing selected, can't validate, returning nothing.");
                    }
                    return;
                }
                // check if a validator for this form was already created
                var validator = $.data(this[0], "validator");
                if (validator) {
                    return validator;
                }
                // Add novalidate tag if HTML5.
                this.attr("novalidate", "novalidate");
                validator = new $.validator(options, this[0]);
                $.data(this[0], "validator", validator);
                if (validator.settings.onsubmit) {
                    this.validateDelegate(":submit", "click", function(event) {
                        if (validator.settings.submitHandler) {
                            validator.submitButton = event.target;
                        }
                        // allow suppressing validation by adding a cancel class to the submit button
                        if ($(event.target).hasClass("cancel")) {
                            validator.cancelSubmit = true;
                        }
                        // allow suppressing validation by adding the html5 formnovalidate attribute to the submit button
                        if ($(event.target).attr("formnovalidate") !== undefined) {
                            validator.cancelSubmit = true;
                        }
                    });
                    // validate the form on submit
                    this.submit(function(event) {
                        if (validator.settings.debug) {
                            // prevent form submit to be able to see console output
                            event.preventDefault();
                        }
                        function handle() {
                            var hidden;
                            if (validator.settings.submitHandler) {
                                if (validator.submitButton) {
                                    // insert a hidden input as a replacement for the missing submit button
                                    hidden = $("<input type='hidden'/>").attr("name", validator.submitButton.name).val($(validator.submitButton).val()).appendTo(validator.currentForm);
                                }
                                validator.settings.submitHandler.call(validator, validator.currentForm, event);
                                if (validator.submitButton) {
                                    // and clean up afterwards; thanks to no-block-scope, hidden can be referenced
                                    hidden.remove();
                                }
                                return false;
                            }
                            return true;
                        }
                        // prevent submit for invalid forms or custom submit handlers
                        if (validator.cancelSubmit) {
                            validator.cancelSubmit = false;
                            return handle();
                        }
                        if (validator.form()) {
                            if (validator.pendingRequest) {
                                validator.formSubmitted = true;
                                return false;
                            }
                            return handle();
                        } else {
                            validator.focusInvalid();
                            return false;
                        }
                    });
                }
                return validator;
            },
            // http://docs.jquery.com/Plugins/Validation/valid
            valid: function() {
                if ($(this[0]).is("form")) {
                    return this.validate().form();
                } else {
                    var valid = true;
                    var validator = $(this[0].form).validate();
                    this.each(function() {
                        valid = valid && validator.element(this);
                    });
                    return valid;
                }
            },
            // attributes: space seperated list of attributes to retrieve and remove
            removeAttrs: function(attributes) {
                var result = {}, $element = this;
                $.each(attributes.split(/\s/), function(index, value) {
                    result[value] = $element.attr(value);
                    $element.removeAttr(value);
                });
                return result;
            },
            // http://docs.jquery.com/Plugins/Validation/rules
            rules: function(command, argument) {
                var element = this[0];
                if (command) {
                    var settings = $.data(element.form, "validator").settings;
                    var staticRules = settings.rules;
                    var existingRules = $.validator.staticRules(element);
                    switch (command) {
                      case "add":
                        $.extend(existingRules, $.validator.normalizeRule(argument));
                        // remove messages from rules, but allow them to be set separetely
                        delete existingRules.messages;
                        staticRules[element.name] = existingRules;
                        if (argument.messages) {
                            settings.messages[element.name] = $.extend(settings.messages[element.name], argument.messages);
                        }
                        break;

                      case "remove":
                        if (!argument) {
                            delete staticRules[element.name];
                            return existingRules;
                        }
                        var filtered = {};
                        $.each(argument.split(/\s/), function(index, method) {
                            filtered[method] = existingRules[method];
                            delete existingRules[method];
                        });
                        return filtered;
                    }
                }
                var data = $.validator.normalizeRules($.extend({}, $.validator.classRules(element), $.validator.attributeRules(element), $.validator.dataRules(element), $.validator.staticRules(element)), element);
                // make sure required is at front
                if (data.required) {
                    var param = data.required;
                    delete data.required;
                    data = $.extend({
                        required: param
                    }, data);
                }
                return data;
            }
        });
        // Custom selectors
        $.extend($.expr[":"], {
            // http://docs.jquery.com/Plugins/Validation/blank
            blank: function(a) {
                return !$.trim("" + $(a).val());
            },
            // http://docs.jquery.com/Plugins/Validation/filled
            filled: function(a) {
                return !!$.trim("" + $(a).val());
            },
            // http://docs.jquery.com/Plugins/Validation/unchecked
            unchecked: function(a) {
                return !$(a).prop("checked");
            }
        });
        // constructor for validator
        $.validator = function(options, form) {
            this.settings = $.extend(true, {}, $.validator.defaults, options);
            this.currentForm = form;
            this.init();
        };
        $.validator.format = function(source, params) {
            if (arguments.length === 1) {
                return function() {
                    var args = $.makeArray(arguments);
                    args.unshift(source);
                    return $.validator.format.apply(this, args);
                };
            }
            if (arguments.length > 2 && params.constructor !== Array) {
                params = $.makeArray(arguments).slice(1);
            }
            if (params.constructor !== Array) {
                params = [ params ];
            }
            $.each(params, function(i, n) {
                source = source.replace(new RegExp("\\{" + i + "\\}", "g"), function() {
                    return n;
                });
            });
            return source;
        };
        $.extend($.validator, {
            defaults: {
                messages: {},
                groups: {},
                rules: {},
                errorClass: "error",
                validClass: "valid",
                errorElement: "label",
                focusInvalid: true,
                errorContainer: $([]),
                errorLabelContainer: $([]),
                onsubmit: true,
                ignore: ":hidden",
                ignoreTitle: false,
                onfocusin: function(element, event) {
                    this.lastActive = element;
                    // hide error label and remove error class on focus if enabled
                    if (this.settings.focusCleanup && !this.blockFocusCleanup) {
                        if (this.settings.unhighlight) {
                            this.settings.unhighlight.call(this, element, this.settings.errorClass, this.settings.validClass);
                        }
                        this.addWrapper(this.errorsFor(element)).hide();
                    }
                },
                onfocusout: function(element, event) {
                    if (!this.checkable(element) && (element.name in this.submitted || !this.optional(element))) {
                        this.element(element);
                    }
                },
                onkeyup: function(element, event) {
                    if (event.which === 9 && this.elementValue(element) === "") {
                        return;
                    } else if (element.name in this.submitted || element === this.lastElement) {
                        this.element(element);
                    }
                },
                onclick: function(element, event) {
                    // click on selects, radiobuttons and checkboxes
                    if (element.name in this.submitted) {
                        this.element(element);
                    } else if (element.parentNode.name in this.submitted) {
                        this.element(element.parentNode);
                    }
                },
                highlight: function(element, errorClass, validClass) {
                    if (element.type === "radio") {
                        this.findByName(element.name).addClass(errorClass).removeClass(validClass);
                    } else {
                        $(element).addClass(errorClass).removeClass(validClass);
                    }
                },
                unhighlight: function(element, errorClass, validClass) {
                    if (element.type === "radio") {
                        this.findByName(element.name).removeClass(errorClass).addClass(validClass);
                    } else {
                        $(element).removeClass(errorClass).addClass(validClass);
                    }
                }
            },
            // http://docs.jquery.com/Plugins/Validation/Validator/setDefaults
            setDefaults: function(settings) {
                $.extend($.validator.defaults, settings);
            },
            messages: {
                required: "This field is required.",
                remote: "Please fix this field.",
                email: "Please enter a valid email address.",
                url: "Please enter a valid URL.",
                date: "Please enter a valid date.",
                dateISO: "Please enter a valid date (ISO).",
                number: "Please enter a valid number.",
                digits: "Please enter only digits.",
                creditcard: "Please enter a valid credit card number.",
                equalTo: "Please enter the same value again.",
                maxlength: $.validator.format("Please enter no more than {0} characters."),
                minlength: $.validator.format("Please enter at least {0} characters."),
                rangelength: $.validator.format("Please enter a value between {0} and {1} characters long."),
                range: $.validator.format("Please enter a value between {0} and {1}."),
                max: $.validator.format("Please enter a value less than or equal to {0}."),
                min: $.validator.format("Please enter a value greater than or equal to {0}.")
            },
            autoCreateRanges: false,
            prototype: {
                init: function() {
                    this.labelContainer = $(this.settings.errorLabelContainer);
                    this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm);
                    this.containers = $(this.settings.errorContainer).add(this.settings.errorLabelContainer);
                    this.submitted = {};
                    this.valueCache = {};
                    this.pendingRequest = 0;
                    this.pending = {};
                    this.invalid = {};
                    this.reset();
                    var groups = this.groups = {};
                    $.each(this.settings.groups, function(key, value) {
                        if (typeof value === "string") {
                            value = value.split(/\s/);
                        }
                        $.each(value, function(index, name) {
                            groups[name] = key;
                        });
                    });
                    var rules = this.settings.rules;
                    $.each(rules, function(key, value) {
                        rules[key] = $.validator.normalizeRule(value);
                    });
                    function delegate(event) {
                        var validator = $.data(this[0].form, "validator"), eventType = "on" + event.type.replace(/^validate/, "");
                        if (validator.settings[eventType]) {
                            validator.settings[eventType].call(validator, this[0], event);
                        }
                    }
                    $(this.currentForm).validateDelegate(":text, [type='password'], [type='file'], select, textarea, " + "[type='number'], [type='search'] ,[type='tel'], [type='url'], " + "[type='email'], [type='datetime'], [type='date'], [type='month'], " + "[type='week'], [type='time'], [type='datetime-local'], " + "[type='range'], [type='color'] ", "focusin focusout keyup", delegate).validateDelegate("[type='radio'], [type='checkbox'], select, option", "click", delegate);
                    if (this.settings.invalidHandler) {
                        $(this.currentForm).bind("invalid-form.validate", this.settings.invalidHandler);
                    }
                },
                // http://docs.jquery.com/Plugins/Validation/Validator/form
                form: function() {
                    this.checkForm();
                    $.extend(this.submitted, this.errorMap);
                    this.invalid = $.extend({}, this.errorMap);
                    if (!this.valid()) {
                        $(this.currentForm).triggerHandler("invalid-form", [ this ]);
                    }
                    this.showErrors();
                    return this.valid();
                },
                checkForm: function() {
                    this.prepareForm();
                    for (var i = 0, elements = this.currentElements = this.elements(); elements[i]; i++) {
                        this.check(elements[i]);
                    }
                    return this.valid();
                },
                // http://docs.jquery.com/Plugins/Validation/Validator/element
                element: function(element) {
                    element = this.validationTargetFor(this.clean(element));
                    this.lastElement = element;
                    this.prepareElement(element);
                    this.currentElements = $(element);
                    var result = this.check(element) !== false;
                    if (result) {
                        delete this.invalid[element.name];
                    } else {
                        this.invalid[element.name] = true;
                    }
                    if (!this.numberOfInvalids()) {
                        // Hide error containers on last error
                        this.toHide = this.toHide.add(this.containers);
                    }
                    this.showErrors();
                    return result;
                },
                // http://docs.jquery.com/Plugins/Validation/Validator/showErrors
                showErrors: function(errors) {
                    if (errors) {
                        // add items to error list and map
                        $.extend(this.errorMap, errors);
                        this.errorList = [];
                        for (var name in errors) {
                            this.errorList.push({
                                message: errors[name],
                                element: this.findByName(name)[0]
                            });
                        }
                        // remove items from success list
                        this.successList = $.grep(this.successList, function(element) {
                            return !(element.name in errors);
                        });
                    }
                    if (this.settings.showErrors) {
                        this.settings.showErrors.call(this, this.errorMap, this.errorList);
                    } else {
                        this.defaultShowErrors();
                    }
                },
                // http://docs.jquery.com/Plugins/Validation/Validator/resetForm
                resetForm: function() {
                    if ($.fn.resetForm) {
                        $(this.currentForm).resetForm();
                    }
                    this.submitted = {};
                    this.lastElement = null;
                    this.prepareForm();
                    this.hideErrors();
                    this.elements().removeClass(this.settings.errorClass).removeData("previousValue");
                },
                numberOfInvalids: function() {
                    return this.objectLength(this.invalid);
                },
                objectLength: function(obj) {
                    var count = 0;
                    for (var i in obj) {
                        count++;
                    }
                    return count;
                },
                hideErrors: function() {
                    this.addWrapper(this.toHide).hide();
                },
                valid: function() {
                    return this.size() === 0;
                },
                size: function() {
                    return this.errorList.length;
                },
                focusInvalid: function() {
                    if (this.settings.focusInvalid) {
                        try {
                            $(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(":visible").focus().trigger("focusin");
                        } catch (e) {}
                    }
                },
                findLastActive: function() {
                    var lastActive = this.lastActive;
                    return lastActive && $.grep(this.errorList, function(n) {
                        return n.element.name === lastActive.name;
                    }).length === 1 && lastActive;
                },
                elements: function() {
                    var validator = this, rulesCache = {};
                    // select all valid inputs inside the form (no submit or reset buttons)
                    return $(this.currentForm).find("input, select, textarea").not(":submit, :reset, :image, [disabled]").not(this.settings.ignore).filter(function() {
                        if (!this.name && validator.settings.debug && window.console) {
                            console.error("%o has no name assigned", this);
                        }
                        // select only the first element for each name, and only those with rules specified
                        if (this.name in rulesCache || !validator.objectLength($(this).rules())) {
                            return false;
                        }
                        rulesCache[this.name] = true;
                        return true;
                    });
                },
                clean: function(selector) {
                    return $(selector)[0];
                },
                errors: function() {
                    var errorClass = this.settings.errorClass.replace(" ", ".");
                    return $(this.settings.errorElement + "." + errorClass, this.errorContext);
                },
                reset: function() {
                    this.successList = [];
                    this.errorList = [];
                    this.errorMap = {};
                    this.toShow = $([]);
                    this.toHide = $([]);
                    this.currentElements = $([]);
                },
                prepareForm: function() {
                    this.reset();
                    this.toHide = this.errors().add(this.containers);
                },
                prepareElement: function(element) {
                    this.reset();
                    this.toHide = this.errorsFor(element);
                },
                elementValue: function(element) {
                    var type = $(element).attr("type"), val = $(element).val();
                    if (type === "radio" || type === "checkbox") {
                        return $("input[name='" + $(element).attr("name") + "']:checked").val();
                    }
                    if (typeof val === "string") {
                        return val.replace(/\r/g, "");
                    }
                    return val;
                },
                check: function(element) {
                    element = this.validationTargetFor(this.clean(element));
                    var rules = $(element).rules();
                    var dependencyMismatch = false;
                    var val = this.elementValue(element);
                    var result;
                    for (var method in rules) {
                        var rule = {
                            method: method,
                            parameters: rules[method]
                        };
                        try {
                            result = $.validator.methods[method].call(this, val, element, rule.parameters);
                            // if a method indicates that the field is optional and therefore valid,
                            // don't mark it as valid when there are no other rules
                            if (result === "dependency-mismatch") {
                                dependencyMismatch = true;
                                continue;
                            }
                            dependencyMismatch = false;
                            if (result === "pending") {
                                this.toHide = this.toHide.not(this.errorsFor(element));
                                return;
                            }
                            if (!result) {
                                this.formatAndAdd(element, rule);
                                return false;
                            }
                        } catch (e) {
                            if (this.settings.debug && window.console) {
                                console.log("Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e);
                            }
                            throw e;
                        }
                    }
                    if (dependencyMismatch) {
                        return;
                    }
                    if (this.objectLength(rules)) {
                        this.successList.push(element);
                    }
                    return true;
                },
                // return the custom message for the given element and validation method
                // specified in the element's HTML5 data attribute
                customDataMessage: function(element, method) {
                    return $(element).data("msg-" + method.toLowerCase()) || element.attributes && $(element).attr("data-msg-" + method.toLowerCase());
                },
                // return the custom message for the given element name and validation method
                customMessage: function(name, method) {
                    var m = this.settings.messages[name];
                    return m && (m.constructor === String ? m : m[method]);
                },
                // return the first defined argument, allowing empty strings
                findDefined: function() {
                    for (var i = 0; i < arguments.length; i++) {
                        if (arguments[i] !== undefined) {
                            return arguments[i];
                        }
                    }
                    return undefined;
                },
                defaultMessage: function(element, method) {
                    return this.findDefined(this.customMessage(element.name, method), this.customDataMessage(element, method), // title is never undefined, so handle empty string as undefined
                    !this.settings.ignoreTitle && element.title || undefined, $.validator.messages[method], "<strong>Warning: No message defined for " + element.name + "</strong>");
                },
                formatAndAdd: function(element, rule) {
                    var message = this.defaultMessage(element, rule.method), theregex = /\$?\{(\d+)\}/g;
                    if (typeof message === "function") {
                        message = message.call(this, rule.parameters, element);
                    } else if (theregex.test(message)) {
                        message = $.validator.format(message.replace(theregex, "{$1}"), rule.parameters);
                    }
                    this.errorList.push({
                        message: message,
                        element: element
                    });
                    this.errorMap[element.name] = message;
                    this.submitted[element.name] = message;
                },
                addWrapper: function(toToggle) {
                    if (this.settings.wrapper) {
                        toToggle = toToggle.add(toToggle.parent(this.settings.wrapper));
                    }
                    return toToggle;
                },
                defaultShowErrors: function() {
                    var i, elements;
                    for (i = 0; this.errorList[i]; i++) {
                        var error = this.errorList[i];
                        if (this.settings.highlight) {
                            this.settings.highlight.call(this, error.element, this.settings.errorClass, this.settings.validClass);
                        }
                        this.showLabel(error.element, error.message);
                    }
                    if (this.errorList.length) {
                        this.toShow = this.toShow.add(this.containers);
                    }
                    if (this.settings.success) {
                        for (i = 0; this.successList[i]; i++) {
                            this.showLabel(this.successList[i]);
                        }
                    }
                    if (this.settings.unhighlight) {
                        for (i = 0, elements = this.validElements(); elements[i]; i++) {
                            this.settings.unhighlight.call(this, elements[i], this.settings.errorClass, this.settings.validClass);
                        }
                    }
                    this.toHide = this.toHide.not(this.toShow);
                    this.hideErrors();
                    this.addWrapper(this.toShow).show();
                },
                validElements: function() {
                    return this.currentElements.not(this.invalidElements());
                },
                invalidElements: function() {
                    return $(this.errorList).map(function() {
                        return this.element;
                    });
                },
                showLabel: function(element, message) {
                    var label = this.errorsFor(element);
                    if (label.length) {
                        // refresh error/success class
                        label.removeClass(this.settings.validClass).addClass(this.settings.errorClass);
                        // replace message on existing label
                        label.html(message);
                    } else {
                        // create label
                        label = $("<" + this.settings.errorElement + ">").attr("for", this.idOrName(element)).addClass(this.settings.errorClass).html(message || "");
                        if (this.settings.wrapper) {
                            // make sure the element is visible, even in IE
                            // actually showing the wrapped element is handled elsewhere
                            label = label.hide().show().wrap("<" + this.settings.wrapper + "/>").parent();
                        }
                        if (!this.labelContainer.append(label).length) {
                            if (this.settings.errorPlacement) {
                                this.settings.errorPlacement(label, $(element));
                            } else {
                                label.insertAfter(element);
                            }
                        }
                    }
                    if (!message && this.settings.success) {
                        label.text("");
                        if (typeof this.settings.success === "string") {
                            label.addClass(this.settings.success);
                        } else {
                            this.settings.success(label, element);
                        }
                    }
                    this.toShow = this.toShow.add(label);
                },
                errorsFor: function(element) {
                    var name = this.idOrName(element);
                    return this.errors().filter(function() {
                        return $(this).attr("for") === name;
                    });
                },
                idOrName: function(element) {
                    return this.groups[element.name] || (this.checkable(element) ? element.name : element.id || element.name);
                },
                validationTargetFor: function(element) {
                    // if radio/checkbox, validate first element in group instead
                    if (this.checkable(element)) {
                        element = this.findByName(element.name).not(this.settings.ignore)[0];
                    }
                    return element;
                },
                checkable: function(element) {
                    return /radio|checkbox/i.test(element.type);
                },
                findByName: function(name) {
                    return $(this.currentForm).find("[name='" + name + "']");
                },
                getLength: function(value, element) {
                    switch (element.nodeName.toLowerCase()) {
                      case "select":
                        return $("option:selected", element).length;

                      case "input":
                        if (this.checkable(element)) {
                            return this.findByName(element.name).filter(":checked").length;
                        }
                    }
                    return value.length;
                },
                depend: function(param, element) {
                    return this.dependTypes[typeof param] ? this.dependTypes[typeof param](param, element) : true;
                },
                dependTypes: {
                    "boolean": function(param, element) {
                        return param;
                    },
                    string: function(param, element) {
                        return !!$(param, element.form).length;
                    },
                    "function": function(param, element) {
                        return param(element);
                    }
                },
                optional: function(element) {
                    var val = this.elementValue(element);
                    return !$.validator.methods.required.call(this, val, element) && "dependency-mismatch";
                },
                startRequest: function(element) {
                    if (!this.pending[element.name]) {
                        this.pendingRequest++;
                        this.pending[element.name] = true;
                    }
                },
                stopRequest: function(element, valid) {
                    this.pendingRequest--;
                    // sometimes synchronization fails, make sure pendingRequest is never < 0
                    if (this.pendingRequest < 0) {
                        this.pendingRequest = 0;
                    }
                    delete this.pending[element.name];
                    if (valid && this.pendingRequest === 0 && this.formSubmitted && this.form()) {
                        $(this.currentForm).submit();
                        this.formSubmitted = false;
                    } else if (!valid && this.pendingRequest === 0 && this.formSubmitted) {
                        $(this.currentForm).triggerHandler("invalid-form", [ this ]);
                        this.formSubmitted = false;
                    }
                },
                previousValue: function(element) {
                    return $.data(element, "previousValue") || $.data(element, "previousValue", {
                        old: null,
                        valid: true,
                        message: this.defaultMessage(element, "remote")
                    });
                }
            },
            classRuleSettings: {
                required: {
                    required: true
                },
                email: {
                    email: true
                },
                url: {
                    url: true
                },
                date: {
                    date: true
                },
                dateISO: {
                    dateISO: true
                },
                number: {
                    number: true
                },
                digits: {
                    digits: true
                },
                creditcard: {
                    creditcard: true
                }
            },
            addClassRules: function(className, rules) {
                if (className.constructor === String) {
                    this.classRuleSettings[className] = rules;
                } else {
                    $.extend(this.classRuleSettings, className);
                }
            },
            classRules: function(element) {
                var rules = {};
                var classes = $(element).attr("class");
                if (classes) {
                    $.each(classes.split(" "), function() {
                        if (this in $.validator.classRuleSettings) {
                            $.extend(rules, $.validator.classRuleSettings[this]);
                        }
                    });
                }
                return rules;
            },
            attributeRules: function(element) {
                var rules = {};
                var $element = $(element);
                var type = $element[0].getAttribute("type");
                for (var method in $.validator.methods) {
                    var value;
                    // support for <input required> in both html5 and older browsers
                    if (method === "required") {
                        value = $element.get(0).getAttribute(method);
                        // Some browsers return an empty string for the required attribute
                        // and non-HTML5 browsers might have required="" markup
                        if (value === "") {
                            value = true;
                        }
                        // force non-HTML5 browsers to return bool
                        value = !!value;
                    } else {
                        value = $element.attr(method);
                    }
                    // convert the value to a number for number inputs, and for text for backwards compability
                    // allows type="date" and others to be compared as strings
                    if (/min|max/.test(method) && (type === null || /number|range|text/.test(type))) {
                        value = Number(value);
                    }
                    if (value) {
                        rules[method] = value;
                    } else if (type === method && type !== "range") {
                        // exception: the jquery validate 'range' method
                        // does not test for the html5 'range' type
                        rules[method] = true;
                    }
                }
                // maxlength may be returned as -1, 2147483647 (IE) and 524288 (safari) for text inputs
                if (rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength)) {
                    delete rules.maxlength;
                }
                return rules;
            },
            dataRules: function(element) {
                var method, value, rules = {}, $element = $(element);
                for (method in $.validator.methods) {
                    value = $element.data("rule-" + method.toLowerCase());
                    if (value !== undefined) {
                        rules[method] = value;
                    }
                }
                return rules;
            },
            staticRules: function(element) {
                var rules = {};
                var validator = $.data(element.form, "validator");
                if (validator.settings.rules) {
                    rules = $.validator.normalizeRule(validator.settings.rules[element.name]) || {};
                }
                return rules;
            },
            normalizeRules: function(rules, element) {
                // handle dependency check
                $.each(rules, function(prop, val) {
                    // ignore rule when param is explicitly false, eg. required:false
                    if (val === false) {
                        delete rules[prop];
                        return;
                    }
                    if (val.param || val.depends) {
                        var keepRule = true;
                        switch (typeof val.depends) {
                          case "string":
                            keepRule = !!$(val.depends, element.form).length;
                            break;

                          case "function":
                            keepRule = val.depends.call(element, element);
                            break;
                        }
                        if (keepRule) {
                            rules[prop] = val.param !== undefined ? val.param : true;
                        } else {
                            delete rules[prop];
                        }
                    }
                });
                // evaluate parameters
                $.each(rules, function(rule, parameter) {
                    rules[rule] = $.isFunction(parameter) ? parameter(element) : parameter;
                });
                // clean number parameters
                $.each([ "minlength", "maxlength" ], function() {
                    if (rules[this]) {
                        rules[this] = Number(rules[this]);
                    }
                });
                $.each([ "rangelength", "range" ], function() {
                    var parts;
                    if (rules[this]) {
                        if ($.isArray(rules[this])) {
                            rules[this] = [ Number(rules[this][0]), Number(rules[this][1]) ];
                        } else if (typeof rules[this] === "string") {
                            parts = rules[this].split(/[\s,]+/);
                            rules[this] = [ Number(parts[0]), Number(parts[1]) ];
                        }
                    }
                });
                if ($.validator.autoCreateRanges) {
                    // auto-create ranges
                    if (rules.min && rules.max) {
                        rules.range = [ rules.min, rules.max ];
                        delete rules.min;
                        delete rules.max;
                    }
                    if (rules.minlength && rules.maxlength) {
                        rules.rangelength = [ rules.minlength, rules.maxlength ];
                        delete rules.minlength;
                        delete rules.maxlength;
                    }
                }
                return rules;
            },
            // Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}
            normalizeRule: function(data) {
                if (typeof data === "string") {
                    var transformed = {};
                    $.each(data.split(/\s/), function() {
                        transformed[this] = true;
                    });
                    data = transformed;
                }
                return data;
            },
            // http://docs.jquery.com/Plugins/Validation/Validator/addMethod
            addMethod: function(name, method, message) {
                $.validator.methods[name] = method;
                $.validator.messages[name] = message !== undefined ? message : $.validator.messages[name];
                if (method.length < 3) {
                    $.validator.addClassRules(name, $.validator.normalizeRule(name));
                }
            },
            methods: {
                // http://docs.jquery.com/Plugins/Validation/Methods/required
                required: function(value, element, param) {
                    // check if dependency is met
                    if (!this.depend(param, element)) {
                        return "dependency-mismatch";
                    }
                    if (element.nodeName.toLowerCase() === "select") {
                        // could be an array for select-multiple or a string, both are fine this way
                        var val = $(element).val();
                        return val && val.length > 0;
                    }
                    if (this.checkable(element)) {
                        return this.getLength(value, element) > 0;
                    }
                    return $.trim(value).length > 0;
                },
                // http://docs.jquery.com/Plugins/Validation/Methods/email
                email: function(value, element) {
                    // contributed by Scott Gonzalez: http://projects.scottsplayground.com/email_address_validation/
                    return this.optional(element) || /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i.test(value);
                },
                // http://docs.jquery.com/Plugins/Validation/Methods/url
                url: function(value, element) {
                    // contributed by Scott Gonzalez: http://projects.scottsplayground.com/iri/
                    return this.optional(element) || /^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(value);
                },
                // http://docs.jquery.com/Plugins/Validation/Methods/date
                date: function(value, element) {
                    return this.optional(element) || !/Invalid|NaN/.test(new Date(value).toString());
                },
                // http://docs.jquery.com/Plugins/Validation/Methods/dateISO
                dateISO: function(value, element) {
                    return this.optional(element) || /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/.test(value);
                },
                // http://docs.jquery.com/Plugins/Validation/Methods/number
                number: function(value, element) {
                    return this.optional(element) || /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value);
                },
                // http://docs.jquery.com/Plugins/Validation/Methods/digits
                digits: function(value, element) {
                    return this.optional(element) || /^\d+$/.test(value);
                },
                // http://docs.jquery.com/Plugins/Validation/Methods/creditcard
                // based on http://en.wikipedia.org/wiki/Luhn
                creditcard: function(value, element) {
                    if (this.optional(element)) {
                        return "dependency-mismatch";
                    }
                    // accept only spaces, digits and dashes
                    if (/[^0-9 \-]+/.test(value)) {
                        return false;
                    }
                    var nCheck = 0, nDigit = 0, bEven = false;
                    value = value.replace(/\D/g, "");
                    for (var n = value.length - 1; n >= 0; n--) {
                        var cDigit = value.charAt(n);
                        nDigit = parseInt(cDigit, 10);
                        if (bEven) {
                            if ((nDigit *= 2) > 9) {
                                nDigit -= 9;
                            }
                        }
                        nCheck += nDigit;
                        bEven = !bEven;
                    }
                    return nCheck % 10 === 0;
                },
                // http://docs.jquery.com/Plugins/Validation/Methods/minlength
                minlength: function(value, element, param) {
                    var length = $.isArray(value) ? value.length : this.getLength($.trim(value), element);
                    return this.optional(element) || length >= param;
                },
                // http://docs.jquery.com/Plugins/Validation/Methods/maxlength
                maxlength: function(value, element, param) {
                    var length = $.isArray(value) ? value.length : this.getLength($.trim(value), element);
                    return this.optional(element) || length <= param;
                },
                // http://docs.jquery.com/Plugins/Validation/Methods/rangelength
                rangelength: function(value, element, param) {
                    var length = $.isArray(value) ? value.length : this.getLength($.trim(value), element);
                    return this.optional(element) || length >= param[0] && length <= param[1];
                },
                // http://docs.jquery.com/Plugins/Validation/Methods/min
                min: function(value, element, param) {
                    return this.optional(element) || value >= param;
                },
                // http://docs.jquery.com/Plugins/Validation/Methods/max
                max: function(value, element, param) {
                    return this.optional(element) || value <= param;
                },
                // http://docs.jquery.com/Plugins/Validation/Methods/range
                range: function(value, element, param) {
                    return this.optional(element) || value >= param[0] && value <= param[1];
                },
                // http://docs.jquery.com/Plugins/Validation/Methods/equalTo
                equalTo: function(value, element, param) {
                    // bind to the blur event of the target in order to revalidate whenever the target field is updated
                    // TODO find a way to bind the event just once, avoiding the unbind-rebind overhead
                    var target = $(param);
                    if (this.settings.onfocusout) {
                        target.unbind(".validate-equalTo").bind("blur.validate-equalTo", function() {
                            $(element).valid();
                        });
                    }
                    return value === target.val();
                },
                // http://docs.jquery.com/Plugins/Validation/Methods/remote
                remote: function(value, element, param) {
                    if (this.optional(element)) {
                        return "dependency-mismatch";
                    }
                    var previous = this.previousValue(element);
                    if (!this.settings.messages[element.name]) {
                        this.settings.messages[element.name] = {};
                    }
                    previous.originalMessage = this.settings.messages[element.name].remote;
                    this.settings.messages[element.name].remote = previous.message;
                    param = typeof param === "string" && {
                        url: param
                    } || param;
                    if (previous.old === value) {
                        return previous.valid;
                    }
                    previous.old = value;
                    var validator = this;
                    this.startRequest(element);
                    var data = {};
                    data[element.name] = value;
                    $.ajax($.extend(true, {
                        url: param,
                        mode: "abort",
                        port: "validate" + element.name,
                        dataType: "json",
                        data: data,
                        success: function(response) {
                            validator.settings.messages[element.name].remote = previous.originalMessage;
                            var valid = response === true || response === "true";
                            if (valid) {
                                var submitted = validator.formSubmitted;
                                validator.prepareElement(element);
                                validator.formSubmitted = submitted;
                                validator.successList.push(element);
                                delete validator.invalid[element.name];
                                validator.showErrors();
                            } else {
                                var errors = {};
                                var message = response || validator.defaultMessage(element, "remote");
                                errors[element.name] = previous.message = $.isFunction(message) ? message(value) : message;
                                validator.invalid[element.name] = true;
                                validator.showErrors(errors);
                            }
                            previous.valid = valid;
                            validator.stopRequest(element, valid);
                        }
                    }, param));
                    return "pending";
                }
            }
        });
        // deprecated, use $.validator.format instead
        $.format = $.validator.format;
    })(jQuery);
    // ajax mode: abort
    // usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});
    // if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()
    (function($) {
        var pendingRequests = {};
        // Use a prefilter if available (1.5+)
        if ($.ajaxPrefilter) {
            $.ajaxPrefilter(function(settings, _, xhr) {
                var port = settings.port;
                if (settings.mode === "abort") {
                    if (pendingRequests[port]) {
                        pendingRequests[port].abort();
                    }
                    pendingRequests[port] = xhr;
                }
            });
        } else {
            // Proxy ajax
            var ajax = $.ajax;
            $.ajax = function(settings) {
                var mode = ("mode" in settings ? settings : $.ajaxSettings).mode, port = ("port" in settings ? settings : $.ajaxSettings).port;
                if (mode === "abort") {
                    if (pendingRequests[port]) {
                        pendingRequests[port].abort();
                    }
                    pendingRequests[port] = ajax.apply(this, arguments);
                    return pendingRequests[port];
                }
                return ajax.apply(this, arguments);
            };
        }
    })(jQuery);
    // provides delegate(type: String, delegate: Selector, handler: Callback) plugin for easier event delegation
    // handler is only called when $(event.target).is(delegate), in the scope of the jquery-object for event.target
    (function($) {
        $.extend($.fn, {
            validateDelegate: function(delegate, type, handler) {
                return this.bind(type, function(event) {
                    var target = $(event.target);
                    if (target.is(delegate)) {
                        return handler.apply(target, arguments);
                    }
                });
            }
        });
    })(jQuery);
});

define("sarike/timefly/0.0.1/common/base/templates/common_empty-debug.tpl", [], '<div class="box">啥玩意儿都木有……</div>');

define("sarike/timefly/0.0.1/common/base/templates/common_content-debug.tpl", [], '<div class="box-header">\n    <% if(has_title){ %>\n    <h2><%=title || "No Title" %></h2>\n    <p class="box-subheader"><%=sub_title || "No Sub_title" %></p>\n    <% } %>\n</div>');

define("sarike/timefly/0.0.1/common/base/templates/add_edit_todo-debug.tpl", [], '<form id="add_todo_form" action="todo/add_todo" method="post" class="clearfix">\n    <h2>\n        <input type="text" placeholder="起一个响亮的名字" class="input-block-level"\n               id="id_todo_name" name="todo_name"/>\n        <span class="pull-right">\n        </span>\n    </h2>\n    <div class="todo_info">\n        该计划开始于 <input type="text" id="id_todo_start" name="todo_start"/> ，\n        计划在 <input type="text" id="id_todo_end" name="todo_end"/>  完成！\n    </div>\n    <div class="todo_desc markdown">\n        <div class="editor-field"></div>\n    </div>\n    <div>\n        <label class="checkbox pull-left">\n            <input type="checkbox" name="todo_visible" checked/>对所有人可见\n        </label>\n        <label class="checkbox pull-left margin-left20">\n            <input type="checkbox" name="todo_erasable"checked/> 背水一战，绝不删除\n        </label>\n    </div>\n    <div class="add-todo-ops">\n        <span class="pull-right">\n            <button class="btn btn-info submit">保存</button>\n            <button class="btn cancel">取消</button>\n        </span>\n    </div>\n</form>');

define("sarike/timefly/0.0.1/common/base/templates/common_header-debug.tpl", [], '<div class="navbar navbar-fixed-top">\n    <div class="navbar-inner">\n        <div class="container">\n            <ul class="nav">\n                <li <% if(user.at_index_page){ %>class="active"<% } %>>\n                    <a href="#" class=" clearfix">\n                        <span><i class="nav-home"></i></span>\n                        <span>主页</span>\n                    </a>\n                </li>\n                <% if(!!user && user.is_authenticated){ %>\n                <li <% if(user.self_home){ %>class="active"<% } %>>\n                    <a href="#<%=user.username %>" class=" clearfix">\n                        <span><i class="nav-me"></i></span>\n                        <span>我</span>\n                    </a>\n                </li>\n                <% } %>\n            </ul>\n\n            <div class="pull-right">\n                <% if(!!user && user.is_authenticated){ %>\n                <ul class="nav">\n                    <li>\n                        <a href="#" class=" clearfix dropdown-toggle" data-toggle="dropdown">\n									<span>\n                                        <%=user.nickname || user.username %>\n									</span>\n									<span>\n										<i class="caret"></i>\n									</span>\n                        </a>\n                        <ul class="dropdown-menu" role="menu" aria-labelledby="">\n                            <li role="presentation">\n                                <a role="menuitem" tabindex="-1" href="#<%= user.username %>/setting">\n                                    <i class="icon-user "></i> 个人资料\n                                </a>\n                            </li>\n                            <li role="presentation" class="divider"></li>\n                            <li role="presentation">\n                                <a role="menuitem" tabindex="-1" href="../account/logout">\n                                    <i class="icon-off"></i> 退出登录</a></li>\n                        </ul>\n                    </li>\n                </ul>\n                <button title="制定新计划" class="add-new-todo btn btn-info">\n                    <i class="nav-new-todo"></i><span></span>\n                </button>\n                <% }else{ %>\n                <form id="login-form" class="form-inline" action="account/ajax_login" method="post">\n                    <input type="text" name="email" class="input-medium" placeholder="Email">\n                    <input type="password" name="password" class="input-medium" placeholder="Password">\n                    <label class="checkbox">\n                        <input type="checkbox" name="remember"> 记住我\n                    </label>\n                    <button type="button" id="login-btn" class="btn btn-info">登录</button>\n                    <button class="btn btn-info" type="button" onclick="javascript:location.href=\'account/reg\'">注册\n                    </button>\n                </form>\n                <% } %>\n            </div>\n        </div>\n    </div>\n</div>');

define("sarike/timefly/0.0.1/common/box/box-debug", [ "$-debug", "gallery/underscore/1.4.4/underscore-debug", "sarike/timefly/0.0.1/libs/libs-debug", "gallery/backbone/1.0.0/backbone-debug", "sarike/jquery-ui/1.10.3/jquery-ui-debug", "sarike/jquery-noty/2.1.0/jquery-noty-debug", "sarike/timefly/0.0.1/common/base/base-debug", "sarike/timefly/0.0.1/editor/editor-debug", "sarike/jquery-validate/1.11.1/jquery-validate-debug" ], function(require, exports, module) {
    "use strict";
    var $ = require("$-debug"), _ = require("gallery/underscore/1.4.4/underscore-debug"), libs = require("sarike/timefly/0.0.1/libs/libs-debug"), Base = require("sarike/timefly/0.0.1/common/base/base-debug");
    var UserItem = Base.Views.Item.extend({
        template: _.template(require("sarike/timefly/0.0.1/common/box/templates/user_item-debug.tpl")),
        tagName: "li",
        className: "media"
    });
    var UsersBox = Base.Views.ArrayBox.extend({
        template: _.template(require("sarike/timefly/0.0.1/common/box/templates/user_list_box-debug.tpl")),
        ItemView: UserItem,
        itemContainer: ".media-list"
    });
    var AboutBox = Base.Views.ObjectBox.extend({
        template: _.template(require("sarike/timefly/0.0.1/common/box/templates/about_box-debug.tpl"))
    });
    var UserProfileBox = Base.Views.ObjectBox.extend({
        template: _.template(require("sarike/timefly/0.0.1/common/box/templates/user_profile_box-debug.tpl"))
    });
    var SideNavBox = Base.Views.PlainBox.extend({
        template: _.template(require("sarike/timefly/0.0.1/common/box/templates/side_nav_box-debug.tpl")),
        events: {
            "click .nav-list>li": "clickNavItem"
        },
        clickNavItem: function(e) {
            var nav = $(e.currentTarget);
            this.$("li").removeClass("active");
            nav.addClass("active");
            this.action(nav);
        },
        action: function(nav) {},
        render: function() {
            this.$el.html(this.template({
                side_nav_list: this.side_nav_list || this.options.side_nav_list || []
            }));
            return this;
        }
    });
    module.exports = {
        UserBox: UsersBox,
        AboutBox: AboutBox,
        UserProfileBox: UserProfileBox,
        SideNavBox: SideNavBox
    };
});

define("sarike/timefly/0.0.1/common/box/templates/user_item-debug.tpl", [], '<a class="pull-left" href="#<%=username %>"> <img\n        class="media-object img-rounded"\n        src="http://www.gravatar.com/avatar/<%=avatar_hash %>?d=identicon"\n        class="img-rounded" alt="Avatar">\n</a>\n\n<div class="media-body">\n    <h4 class="media-heading">\n        <a href="#<%=username %>">\n            <%=nickname %>\n        </a>\n    </h4>\n    <%=description || \'还没来得及说点什么呢\' %>\n</div>');

define("sarike/timefly/0.0.1/common/box/templates/user_list_box-debug.tpl", [], '<div id="friend-list">\n    <h3>\n        活跃用户 <a href="#">查看全部</a>\n    </h3>\n    <ul class="media-list">\n    </ul>\n</div>');

define("sarike/timefly/0.0.1/common/box/templates/about_box-debug.tpl", [], '<span class="copyright">&copy; 2013</span>\n<a href="#">关于</a>');

define("sarike/timefly/0.0.1/common/box/templates/user_profile_box-debug.tpl", [], '<div id="user-profile">\n        <div class="clearfix">\n            <div id="avatar" class="pull-left">\n                <img src="http://www.gravatar.com/avatar/<%=avatar_hash %>?d=identicon" class="img-rounded" alt="Avatar">\n            </div>\n            <div id="user-info" class="pull-left">\n                <h2>\n                    <%=nickname %>\n                </h2>\n                <ul>\n                    <li>努力中 <span class="badge badge-info"><%=ing_count %></span></li>\n                    <li>已完成 <span class="badge badge-success"><%=ed_count %></span></li>\n                    <li>未完成 <span class="badge badge-important"><%=fail_count %></span></li>\n                </ul>\n            </div>\n        </div>\n        <div id="user-desc"><%=description %></div>\n</div>');

define("sarike/timefly/0.0.1/common/box/templates/side_nav_box-debug.tpl", [], '<div id="menu">\n    <ul class="nav nav-list">\n        <% _.each(side_nav_list, function(nav){ %>\n        <li data-id="<%=nav.id %>" <% if(nav.active){ %>class="active"<% } %>>\n            <a href="javascript: void(0)"><%=nav.caption %><i class="icon-chevron-right pull-right"></i></a>\n        </li>\n        <% });%>\n    </ul>\n</div>');

// moment-timezone.js
// version : 0.0.3
// author : Tim Wood
// license : MIT
// github.com/timrwood/moment-timezone
define("sarike/moment-timezone/0.0.3/moment-timezone-debug", [ "sarike/moment/2.4.0/moment-debug" ], function(require) {
    var moment = require("sarike/moment/2.4.0/moment-debug");
    var VERSION = "0.0.3";
    var oldZoneName = moment.fn.zoneName, oldZoneAbbr = moment.fn.zoneAbbr, defaultRule, rules = {}, ruleSets = {}, zones = {}, zoneSets = {}, links = {}, TIME_RULE_WALL_CLOCK = 0, TIME_RULE_UTC = 1, TIME_RULE_STANDARD = 2, DAY_RULE_DAY_OF_MONTH = 7, DAY_RULE_LAST_WEEKDAY = 8;
    // converts time in the HH:mm:ss format to absolute number of minutes
    function parseMinutes(input) {
        input = input + "";
        var output = input.split(":"), sign = ~input.indexOf("-") ? -1 : 1, hour = Math.abs(+output[0]), minute = parseInt(output[1], 10) || 0, second = parseInt(output[2], 10) || 0;
        return sign * (hour * 60 + minute + second / 60);
    }
    /************************************
        Rules
    ************************************/
    function Rule(name, startYear, endYear, month, day, dayRule, time, timeRule, offset, letters) {
        this.name = name;
        this.startYear = +startYear;
        this.endYear = +endYear;
        this.month = +month;
        this.day = +day;
        this.dayRule = +dayRule;
        this.time = parseMinutes(time);
        this.timeRule = +timeRule;
        this.offset = parseMinutes(offset);
        this.letters = letters || "";
    }
    Rule.prototype = {
        contains: function(year) {
            return year >= this.startYear && year <= this.endYear;
        },
        start: function(year) {
            year = Math.min(Math.max(year, this.startYear), this.endYear);
            return moment.utc([ year, this.month, this.date(year), 0, this.time ]);
        },
        date: function(year) {
            if (this.dayRule === DAY_RULE_DAY_OF_MONTH) {
                return this.day;
            } else if (this.dayRule === DAY_RULE_LAST_WEEKDAY) {
                return this.lastWeekday(year);
            }
            return this.weekdayAfter(year);
        },
        weekdayAfter: function(year) {
            var day = this.day, firstDayOfWeek = moment([ year, this.month, 1 ]).day(), output = this.dayRule + 1 - firstDayOfWeek;
            while (output < day) {
                output += 7;
            }
            return output;
        },
        lastWeekday: function(year) {
            var day = this.day, dow = day % 7, lastDowOfMonth = moment([ year, this.month + 1, 1 ]).day(), daysInMonth = moment([ year, this.month, 1 ]).daysInMonth(), output = daysInMonth + (dow - (lastDowOfMonth - 1)) - ~~(day / 7) * 7;
            if (dow >= lastDowOfMonth) {
                output -= 7;
            }
            return output;
        }
    };
    /************************************
        Rule Year
    ************************************/
    function RuleYear(year, rule) {
        this.rule = rule;
        this.start = rule.start(year);
    }
    RuleYear.prototype = {
        equals: function(other) {
            if (!other || other.rule !== this.rule) {
                return false;
            }
            return Math.abs(other.start - this.start) < 864e5;
        }
    };
    function sortRuleYears(a, b) {
        if (a.isLast) {
            return -1;
        }
        if (b.isLast) {
            return 1;
        }
        return b.start - a.start;
    }
    /************************************
        Rule Sets
    ************************************/
    function RuleSet(name) {
        this.name = name;
        this.rules = [];
    }
    RuleSet.prototype = {
        add: function(rule) {
            this.rules.push(rule);
        },
        ruleYears: function(mom, lastZone) {
            var i, j, year = mom.year(), rule, lastZoneRule, rules = [];
            for (i = 0; i < this.rules.length; i++) {
                rule = this.rules[i];
                if (rule.contains(year)) {
                    rules.push(new RuleYear(year, rule));
                } else if (rule.contains(year + 1)) {
                    rules.push(new RuleYear(year + 1, rule));
                }
            }
            rules.push(new RuleYear(year - 1, this.lastYearRule(year - 1)));
            if (lastZone) {
                lastZoneRule = new RuleYear(year - 1, lastZone.lastRule());
                lastZoneRule.start = lastZone.until.clone().utc();
                lastZoneRule.isLast = lastZone.ruleSet !== this;
                rules.push(lastZoneRule);
            }
            rules.sort(sortRuleYears);
            return rules;
        },
        rule: function(mom, offset, lastZone) {
            var rules = this.ruleYears(mom, lastZone), lastOffset = 0, rule, lastZoneOffset, lastZoneOffsetAbs, lastRule, i;
            if (lastZone) {
                lastZoneOffset = lastZone.offset + lastZone.lastRule().offset;
                lastZoneOffsetAbs = Math.abs(lastZoneOffset) * 9e4;
            }
            // make sure to include the previous rule's offset
            for (i = rules.length - 1; i > -1; i--) {
                lastRule = rule;
                rule = rules[i];
                if (rule.equals(lastRule)) {
                    continue;
                }
                if (lastZone && !rule.isLast && Math.abs(rule.start - lastZone.until) <= lastZoneOffsetAbs) {
                    lastOffset += lastZoneOffset - offset;
                }
                if (rule.rule.timeRule === TIME_RULE_STANDARD) {
                    lastOffset = offset;
                }
                if (rule.rule.timeRule !== TIME_RULE_UTC) {
                    rule.start.add("m", -lastOffset);
                }
                lastOffset = rule.rule.offset + offset;
            }
            for (i = 0; i < rules.length; i++) {
                rule = rules[i];
                if (mom >= rule.start && !rule.isLast) {
                    return rule.rule;
                }
            }
            return defaultRule;
        },
        lastYearRule: function(year) {
            var i, rule, start, bestRule = defaultRule, largest = -1e30;
            for (i = 0; i < this.rules.length; i++) {
                rule = this.rules[i];
                if (year >= rule.startYear) {
                    start = rule.start(year);
                    if (start > largest) {
                        largest = start;
                        bestRule = rule;
                    }
                }
            }
            return bestRule;
        }
    };
    /************************************
        Zone
    ************************************/
    function Zone(name, offset, ruleSet, letters, until, untilOffset) {
        var i, untilArray = typeof until === "string" ? until.split("_") : [ 9999 ];
        this.name = name;
        this.offset = parseMinutes(offset);
        this.ruleSet = ruleSet;
        this.letters = letters;
        for (i = 0; i < untilArray.length; i++) {
            untilArray[i] = +untilArray[i];
        }
        this.until = moment.utc(untilArray).subtract("m", parseMinutes(untilOffset));
    }
    Zone.prototype = {
        rule: function(mom, lastZone) {
            return this.ruleSet.rule(mom, this.offset, lastZone);
        },
        lastRule: function() {
            if (!this._lastRule) {
                this._lastRule = this.rule(this.until);
            }
            return this._lastRule;
        },
        format: function(rule) {
            return this.letters.replace("%s", rule.letters);
        }
    };
    /************************************
        Zone Set
    ************************************/
    function sortZones(a, b) {
        return a.until - b.until;
    }
    function ZoneSet(name) {
        this.name = normalizeName(name);
        this.displayName = name;
        this.zones = [];
    }
    ZoneSet.prototype = {
        zoneAndRule: function(mom) {
            var i, zone, lastZone;
            mom = mom.clone().utc();
            for (i = 0; i < this.zones.length; i++) {
                zone = this.zones[i];
                if (mom < zone.until) {
                    break;
                }
                lastZone = zone;
            }
            return [ zone, zone.rule(mom, lastZone) ];
        },
        add: function(zone) {
            this.zones.push(zone);
            this.zones.sort(sortZones);
        },
        format: function(mom) {
            var zoneAndRule = this.zoneAndRule(mom);
            return zoneAndRule[0].format(zoneAndRule[1]);
        },
        offset: function(mom) {
            var zoneAndRule = this.zoneAndRule(mom);
            return -(zoneAndRule[0].offset + zoneAndRule[1].offset);
        }
    };
    /************************************
        Global Methods
    ************************************/
    function addRules(rules) {
        var i, j, rule;
        for (i in rules) {
            rule = rules[i];
            for (j = 0; j < rule.length; j++) {
                addRule(i + "	" + rule[j]);
            }
        }
    }
    function addRule(ruleString) {
        // don't duplicate rules
        if (rules[ruleString]) {
            return rules[ruleString];
        }
        var p = ruleString.split(/\s/), name = normalizeName(p[0]), rule = new Rule(name, p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10]);
        // cache the rule so we don't add it again
        rules[ruleString] = rule;
        // add to the ruleset
        getRuleSet(name).add(rule);
        return rule;
    }
    function normalizeName(name) {
        return (name || "").toLowerCase().replace(/\//g, "_");
    }
    function addZones(zones) {
        var i, j, zone;
        for (i in zones) {
            zone = zones[i];
            for (j = 0; j < zone.length; j++) {
                addZone(i + "	" + zone[j]);
            }
        }
    }
    function addLinks(linksToAdd) {
        var i;
        for (i in linksToAdd) {
            links[normalizeName(i)] = normalizeName(linksToAdd[i]);
        }
    }
    function addZone(zoneString) {
        // don't duplicate zones
        if (zones[zoneString]) {
            return zones[zoneString];
        }
        var p = zoneString.split(/\s/), name = normalizeName(p[0]), zone = new Zone(name, p[1], getRuleSet(p[2]), p[3], p[4], p[5]);
        // cache the zone so we don't add it again
        zones[zoneString] = zone;
        // add to the zoneset
        getZoneSet(p[0]).add(zone);
        return zone;
    }
    function getRuleSet(name) {
        name = normalizeName(name);
        if (!ruleSets[name]) {
            ruleSets[name] = new RuleSet(name);
        }
        return ruleSets[name];
    }
    function getZoneSet(name) {
        var machineName = normalizeName(name);
        if (links[machineName]) {
            machineName = links[machineName];
        }
        if (!zoneSets[machineName]) {
            zoneSets[machineName] = new ZoneSet(name);
        }
        return zoneSets[machineName];
    }
    function add(data) {
        if (!data) {
            return;
        }
        if (data.zones) {
            addZones(data.zones);
        }
        if (data.rules) {
            addRules(data.rules);
        }
        if (data.links) {
            addLinks(data.links);
        }
    }
    // overwrite moment.updateOffset
    moment.updateOffset = function(mom) {
        var offset;
        if (mom._z) {
            offset = mom._z.offset(mom);
            if (Math.abs(offset) < 16) {
                offset = offset / 60;
            }
            mom.zone(offset);
        }
    };
    function getZoneSets() {
        var sets = [], zoneName;
        for (zoneName in zoneSets) {
            sets.push(zoneSets[zoneName]);
        }
        return sets;
    }
    moment.fn.tz = function(name) {
        if (name) {
            this._z = getZoneSet(name);
            if (this._z) {
                moment.updateOffset(this);
            }
            return this;
        }
        if (this._z) {
            return this._z.displayName;
        }
    };
    moment.fn.zoneName = function() {
        if (this._z) {
            return this._z.format(this);
        }
        return oldZoneName.call(this);
    };
    moment.fn.zoneAbbr = function() {
        if (this._z) {
            return this._z.format(this);
        }
        return oldZoneAbbr.call(this);
    };
    moment.tz = function() {
        var args = [], i, len = arguments.length - 1;
        for (i = 0; i < len; i++) {
            args[i] = arguments[i];
        }
        var m = moment.apply(null, args);
        var preTzOffset = m.zone();
        m.tz(arguments[len]);
        return m.add("minutes", m.zone() - preTzOffset);
    };
    moment.tz.add = add;
    moment.tz.addRule = addRule;
    moment.tz.addZone = addZone;
    moment.tz.zones = getZoneSets;
    moment.tz.version = VERSION;
    // add default rule
    defaultRule = addRule("- 0 9999 0 0 0 0 0 0");
    moment.tz.add({
        zones: {
            "Asia/Chongqing": [ "7:6:20 - LMT 1928 7:6:20", "7 - LONT 1980_4 7", "8 PRC C%sT" ],
            "Asia/Hong_Kong": [ "7:36:42 - LMT 1904_9_30 7:36:42", "8 HK HK%sT 1941_11_25 8", "9 - JST 1945_8_15 9", "8 HK HK%sT" ],
            "Asia/Shanghai": [ "8:5:57 - LMT 1928 8:5:57", "8 Shang C%sT 1949 8", "8 PRC C%sT" ],
            "Asia/Taipei": [ "8:6 - LMT 1896 8:6", "8 Taiwan C%sT" ]
        },
        rules: {
            PRC: [ "1986 1986 4 4 7 0 0 1 D", "1986 1991 8 11 0 0 0 0 S", "1987 1991 3 10 0 0 0 1 D" ],
            HK: [ "1941 1941 3 1 7 3:30 0 1 S", "1941 1941 8 30 7 3:30 0 0", "1946 1946 3 20 7 3:30 0 1 S", "1946 1946 11 1 7 3:30 0 0", "1947 1947 3 13 7 3:30 0 1 S", "1947 1947 11 30 7 3:30 0 0", "1948 1948 4 2 7 3:30 0 1 S", "1948 1951 9 0 8 3:30 0 0", "1952 1952 9 25 7 3:30 0 0", "1949 1953 3 1 0 3:30 0 1 S", "1953 1953 10 1 7 3:30 0 0", "1954 1964 2 18 0 3:30 0 1 S", "1954 1954 9 31 7 3:30 0 0", "1955 1964 10 1 0 3:30 0 0", "1965 1976 3 16 0 3:30 0 1 S", "1965 1976 9 16 0 3:30 0 0", "1973 1973 11 30 7 3:30 0 1 S", "1979 1979 4 8 0 3:30 0 1 S", "1979 1979 9 16 0 3:30 0 0" ],
            Shang: [ "1940 1940 5 3 7 0 0 1 D", "1940 1941 9 1 7 0 0 0 S", "1941 1941 2 16 7 0 0 1 D" ],
            Taiwan: [ "1945 1951 4 1 7 0 0 1 D", "1945 1951 9 1 7 0 0 0 S", "1952 1952 2 1 7 0 0 1 D", "1952 1954 10 1 7 0 0 0 S", "1953 1959 3 1 7 0 0 1 D", "1955 1961 9 1 7 0 0 0 S", "1960 1961 5 1 7 0 0 1 D", "1974 1975 3 1 7 0 0 1 D", "1974 1975 9 1 7 0 0 0 S", "1979 1979 5 30 7 0 0 1 D", "1979 1979 8 30 7 0 0 0 S" ]
        },
        links: {}
    });
    return moment;
});

//! moment.js
//! version : 2.4.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
define("sarike/moment/2.4.0/moment-debug", [], function(require) {
    /************************************
        Constants
    ************************************/
    var moment, VERSION = "2.4.0", round = Math.round, i, YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, // internal storage for language config files
    languages = {}, // check for nodeJS
    hasModule = typeof module !== "undefined" && module.exports, // ASP.NET json date format regex
    aspNetJsonRegex = /^\/?Date\((\-?\d+)/i, aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/, // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/, // format tokens
    formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g, // parsing token regexes
    parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
    parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
    parseTokenThreeDigits = /\d{3}/, // 000 - 999
    parseTokenFourDigits = /\d{1,4}/, // 0 - 9999
    parseTokenSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
    parseTokenDigits = /\d+/, // nonzero number of digits
    parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
    parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i, // +00:00 -00:00 +0000 -0000 or Z
    parseTokenT = /T/i, // T (ISO seperator)
    parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
    // preliminary iso regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000)
    isoRegex = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d:?\d\d|Z)?)?$/, isoFormat = "YYYY-MM-DDTHH:mm:ssZ", isoDates = [ "YYYY-MM-DD", "GGGG-[W]WW", "GGGG-[W]WW-E", "YYYY-DDD" ], // iso time formats and regexes
    isoTimes = [ [ "HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d{1,3}/ ], [ "HH:mm:ss", /(T| )\d\d:\d\d:\d\d/ ], [ "HH:mm", /(T| )\d\d:\d\d/ ], [ "HH", /(T| )\d\d/ ] ], // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
    parseTimezoneChunker = /([\+\-]|\d\d)/gi, // getter and setter names
    proxyGettersAndSetters = "Date|Hours|Minutes|Seconds|Milliseconds".split("|"), unitMillisecondFactors = {
        Milliseconds: 1,
        Seconds: 1e3,
        Minutes: 6e4,
        Hours: 36e5,
        Days: 864e5,
        Months: 2592e6,
        Years: 31536e6
    }, unitAliases = {
        ms: "millisecond",
        s: "second",
        m: "minute",
        h: "hour",
        d: "day",
        D: "date",
        w: "week",
        W: "isoWeek",
        M: "month",
        y: "year",
        DDD: "dayOfYear",
        e: "weekday",
        E: "isoWeekday",
        gg: "weekYear",
        GG: "isoWeekYear"
    }, camelFunctions = {
        dayofyear: "dayOfYear",
        isoweekday: "isoWeekday",
        isoweek: "isoWeek",
        weekyear: "weekYear",
        isoweekyear: "isoWeekYear"
    }, // format function strings
    formatFunctions = {}, // tokens to ordinalize and pad
    ordinalizeTokens = "DDD w W M D d".split(" "), paddedTokens = "M D H h m s w W".split(" "), formatTokenFunctions = {
        M: function() {
            return this.month() + 1;
        },
        MMM: function(format) {
            return this.lang().monthsShort(this, format);
        },
        MMMM: function(format) {
            return this.lang().months(this, format);
        },
        D: function() {
            return this.date();
        },
        DDD: function() {
            return this.dayOfYear();
        },
        d: function() {
            return this.day();
        },
        dd: function(format) {
            return this.lang().weekdaysMin(this, format);
        },
        ddd: function(format) {
            return this.lang().weekdaysShort(this, format);
        },
        dddd: function(format) {
            return this.lang().weekdays(this, format);
        },
        w: function() {
            return this.week();
        },
        W: function() {
            return this.isoWeek();
        },
        YY: function() {
            return leftZeroFill(this.year() % 100, 2);
        },
        YYYY: function() {
            return leftZeroFill(this.year(), 4);
        },
        YYYYY: function() {
            return leftZeroFill(this.year(), 5);
        },
        gg: function() {
            return leftZeroFill(this.weekYear() % 100, 2);
        },
        gggg: function() {
            return this.weekYear();
        },
        ggggg: function() {
            return leftZeroFill(this.weekYear(), 5);
        },
        GG: function() {
            return leftZeroFill(this.isoWeekYear() % 100, 2);
        },
        GGGG: function() {
            return this.isoWeekYear();
        },
        GGGGG: function() {
            return leftZeroFill(this.isoWeekYear(), 5);
        },
        e: function() {
            return this.weekday();
        },
        E: function() {
            return this.isoWeekday();
        },
        a: function() {
            return this.lang().meridiem(this.hours(), this.minutes(), true);
        },
        A: function() {
            return this.lang().meridiem(this.hours(), this.minutes(), false);
        },
        H: function() {
            return this.hours();
        },
        h: function() {
            return this.hours() % 12 || 12;
        },
        m: function() {
            return this.minutes();
        },
        s: function() {
            return this.seconds();
        },
        S: function() {
            return toInt(this.milliseconds() / 100);
        },
        SS: function() {
            return leftZeroFill(toInt(this.milliseconds() / 10), 2);
        },
        SSS: function() {
            return leftZeroFill(this.milliseconds(), 3);
        },
        SSSS: function() {
            return leftZeroFill(this.milliseconds(), 3);
        },
        Z: function() {
            var a = -this.zone(), b = "+";
            if (a < 0) {
                a = -a;
                b = "-";
            }
            return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
        },
        ZZ: function() {
            var a = -this.zone(), b = "+";
            if (a < 0) {
                a = -a;
                b = "-";
            }
            return b + leftZeroFill(toInt(10 * a / 6), 4);
        },
        z: function() {
            return this.zoneAbbr();
        },
        zz: function() {
            return this.zoneName();
        },
        X: function() {
            return this.unix();
        }
    }, lists = [ "months", "monthsShort", "weekdays", "weekdaysShort", "weekdaysMin" ];
    function padToken(func, count) {
        return function(a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function(a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }
    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + "o"] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
    /************************************
        Constructors
    ************************************/
    function Language() {}
    // Moment prototype object
    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }
    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        // store reference to input for deterministic cloning
        this._input = duration;
        // representation for dateAddRemove
        this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 36e5;
        // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days + weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months + years * 12;
        this._data = {};
        this._bubble();
    }
    /************************************
        Helpers
    ************************************/
    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }
        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }
        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }
        return a;
    }
    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }
    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength) {
        var output = number + "";
        while (output.length < targetLength) {
            output = "0" + output;
        }
        return output;
    }
    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, ignoreUpdateOffset) {
        var milliseconds = duration._milliseconds, days = duration._days, months = duration._months, minutes, hours;
        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        // store the minutes and hours so we can restore them
        if (days || months) {
            minutes = mom.minute();
            hours = mom.hour();
        }
        if (days) {
            mom.date(mom.date() + days * isAdding);
        }
        if (months) {
            mom.month(mom.month() + months * isAdding);
        }
        if (milliseconds && !ignoreUpdateOffset) {
            moment.updateOffset(mom);
        }
        // restore the minutes and hours after possibly changing dst
        if (days || months) {
            mom.minute(minutes);
            mom.hour(hours);
        }
    }
    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === "[object Array]";
    }
    function isDate(input) {
        return Object.prototype.toString.call(input) === "[object Date]" || input instanceof Date;
    }
    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }
    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, "$1");
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop, index;
        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }
        return normalizedInput;
    }
    function makeList(field) {
        var count, setter;
        if (field.indexOf("week") === 0) {
            count = 7;
            setter = "day";
        } else if (field.indexOf("month") === 0) {
            count = 12;
            setter = "month";
        } else {
            return;
        }
        moment[field] = function(format, index) {
            var i, getter, method = moment.fn._lang[field], results = [];
            if (typeof format === "number") {
                index = format;
                format = undefined;
            }
            getter = function(i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || "");
            };
            if (index != null) {
                return getter(index);
            } else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }
        return value;
    }
    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow = m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH : m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE : m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR : m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE : m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND : m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            m._pf.overflow = overflow;
        }
    }
    function initializeParsingFlags(config) {
        config._pf = {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false
        };
    }
    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) && m._pf.overflow < 0 && !m._pf.empty && !m._pf.invalidMonth && !m._pf.nullInput && !m._pf.invalidFormat && !m._pf.userInvalidated;
            if (m._strict) {
                m._isValid = m._isValid && m._pf.charsLeftOver === 0 && m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }
    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
    }
    /************************************
        Languages
    ************************************/
    extend(Language.prototype, {
        set: function(config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === "function") {
                    this[i] = prop;
                } else {
                    this["_" + i] = prop;
                }
            }
        },
        _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months: function(m) {
            return this._months[m.month()];
        },
        _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort: function(m) {
            return this._monthsShort[m.month()];
        },
        monthsParse: function(monthName) {
            var i, mom, regex;
            if (!this._monthsParse) {
                this._monthsParse = [];
            }
            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([ 2e3, i ]);
                    regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                    this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },
        _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays: function(m) {
            return this._weekdays[m.day()];
        },
        _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort: function(m) {
            return this._weekdaysShort[m.day()];
        },
        _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin: function(m) {
            return this._weekdaysMin[m.day()];
        },
        weekdaysParse: function(weekdayName) {
            var i, mom, regex;
            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }
            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([ 2e3, 1 ]).day(i);
                    regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
                    this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },
        _longDateFormat: {
            LT: "h:mm A",
            L: "MM/DD/YYYY",
            LL: "MMMM D YYYY",
            LLL: "MMMM D YYYY LT",
            LLLL: "dddd, MMMM D YYYY LT"
        },
        longDateFormat: function(key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function(val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },
        isPM: function(input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return (input + "").toLowerCase().charAt(0) === "p";
        },
        _meridiemParse: /[ap]\.?m?\.?/i,
        meridiem: function(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? "pm" : "PM";
            } else {
                return isLower ? "am" : "AM";
            }
        },
        _calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        calendar: function(key, mom) {
            var output = this._calendar[key];
            return typeof output === "function" ? output.apply(mom) : output;
        },
        _relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        relativeTime: function(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return typeof output === "function" ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        },
        pastFuture: function(diff, output) {
            var format = this._relativeTime[diff > 0 ? "future" : "past"];
            return typeof format === "function" ? format(output) : format.replace(/%s/i, output);
        },
        ordinal: function(number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal: "%d",
        preparse: function(string) {
            return string;
        },
        postformat: function(string) {
            return string;
        },
        week: function(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },
        _week: {
            dow: 0,
            // Sunday is the first day of the week.
            doy: 6
        },
        _invalidDate: "Invalid date",
        invalidDate: function() {
            return this._invalidDate;
        }
    });
    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }
    // Remove a language from the `languages` cache. Mostly useful in tests.
    function unloadLang(key) {
        delete languages[key];
    }
    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        var i = 0, j, lang, next, split, get = function(k) {
            if (!languages[k] && hasModule) {
                try {
                    require("./lang/" + k);
                } catch (e) {}
            }
            return languages[k];
        };
        if (!key) {
            return moment.fn._lang;
        }
        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [ key ];
        }
        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split("-");
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join("-"));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }
    /************************************
        Formatting
    ************************************/
    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }
        return function(mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }
    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.lang().invalidDate();
        }
        format = expandFormat(format, m.lang());
        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }
        return formatFunctions[format](m);
    }
    function expandFormat(format, lang) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }
        return format;
    }
    /************************************
        Parsing
    ************************************/
    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a;
        switch (token) {
          case "DDDD":
            return parseTokenThreeDigits;

          case "YYYY":
          case "GGGG":
          case "gggg":
            return parseTokenFourDigits;

          case "YYYYY":
          case "GGGGG":
          case "ggggg":
            return parseTokenSixDigits;

          case "S":
          case "SS":
          case "SSS":
          case "DDD":
            return parseTokenOneToThreeDigits;

          case "MMM":
          case "MMMM":
          case "dd":
          case "ddd":
          case "dddd":
            return parseTokenWord;

          case "a":
          case "A":
            return getLangDefinition(config._l)._meridiemParse;

          case "X":
            return parseTokenTimestampMs;

          case "Z":
          case "ZZ":
            return parseTokenTimezone;

          case "T":
            return parseTokenT;

          case "SSSS":
            return parseTokenDigits;

          case "MM":
          case "DD":
          case "YY":
          case "GG":
          case "gg":
          case "HH":
          case "hh":
          case "mm":
          case "ss":
          case "M":
          case "D":
          case "d":
          case "H":
          case "h":
          case "m":
          case "s":
          case "w":
          case "ww":
          case "W":
          case "WW":
          case "e":
          case "E":
            return parseTokenOneOrTwoDigits;

          default:
            a = new RegExp(regexpEscape(unescapeFormat(token.replace("\\", "")), "i"));
            return a;
        }
    }
    function timezoneMinutesFromString(string) {
        var tzchunk = (parseTokenTimezone.exec(string) || [])[0], parts = (tzchunk + "").match(parseTimezoneChunker) || [ "-", 0, 0 ], minutes = +(parts[1] * 60) + toInt(parts[2]);
        return parts[0] === "+" ? -minutes : minutes;
    }
    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;
        switch (token) {
          // MONTH
            case "M":
          // fall through to MM
            case "MM":
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;

          case "MMM":
          // fall through to MMMM
            case "MMMM":
            a = getLangDefinition(config._l).monthsParse(input);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;

          // DAY OF MONTH
            case "D":
          // fall through to DD
            case "DD":
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;

          // DAY OF YEAR
            case "DDD":
          // fall through to DDDD
            case "DDDD":
            if (input != null) {
                config._dayOfYear = toInt(input);
            }
            break;

          // YEAR
            case "YY":
            datePartArray[YEAR] = toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
            break;

          case "YYYY":
          case "YYYYY":
            datePartArray[YEAR] = toInt(input);
            break;

          // AM / PM
            case "a":
          // fall through to A
            case "A":
            config._isPm = getLangDefinition(config._l).isPM(input);
            break;

          // 24 HOUR
            case "H":
          // fall through to hh
            case "HH":
          // fall through to hh
            case "h":
          // fall through to hh
            case "hh":
            datePartArray[HOUR] = toInt(input);
            break;

          // MINUTE
            case "m":
          // fall through to mm
            case "mm":
            datePartArray[MINUTE] = toInt(input);
            break;

          // SECOND
            case "s":
          // fall through to ss
            case "ss":
            datePartArray[SECOND] = toInt(input);
            break;

          // MILLISECOND
            case "S":
          case "SS":
          case "SSS":
          case "SSSS":
            datePartArray[MILLISECOND] = toInt(("0." + input) * 1e3);
            break;

          // UNIX TIMESTAMP WITH MS
            case "X":
            config._d = new Date(parseFloat(input) * 1e3);
            break;

          // TIMEZONE
            case "Z":
          // fall through to ZZ
            case "ZZ":
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;

          case "w":
          case "ww":
          case "W":
          case "WW":
          case "d":
          case "dd":
          case "ddd":
          case "dddd":
          case "e":
          case "E":
            token = token.substr(0, 1);

          /* falls through */
            case "gg":
          case "gggg":
          case "GG":
          case "GGGG":
          case "GGGGG":
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = input;
            }
            break;
        }
    }
    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse, fixYear, w, temp, lang, weekday, week;
        if (config._d) {
            return;
        }
        currentDate = currentDateArray(config);
        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            fixYear = function(val) {
                return val ? val.length < 3 ? parseInt(val, 10) > 68 ? "19" + val : "20" + val : val : config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR];
            };
            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
            } else {
                lang = getLangDefinition(config._l);
                weekday = w.d != null ? parseWeekday(w.d, lang) : w.e != null ? parseInt(w.e, 10) + lang._week.dow : 0;
                week = parseInt(w.w, 10) || 1;
                //if we're parsing 'd', then the low day numbers may be next week
                if (w.d != null && weekday < lang._week.dow) {
                    week++;
                }
                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
            }
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];
            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }
            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }
        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }
        // Zero out whatever was not defaulted, including time
        for (;i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
        input[HOUR] += toInt((config._tzm || 0) / 60);
        input[MINUTE] += toInt((config._tzm || 0) % 60);
        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
    }
    function dateFromObject(config) {
        var normalizedInput;
        if (config._d) {
            return;
        }
        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [ normalizedInput.year, normalizedInput.month, normalizedInput.day, normalizedInput.hour, normalizedInput.minute, normalizedInput.second, normalizedInput.millisecond ];
        dateFromConfig(config);
    }
    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [ now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() ];
        } else {
            return [ now.getFullYear(), now.getMonth(), now.getDate() ];
        }
    }
    // date from string and format string
    function makeDateFromStringAndFormat(config) {
        config._a = [];
        config._pf.empty = true;
        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l), string = "" + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;
        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (getParseRegexForToken(token, config).exec(string) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                } else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }
        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }
        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }
        dateFromConfig(config);
        checkOverflow(config);
    }
    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }
    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }
        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            initializeParsingFlags(tempConfig);
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);
            if (!isValid(tempConfig)) {
                continue;
            }
            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;
            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;
            tempConfig._pf.score = currentScore;
            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }
        extend(config, bestMoment || tempConfig);
    }
    // date from iso format
    function makeDateFromString(config) {
        var i, string = config._i, match = isoRegex.exec(string);
        if (match) {
            config._pf.iso = true;
            for (i = 4; i > 0; i--) {
                if (match[i]) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i - 1] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0; i < 4; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (parseTokenTimezone.exec(string)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._d = new Date(string);
        }
    }
    function makeDateFromInput(config) {
        var input = config._i, matched = aspNetJsonRegex.exec(input);
        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === "string") {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === "object") {
            dateFromObject(config);
        } else {
            config._d = new Date(input);
        }
    }
    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);
        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }
    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }
    function parseWeekday(input, language) {
        if (typeof input === "string") {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            } else {
                input = language.weekdaysParse(input);
                if (typeof input !== "number") {
                    return null;
                }
            }
        }
        return input;
    }
    /************************************
        Relative Time
    ************************************/
    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1e3), minutes = round(seconds / 60), hours = round(minutes / 60), days = round(hours / 24), years = round(days / 365), args = seconds < 45 && [ "s", seconds ] || minutes === 1 && [ "m" ] || minutes < 45 && [ "mm", minutes ] || hours === 1 && [ "h" ] || hours < 22 && [ "hh", hours ] || days === 1 && [ "d" ] || days <= 25 && [ "dd", days ] || days <= 45 && [ "M" ] || days < 345 && [ "MM", round(days / 30) ] || years === 1 && [ "y" ] || [ "yy", years ];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }
    /************************************
        Week of Year
    ************************************/
    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(), adjustedMoment;
        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }
        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }
        adjustedMoment = moment(mom).add("d", daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }
    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = new Date(Date.UTC(year, 0)).getUTCDay(), daysToAdd, dayOfYear;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }
    /************************************
        Top Level Functions
    ************************************/
    function makeMoment(config) {
        var input = config._i, format = config._f;
        if (typeof config._pf === "undefined") {
            initializeParsingFlags(config);
        }
        if (input === null) {
            return moment.invalid({
                nullInput: true
            });
        }
        if (typeof input === "string") {
            config._i = input = getLangDefinition().preparse(input);
        }
        if (moment.isMoment(input)) {
            config = extend({}, input);
            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }
        return new Moment(config);
    }
    moment = function(input, format, lang, strict) {
        if (typeof lang === "boolean") {
            strict = lang;
            lang = undefined;
        }
        return makeMoment({
            _i: input,
            _f: format,
            _l: lang,
            _strict: strict,
            _isUTC: false
        });
    };
    // creating with utc
    moment.utc = function(input, format, lang, strict) {
        var m;
        if (typeof lang === "boolean") {
            strict = lang;
            lang = undefined;
        }
        m = makeMoment({
            _useUTC: true,
            _isUTC: true,
            _l: lang,
            _i: input,
            _f: format,
            _strict: strict
        }).utc();
        return m;
    };
    // creating with unix timestamp (in seconds)
    moment.unix = function(input) {
        return moment(input * 1e3);
    };
    // duration
    moment.duration = function(input, key) {
        var isDuration = moment.isDuration(input), isNumber = typeof input === "number", duration = isDuration ? input._input : isNumber ? {} : input, // matching against regexp is expensive, do it on demand
        match = null, sign, ret, parseIso, timeEmpty, dateTimeEmpty;
        if (isNumber) {
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            parseIso = function(inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(",", "."));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }
        ret = new Duration(duration);
        if (isDuration && input.hasOwnProperty("_lang")) {
            ret._lang = input._lang;
        }
        return ret;
    };
    // version number
    moment.version = VERSION;
    // default format
    moment.defaultFormat = isoFormat;
    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function() {};
    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function(key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = "en";
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };
    // returns language data
    moment.langData = function(key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };
    // compare moment object
    moment.isMoment = function(obj) {
        return obj instanceof Moment;
    };
    // for typechecking Duration objects
    moment.isDuration = function(obj) {
        return obj instanceof Duration;
    };
    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }
    moment.normalizeUnits = function(units) {
        return normalizeUnits(units);
    };
    moment.invalid = function(flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        } else {
            m._pf.userInvalidated = true;
        }
        return m;
    };
    moment.parseZone = function(input) {
        return moment(input).parseZone();
    };
    /************************************
        Moment Prototype
    ************************************/
    extend(moment.fn = Moment.prototype, {
        clone: function() {
            return moment(this);
        },
        valueOf: function() {
            return +this._d + (this._offset || 0) * 6e4;
        },
        unix: function() {
            return Math.floor(+this / 1e3);
        },
        toString: function() {
            return this.clone().lang("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },
        toDate: function() {
            return this._offset ? new Date(+this) : this._d;
        },
        toISOString: function() {
            return formatMoment(moment(this).utc(), "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
        },
        toArray: function() {
            var m = this;
            return [ m.year(), m.month(), m.date(), m.hours(), m.minutes(), m.seconds(), m.milliseconds() ];
        },
        isValid: function() {
            return isValid(this);
        },
        isDSTShifted: function() {
            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }
            return false;
        },
        parsingFlags: function() {
            return extend({}, this._pf);
        },
        invalidAt: function() {
            return this._pf.overflow;
        },
        utc: function() {
            return this.zone(0);
        },
        local: function() {
            this.zone(0);
            this._isUTC = false;
            return this;
        },
        format: function(inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },
        add: function(input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === "string") {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },
        subtract: function(input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === "string") {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },
        diff: function(input, units, asFloat) {
            var that = this._isUTC ? moment(input).zone(this._offset || 0) : moment(input).local(), zoneDiff = (this.zone() - that.zone()) * 6e4, diff, output;
            units = normalizeUnits(units);
            if (units === "year" || units === "month") {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5;
                // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = (this.year() - that.year()) * 12 + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += (this - moment(this).startOf("month") - (that - moment(that).startOf("month"))) / diff;
                // same as above but with zones, to negate all dst
                output -= (this.zone() - moment(this).startOf("month").zone() - (that.zone() - moment(that).startOf("month").zone())) * 6e4 / diff;
                if (units === "year") {
                    output = output / 12;
                }
            } else {
                diff = this - that;
                output = units === "second" ? diff / 1e3 : // 1000
                units === "minute" ? diff / 6e4 : // 1000 * 60
                units === "hour" ? diff / 36e5 : // 1000 * 60 * 60
                units === "day" ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === "week" ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                diff;
            }
            return asFloat ? output : absRound(output);
        },
        from: function(time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },
        fromNow: function(withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },
        calendar: function() {
            var diff = this.diff(moment().zone(this.zone()).startOf("day"), "days", true), format = diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
            return this.format(this.lang().calendar(format, this));
        },
        isLeapYear: function() {
            return isLeapYear(this.year());
        },
        isDST: function() {
            return this.zone() < this.clone().month(0).zone() || this.zone() < this.clone().month(5).zone();
        },
        day: function(input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({
                    d: input - day
                });
            } else {
                return day;
            }
        },
        month: function(input) {
            var utc = this._isUTC ? "UTC" : "", dayOfMonth;
            if (input != null) {
                if (typeof input === "string") {
                    input = this.lang().monthsParse(input);
                    if (typeof input !== "number") {
                        return this;
                    }
                }
                dayOfMonth = this.date();
                this.date(1);
                this._d["set" + utc + "Month"](input);
                this.date(Math.min(dayOfMonth, this.daysInMonth()));
                moment.updateOffset(this);
                return this;
            } else {
                return this._d["get" + utc + "Month"]();
            }
        },
        startOf: function(units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
              case "year":
                this.month(0);

              /* falls through */
                case "month":
                this.date(1);

              /* falls through */
                case "week":
              case "isoWeek":
              case "day":
                this.hours(0);

              /* falls through */
                case "hour":
                this.minutes(0);

              /* falls through */
                case "minute":
                this.seconds(0);

              /* falls through */
                case "second":
                this.milliseconds(0);
            }
            // weeks are a special case
            if (units === "week") {
                this.weekday(0);
            } else if (units === "isoWeek") {
                this.isoWeekday(1);
            }
            return this;
        },
        endOf: function(units) {
            units = normalizeUnits(units);
            return this.startOf(units).add(units === "isoWeek" ? "week" : units, 1).subtract("ms", 1);
        },
        isAfter: function(input, units) {
            units = typeof units !== "undefined" ? units : "millisecond";
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },
        isBefore: function(input, units) {
            units = typeof units !== "undefined" ? units : "millisecond";
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },
        isSame: function(input, units) {
            units = typeof units !== "undefined" ? units : "millisecond";
            return +this.clone().startOf(units) === +moment(input).startOf(units);
        },
        min: function(other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        },
        max: function(other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        },
        zone: function(input) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    addOrSubtractDurationFromMoment(this, moment.duration(offset - input, "m"), 1, true);
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },
        zoneAbbr: function() {
            return this._isUTC ? "UTC" : "";
        },
        zoneName: function() {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },
        parseZone: function() {
            if (typeof this._i === "string") {
                this.zone(this._i);
            }
            return this;
        },
        hasAlignedHourOffset: function(input) {
            if (!input) {
                input = 0;
            } else {
                input = moment(input).zone();
            }
            return (this.zone() - input) % 60 === 0;
        },
        daysInMonth: function() {
            return daysInMonth(this.year(), this.month());
        },
        dayOfYear: function(input) {
            var dayOfYear = round((moment(this).startOf("day") - moment(this).startOf("year")) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", input - dayOfYear);
        },
        weekYear: function(input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", input - year);
        },
        isoWeekYear: function(input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", input - year);
        },
        week: function(input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },
        isoWeek: function(input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },
        weekday: function(input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },
        isoWeekday: function(input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },
        get: function(units) {
            units = normalizeUnits(units);
            return this[units]();
        },
        set: function(units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === "function") {
                this[units](value);
            }
            return this;
        },
        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang: function(key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });
    // helper for adding shortcuts
    function makeGetterAndSetter(name, key) {
        moment.fn[name] = moment.fn[name + "s"] = function(input) {
            var utc = this._isUTC ? "UTC" : "";
            if (input != null) {
                this._d["set" + utc + key](input);
                moment.updateOffset(this);
                return this;
            } else {
                return this._d["get" + utc + key]();
            }
        };
    }
    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
    for (i = 0; i < proxyGettersAndSetters.length; i++) {
        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ""), proxyGettersAndSetters[i]);
    }
    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
    makeGetterAndSetter("year", "FullYear");
    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;
    /************************************
        Duration Prototype
    ************************************/
    extend(moment.duration.fn = Duration.prototype, {
        _bubble: function() {
            var milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, seconds, minutes, hours, years;
            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1e3;
            seconds = absRound(milliseconds / 1e3);
            data.seconds = seconds % 60;
            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;
            hours = absRound(minutes / 60);
            data.hours = hours % 24;
            days += absRound(hours / 24);
            data.days = days % 30;
            months += absRound(days / 30);
            data.months = months % 12;
            years = absRound(months / 12);
            data.years = years;
        },
        weeks: function() {
            return absRound(this.days() / 7);
        },
        valueOf: function() {
            return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        },
        humanize: function(withSuffix) {
            var difference = +this, output = relativeTime(difference, !withSuffix, this.lang());
            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }
            return this.lang().postformat(output);
        },
        add: function(input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);
            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;
            this._bubble();
            return this;
        },
        subtract: function(input, val) {
            var dur = moment.duration(input, val);
            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;
            this._bubble();
            return this;
        },
        get: function(units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + "s"]();
        },
        as: function(units) {
            units = normalizeUnits(units);
            return this["as" + units.charAt(0).toUpperCase() + units.slice(1) + "s"]();
        },
        lang: moment.fn.lang,
        toIsoString: function() {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()), months = Math.abs(this.months()), days = Math.abs(this.days()), hours = Math.abs(this.hours()), minutes = Math.abs(this.minutes()), seconds = Math.abs(this.seconds() + this.milliseconds() / 1e3);
            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return "P0D";
            }
            return (this.asSeconds() < 0 ? "-" : "") + "P" + (years ? years + "Y" : "") + (months ? months + "M" : "") + (days ? days + "D" : "") + (hours || minutes || seconds ? "T" : "") + (hours ? hours + "H" : "") + (minutes ? minutes + "M" : "") + (seconds ? seconds + "S" : "");
        }
    });
    function makeDurationGetter(name) {
        moment.duration.fn[name] = function() {
            return this._data[name];
        };
    }
    function makeDurationAsGetter(name, factor) {
        moment.duration.fn["as" + name] = function() {
            return +this / factor;
        };
    }
    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }
    makeDurationAsGetter("Weeks", 6048e5);
    moment.duration.fn.asMonths = function() {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };
    /************************************
        Default Lang
    ************************************/
    // Set default language, other languages will inherit from English.
    moment.lang("en", {
        ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        }
    });
    // moment.js language configuration
    // language : Moroccan Arabic (ar-ma)
    // author : ElFadili Yassine : https://github.com/ElFadiliY
    // author : Abdel Said : https://github.com/abdelsaid
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("ar-ma", {
            months: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"),
            monthsShort: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"),
            weekdays: "الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
            weekdaysShort: "احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت".split("_"),
            weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[اليوم على الساعة] LT",
                nextDay: "[غدا على الساعة] LT",
                nextWeek: "dddd [على الساعة] LT",
                lastDay: "[أمس على الساعة] LT",
                lastWeek: "dddd [على الساعة] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "في %s",
                past: "منذ %s",
                s: "ثوان",
                m: "دقيقة",
                mm: "%d دقائق",
                h: "ساعة",
                hh: "%d ساعات",
                d: "يوم",
                dd: "%d أيام",
                M: "شهر",
                MM: "%d أشهر",
                y: "سنة",
                yy: "%d سنوات"
            },
            week: {
                dow: 6,
                // Saturday is the first day of the week.
                doy: 12
            }
        });
    });
    // moment.js language configuration
    // language : Arabic (ar)
    // author : Abdel Said : https://github.com/abdelsaid
    // changes in months, weekdays : Ahmed Elkhatib
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("ar", {
            months: "يناير/ كانون الثاني_فبراير/ شباط_مارس/ آذار_أبريل/ نيسان_مايو/ أيار_يونيو/ حزيران_يوليو/ تموز_أغسطس/ آب_سبتمبر/ أيلول_أكتوبر/ تشرين الأول_نوفمبر/ تشرين الثاني_ديسمبر/ كانون الأول".split("_"),
            monthsShort: "يناير/ كانون الثاني_فبراير/ شباط_مارس/ آذار_أبريل/ نيسان_مايو/ أيار_يونيو/ حزيران_يوليو/ تموز_أغسطس/ آب_سبتمبر/ أيلول_أكتوبر/ تشرين الأول_نوفمبر/ تشرين الثاني_ديسمبر/ كانون الأول".split("_"),
            weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
            weekdaysShort: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
            weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[اليوم على الساعة] LT",
                nextDay: "[غدا على الساعة] LT",
                nextWeek: "dddd [على الساعة] LT",
                lastDay: "[أمس على الساعة] LT",
                lastWeek: "dddd [على الساعة] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "في %s",
                past: "منذ %s",
                s: "ثوان",
                m: "دقيقة",
                mm: "%d دقائق",
                h: "ساعة",
                hh: "%d ساعات",
                d: "يوم",
                dd: "%d أيام",
                M: "شهر",
                MM: "%d أشهر",
                y: "سنة",
                yy: "%d سنوات"
            },
            week: {
                dow: 6,
                // Saturday is the first day of the week.
                doy: 12
            }
        });
    });
    // moment.js language configuration
    // language : bulgarian (bg)
    // author : Krasen Borisov : https://github.com/kraz
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("bg", {
            months: "януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември".split("_"),
            monthsShort: "янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек".split("_"),
            weekdays: "неделя_понеделник_вторник_сряда_четвъртък_петък_събота".split("_"),
            weekdaysShort: "нед_пон_вто_сря_чет_пет_съб".split("_"),
            weekdaysMin: "нд_пн_вт_ср_чт_пт_сб".split("_"),
            longDateFormat: {
                LT: "H:mm",
                L: "D.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Днес в] LT",
                nextDay: "[Утре в] LT",
                nextWeek: "dddd [в] LT",
                lastDay: "[Вчера в] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                      case 3:
                      case 6:
                        return "[В изминалата] dddd [в] LT";

                      case 1:
                      case 2:
                      case 4:
                      case 5:
                        return "[В изминалия] dddd [в] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "след %s",
                past: "преди %s",
                s: "няколко секунди",
                m: "минута",
                mm: "%d минути",
                h: "час",
                hh: "%d часа",
                d: "ден",
                dd: "%d дни",
                M: "месец",
                MM: "%d месеца",
                y: "година",
                yy: "%d години"
            },
            ordinal: function(number) {
                var lastDigit = number % 10, last2Digits = number % 100;
                if (number === 0) {
                    return number + "-ев";
                } else if (last2Digits === 0) {
                    return number + "-ен";
                } else if (last2Digits > 10 && last2Digits < 20) {
                    return number + "-ти";
                } else if (lastDigit === 1) {
                    return number + "-ви";
                } else if (lastDigit === 2) {
                    return number + "-ри";
                } else if (lastDigit === 7 || lastDigit === 8) {
                    return number + "-ми";
                } else {
                    return number + "-ти";
                }
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : breton (br)
    // author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function relativeTimeWithMutation(number, withoutSuffix, key) {
            var format = {
                mm: "munutenn",
                MM: "miz",
                dd: "devezh"
            };
            return number + " " + mutation(format[key], number);
        }
        function specialMutationForYears(number) {
            switch (lastNumber(number)) {
              case 1:
              case 3:
              case 4:
              case 5:
              case 9:
                return number + " bloaz";

              default:
                return number + " vloaz";
            }
        }
        function lastNumber(number) {
            if (number > 9) {
                return lastNumber(number % 10);
            }
            return number;
        }
        function mutation(text, number) {
            if (number === 2) {
                return softMutation(text);
            }
            return text;
        }
        function softMutation(text) {
            var mutationTable = {
                m: "v",
                b: "v",
                d: "z"
            };
            if (mutationTable[text.charAt(0)] === undefined) {
                return text;
            }
            return mutationTable[text.charAt(0)] + text.substring(1);
        }
        return moment.lang("br", {
            months: "Genver_C'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"),
            monthsShort: "Gen_C'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"),
            weekdays: "Sul_Lun_Meurzh_Merc'her_Yaou_Gwener_Sadorn".split("_"),
            weekdaysShort: "Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"),
            weekdaysMin: "Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"),
            longDateFormat: {
                LT: "h[e]mm A",
                L: "DD/MM/YYYY",
                LL: "D [a viz] MMMM YYYY",
                LLL: "D [a viz] MMMM YYYY LT",
                LLLL: "dddd, D [a viz] MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Hiziv da] LT",
                nextDay: "[Warc'hoazh da] LT",
                nextWeek: "dddd [da] LT",
                lastDay: "[Dec'h da] LT",
                lastWeek: "dddd [paset da] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "a-benn %s",
                past: "%s 'zo",
                s: "un nebeud segondennoù",
                m: "ur vunutenn",
                mm: relativeTimeWithMutation,
                h: "un eur",
                hh: "%d eur",
                d: "un devezh",
                dd: relativeTimeWithMutation,
                M: "ur miz",
                MM: relativeTimeWithMutation,
                y: "ur bloaz",
                yy: specialMutationForYears
            },
            ordinal: function(number) {
                var output = number === 1 ? "añ" : "vet";
                return number + output;
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : bosnian (bs)
    // author : Nedim Cholich : https://github.com/frontyard
    // based on (hr) translation by Bojan Marković
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function translate(number, withoutSuffix, key) {
            var result = number + " ";
            switch (key) {
              case "m":
                return withoutSuffix ? "jedna minuta" : "jedne minute";

              case "mm":
                if (number === 1) {
                    result += "minuta";
                } else if (number === 2 || number === 3 || number === 4) {
                    result += "minute";
                } else {
                    result += "minuta";
                }
                return result;

              case "h":
                return withoutSuffix ? "jedan sat" : "jednog sata";

              case "hh":
                if (number === 1) {
                    result += "sat";
                } else if (number === 2 || number === 3 || number === 4) {
                    result += "sata";
                } else {
                    result += "sati";
                }
                return result;

              case "dd":
                if (number === 1) {
                    result += "dan";
                } else {
                    result += "dana";
                }
                return result;

              case "MM":
                if (number === 1) {
                    result += "mjesec";
                } else if (number === 2 || number === 3 || number === 4) {
                    result += "mjeseca";
                } else {
                    result += "mjeseci";
                }
                return result;

              case "yy":
                if (number === 1) {
                    result += "godina";
                } else if (number === 2 || number === 3 || number === 4) {
                    result += "godine";
                } else {
                    result += "godina";
                }
                return result;
            }
        }
        return moment.lang("bs", {
            months: "januar_februar_mart_april_maj_juni_juli_avgust_septembar_oktobar_novembar_decembar".split("_"),
            monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"),
            weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"),
            weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"),
            weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"),
            longDateFormat: {
                LT: "H:mm",
                L: "DD. MM. YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd, D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[danas u] LT",
                nextDay: "[sutra u] LT",
                nextWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[u] [nedjelju] [u] LT";

                      case 3:
                        return "[u] [srijedu] [u] LT";

                      case 6:
                        return "[u] [subotu] [u] LT";

                      case 1:
                      case 2:
                      case 4:
                      case 5:
                        return "[u] dddd [u] LT";
                    }
                },
                lastDay: "[jučer u] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                      case 3:
                        return "[prošlu] dddd [u] LT";

                      case 6:
                        return "[prošle] [subote] [u] LT";

                      case 1:
                      case 2:
                      case 4:
                      case 5:
                        return "[prošli] dddd [u] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "prije %s",
                s: "par sekundi",
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: "dan",
                dd: translate,
                M: "mjesec",
                MM: translate,
                y: "godinu",
                yy: translate
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : catalan (ca)
    // author : Juan G. Hurtado : https://github.com/juanghurtado
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("ca", {
            months: "Gener_Febrer_Març_Abril_Maig_Juny_Juliol_Agost_Setembre_Octubre_Novembre_Desembre".split("_"),
            monthsShort: "Gen._Febr._Mar._Abr._Mai._Jun._Jul._Ag._Set._Oct._Nov._Des.".split("_"),
            weekdays: "Diumenge_Dilluns_Dimarts_Dimecres_Dijous_Divendres_Dissabte".split("_"),
            weekdaysShort: "Dg._Dl._Dt._Dc._Dj._Dv._Ds.".split("_"),
            weekdaysMin: "Dg_Dl_Dt_Dc_Dj_Dv_Ds".split("_"),
            longDateFormat: {
                LT: "H:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: function() {
                    return "[avui a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
                },
                nextDay: function() {
                    return "[demà a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
                },
                nextWeek: function() {
                    return "dddd [a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
                },
                lastDay: function() {
                    return "[ahir a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
                },
                lastWeek: function() {
                    return "[el] dddd [passat a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "en %s",
                past: "fa %s",
                s: "uns segons",
                m: "un minut",
                mm: "%d minuts",
                h: "una hora",
                hh: "%d hores",
                d: "un dia",
                dd: "%d dies",
                M: "un mes",
                MM: "%d mesos",
                y: "un any",
                yy: "%d anys"
            },
            ordinal: "%dº",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : czech (cs)
    // author : petrbela : https://github.com/petrbela
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var months = "leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec".split("_"), monthsShort = "led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro".split("_");
        function plural(n) {
            return n > 1 && n < 5 && ~~(n / 10) !== 1;
        }
        function translate(number, withoutSuffix, key, isFuture) {
            var result = number + " ";
            switch (key) {
              case "s":
                // a few seconds / in a few seconds / a few seconds ago
                return withoutSuffix || isFuture ? "pár vteřin" : "pár vteřinami";

              case "m":
                // a minute / in a minute / a minute ago
                return withoutSuffix ? "minuta" : isFuture ? "minutu" : "minutou";

              case "mm":
                // 9 minutes / in 9 minutes / 9 minutes ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "minuty" : "minut");
                } else {
                    return result + "minutami";
                }
                break;

              case "h":
                // an hour / in an hour / an hour ago
                return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";

              case "hh":
                // 9 hours / in 9 hours / 9 hours ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "hodiny" : "hodin");
                } else {
                    return result + "hodinami";
                }
                break;

              case "d":
                // a day / in a day / a day ago
                return withoutSuffix || isFuture ? "den" : "dnem";

              case "dd":
                // 9 days / in 9 days / 9 days ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "dny" : "dní");
                } else {
                    return result + "dny";
                }
                break;

              case "M":
                // a month / in a month / a month ago
                return withoutSuffix || isFuture ? "měsíc" : "měsícem";

              case "MM":
                // 9 months / in 9 months / 9 months ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "měsíce" : "měsíců");
                } else {
                    return result + "měsíci";
                }
                break;

              case "y":
                // a year / in a year / a year ago
                return withoutSuffix || isFuture ? "rok" : "rokem";

              case "yy":
                // 9 years / in 9 years / 9 years ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "roky" : "let");
                } else {
                    return result + "lety";
                }
                break;
            }
        }
        return moment.lang("cs", {
            months: months,
            monthsShort: monthsShort,
            monthsParse: function(months, monthsShort) {
                var i, _monthsParse = [];
                for (i = 0; i < 12; i++) {
                    // use custom parser to solve problem with July (červenec)
                    _monthsParse[i] = new RegExp("^" + months[i] + "$|^" + monthsShort[i] + "$", "i");
                }
                return _monthsParse;
            }(months, monthsShort),
            weekdays: "neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota".split("_"),
            weekdaysShort: "ne_po_út_st_čt_pá_so".split("_"),
            weekdaysMin: "ne_po_út_st_čt_pá_so".split("_"),
            longDateFormat: {
                LT: "H:mm",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[dnes v] LT",
                nextDay: "[zítra v] LT",
                nextWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[v neděli v] LT";

                      case 1:
                      case 2:
                        return "[v] dddd [v] LT";

                      case 3:
                        return "[ve středu v] LT";

                      case 4:
                        return "[ve čtvrtek v] LT";

                      case 5:
                        return "[v pátek v] LT";

                      case 6:
                        return "[v sobotu v] LT";
                    }
                },
                lastDay: "[včera v] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[minulou neděli v] LT";

                      case 1:
                      case 2:
                        return "[minulé] dddd [v] LT";

                      case 3:
                        return "[minulou středu v] LT";

                      case 4:
                      case 5:
                        return "[minulý] dddd [v] LT";

                      case 6:
                        return "[minulou sobotu v] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "před %s",
                s: translate,
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: translate,
                dd: translate,
                M: translate,
                MM: translate,
                y: translate,
                yy: translate
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : chuvash (cv)
    // author : Anatoly Mironov : https://github.com/mirontoli
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("cv", {
            months: "кăрлач_нарăс_пуш_ака_май_çĕртме_утă_çурла_авăн_юпа_чӳк_раштав".split("_"),
            monthsShort: "кăр_нар_пуш_ака_май_çĕр_утă_çур_ав_юпа_чӳк_раш".split("_"),
            weekdays: "вырсарникун_тунтикун_ытларикун_юнкун_кĕçнерникун_эрнекун_шăматкун".split("_"),
            weekdaysShort: "выр_тун_ытл_юн_кĕç_эрн_шăм".split("_"),
            weekdaysMin: "вр_тн_ыт_юн_кç_эр_шм".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD-MM-YYYY",
                LL: "YYYY [çулхи] MMMM [уйăхĕн] D[-мĕшĕ]",
                LLL: "YYYY [çулхи] MMMM [уйăхĕн] D[-мĕшĕ], LT",
                LLLL: "dddd, YYYY [çулхи] MMMM [уйăхĕн] D[-мĕшĕ], LT"
            },
            calendar: {
                sameDay: "[Паян] LT [сехетре]",
                nextDay: "[Ыран] LT [сехетре]",
                lastDay: "[Ĕнер] LT [сехетре]",
                nextWeek: "[Çитес] dddd LT [сехетре]",
                lastWeek: "[Иртнĕ] dddd LT [сехетре]",
                sameElse: "L"
            },
            relativeTime: {
                future: function(output) {
                    var affix = /сехет$/i.exec(output) ? "рен" : /çул$/i.exec(output) ? "тан" : "ран";
                    return output + affix;
                },
                past: "%s каялла",
                s: "пĕр-ик çеккунт",
                m: "пĕр минут",
                mm: "%d минут",
                h: "пĕр сехет",
                hh: "%d сехет",
                d: "пĕр кун",
                dd: "%d кун",
                M: "пĕр уйăх",
                MM: "%d уйăх",
                y: "пĕр çул",
                yy: "%d çул"
            },
            ordinal: "%d-мĕш",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : Welsh (cy)
    // author : Robert Allen
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("cy", {
            months: "Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"),
            monthsShort: "Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"),
            weekdays: "Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"),
            weekdaysShort: "Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"),
            weekdaysMin: "Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"),
            // time formats are the same as en-gb
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Heddiw am] LT",
                nextDay: "[Yfory am] LT",
                nextWeek: "dddd [am] LT",
                lastDay: "[Ddoe am] LT",
                lastWeek: "dddd [diwethaf am] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "mewn %s",
                past: "%s yn &#244;l",
                s: "ychydig eiliadau",
                m: "munud",
                mm: "%d munud",
                h: "awr",
                hh: "%d awr",
                d: "diwrnod",
                dd: "%d diwrnod",
                M: "mis",
                MM: "%d mis",
                y: "blwyddyn",
                yy: "%d flynedd"
            },
            // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
            ordinal: function(number) {
                var b = number, output = "", lookup = [ "", "af", "il", "ydd", "ydd", "ed", "ed", "ed", "fed", "fed", "fed", // 1af to 10fed
                "eg", "fed", "eg", "eg", "fed", "eg", "eg", "fed", "eg", "fed" ];
                if (b > 20) {
                    if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                        output = "fed";
                    } else {
                        output = "ain";
                    }
                } else if (b > 0) {
                    output = lookup[b];
                }
                return number + output;
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : danish (da)
    // author : Ulrik Nielsen : https://github.com/mrbase
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("da", {
            months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"),
            monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
            weekdays: "søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"),
            weekdaysShort: "søn_man_tir_ons_tor_fre_lør".split("_"),
            weekdaysMin: "sø_ma_ti_on_to_fr_lø".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D. MMMM, YYYY LT"
            },
            calendar: {
                sameDay: "[I dag kl.] LT",
                nextDay: "[I morgen kl.] LT",
                nextWeek: "dddd [kl.] LT",
                lastDay: "[I går kl.] LT",
                lastWeek: "[sidste] dddd [kl] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "om %s",
                past: "%s siden",
                s: "få sekunder",
                m: "et minut",
                mm: "%d minutter",
                h: "en time",
                hh: "%d timer",
                d: "en dag",
                dd: "%d dage",
                M: "en måned",
                MM: "%d måneder",
                y: "et år",
                yy: "%d år"
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : german (de)
    // author : lluchs : https://github.com/lluchs
    // author: Menelion Elensúle: https://github.com/Oire
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function processRelativeTime(number, withoutSuffix, key, isFuture) {
            var format = {
                m: [ "eine Minute", "einer Minute" ],
                h: [ "eine Stunde", "einer Stunde" ],
                d: [ "ein Tag", "einem Tag" ],
                dd: [ number + " Tage", number + " Tagen" ],
                M: [ "ein Monat", "einem Monat" ],
                MM: [ number + " Monate", number + " Monaten" ],
                y: [ "ein Jahr", "einem Jahr" ],
                yy: [ number + " Jahre", number + " Jahren" ]
            };
            return withoutSuffix ? format[key][0] : format[key][1];
        }
        return moment.lang("de", {
            months: "Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
            monthsShort: "Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
            weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
            weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
            weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "H:mm [Uhr]",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd, D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Heute um] LT",
                sameElse: "L",
                nextDay: "[Morgen um] LT",
                nextWeek: "dddd [um] LT",
                lastDay: "[Gestern um] LT",
                lastWeek: "[letzten] dddd [um] LT"
            },
            relativeTime: {
                future: "in %s",
                past: "vor %s",
                s: "ein paar Sekunden",
                m: processRelativeTime,
                mm: "%d Minuten",
                h: processRelativeTime,
                hh: "%d Stunden",
                d: processRelativeTime,
                dd: processRelativeTime,
                M: processRelativeTime,
                MM: processRelativeTime,
                y: processRelativeTime,
                yy: processRelativeTime
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : modern greek (el)
    // author : Aggelos Karalias : https://github.com/mehiel
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("el", {
            monthsNominativeEl: "Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος".split("_"),
            monthsGenitiveEl: "Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου".split("_"),
            months: function(momentToFormat, format) {
                if (/D/.test(format.substring(0, format.indexOf("MMMM")))) {
                    // if there is a day number before 'MMMM'
                    return this._monthsGenitiveEl[momentToFormat.month()];
                } else {
                    return this._monthsNominativeEl[momentToFormat.month()];
                }
            },
            monthsShort: "Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ".split("_"),
            weekdays: "Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο".split("_"),
            weekdaysShort: "Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ".split("_"),
            weekdaysMin: "Κυ_Δε_Τρ_Τε_Πε_Πα_Σα".split("_"),
            meridiem: function(hours, minutes, isLower) {
                if (hours > 11) {
                    return isLower ? "μμ" : "ΜΜ";
                } else {
                    return isLower ? "πμ" : "ΠΜ";
                }
            },
            longDateFormat: {
                LT: "h:mm A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendarEl: {
                sameDay: "[Σήμερα {}] LT",
                nextDay: "[Αύριο {}] LT",
                nextWeek: "dddd [{}] LT",
                lastDay: "[Χθες {}] LT",
                lastWeek: "[την προηγούμενη] dddd [{}] LT",
                sameElse: "L"
            },
            calendar: function(key, mom) {
                var output = this._calendarEl[key], hours = mom && mom.hours();
                return output.replace("{}", hours % 12 === 1 ? "στη" : "στις");
            },
            relativeTime: {
                future: "σε %s",
                past: "%s πριν",
                s: "δευτερόλεπτα",
                m: "ένα λεπτό",
                mm: "%d λεπτά",
                h: "μία ώρα",
                hh: "%d ώρες",
                d: "μία μέρα",
                dd: "%d μέρες",
                M: "ένας μήνας",
                MM: "%d μήνες",
                y: "ένας χρόνος",
                yy: "%d χρόνια"
            },
            ordinal: function(number) {
                return number + "η";
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : australian english (en-au)
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("en-au", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            ordinal: function(number) {
                var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                return number + output;
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : canadian english (en-ca)
    // author : Jonathan Abourbih : https://github.com/jonbca
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("en-ca", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                L: "YYYY-MM-DD",
                LL: "D MMMM, YYYY",
                LLL: "D MMMM, YYYY LT",
                LLLL: "dddd, D MMMM, YYYY LT"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            ordinal: function(number) {
                var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                return number + output;
            }
        });
    });
    // moment.js language configuration
    // language : great britain english (en-gb)
    // author : Chris Gedrim : https://github.com/chrisgedrim
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("en-gb", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            ordinal: function(number) {
                var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                return number + output;
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : esperanto (eo)
    // author : Colin Dean : https://github.com/colindean
    // komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
    //          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("eo", {
            months: "januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro".split("_"),
            monthsShort: "jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec".split("_"),
            weekdays: "Dimanĉo_Lundo_Mardo_Merkredo_Ĵaŭdo_Vendredo_Sabato".split("_"),
            weekdaysShort: "Dim_Lun_Mard_Merk_Ĵaŭ_Ven_Sab".split("_"),
            weekdaysMin: "Di_Lu_Ma_Me_Ĵa_Ve_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "YYYY-MM-DD",
                LL: "D[-an de] MMMM, YYYY",
                LLL: "D[-an de] MMMM, YYYY LT",
                LLLL: "dddd, [la] D[-an de] MMMM, YYYY LT"
            },
            meridiem: function(hours, minutes, isLower) {
                if (hours > 11) {
                    return isLower ? "p.t.m." : "P.T.M.";
                } else {
                    return isLower ? "a.t.m." : "A.T.M.";
                }
            },
            calendar: {
                sameDay: "[Hodiaŭ je] LT",
                nextDay: "[Morgaŭ je] LT",
                nextWeek: "dddd [je] LT",
                lastDay: "[Hieraŭ je] LT",
                lastWeek: "[pasinta] dddd [je] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "je %s",
                past: "antaŭ %s",
                s: "sekundoj",
                m: "minuto",
                mm: "%d minutoj",
                h: "horo",
                hh: "%d horoj",
                d: "tago",
                //ne 'diurno', ĉar estas uzita por proksimumo
                dd: "%d tagoj",
                M: "monato",
                MM: "%d monatoj",
                y: "jaro",
                yy: "%d jaroj"
            },
            ordinal: "%da",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : spanish (es)
    // author : Julio Napurí : https://github.com/julionc
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("es", {
            months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
            monthsShort: "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),
            weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),
            weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"),
            weekdaysMin: "Do_Lu_Ma_Mi_Ju_Vi_Sá".split("_"),
            longDateFormat: {
                LT: "H:mm",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY LT",
                LLLL: "dddd, D [de] MMMM [de] YYYY LT"
            },
            calendar: {
                sameDay: function() {
                    return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                },
                nextDay: function() {
                    return "[mañana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                },
                nextWeek: function() {
                    return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                },
                lastDay: function() {
                    return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                },
                lastWeek: function() {
                    return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "en %s",
                past: "hace %s",
                s: "unos segundos",
                m: "un minuto",
                mm: "%d minutos",
                h: "una hora",
                hh: "%d horas",
                d: "un día",
                dd: "%d días",
                M: "un mes",
                MM: "%d meses",
                y: "un año",
                yy: "%d años"
            },
            ordinal: "%dº",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : estonian (et)
    // author : Henry Kehlmann : https://github.com/madhenry
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function translateSeconds(number, withoutSuffix, key, isFuture) {
            return isFuture || withoutSuffix ? "paari sekundi" : "paar sekundit";
        }
        return moment.lang("et", {
            months: "jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"),
            monthsShort: "jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"),
            weekdays: "pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev".split("_"),
            weekdaysShort: "P_E_T_K_N_R_L".split("_"),
            weekdaysMin: "P_E_T_K_N_R_L".split("_"),
            longDateFormat: {
                LT: "H:mm",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd, D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Täna,] LT",
                nextDay: "[Homme,] LT",
                nextWeek: "[Järgmine] dddd LT",
                lastDay: "[Eile,] LT",
                lastWeek: "[Eelmine] dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s pärast",
                past: "%s tagasi",
                s: translateSeconds,
                m: "minut",
                mm: "%d minutit",
                h: "tund",
                hh: "%d tundi",
                d: "päev",
                dd: "%d päeva",
                M: "kuu",
                MM: "%d kuud",
                y: "aasta",
                yy: "%d aastat"
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : euskara (eu)
    // author : Eneko Illarramendi : https://github.com/eillarra
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("eu", {
            months: "urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"),
            monthsShort: "urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"),
            weekdays: "igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"),
            weekdaysShort: "ig._al._ar._az._og._ol._lr.".split("_"),
            weekdaysMin: "ig_al_ar_az_og_ol_lr".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "YYYY-MM-DD",
                LL: "YYYY[ko] MMMM[ren] D[a]",
                LLL: "YYYY[ko] MMMM[ren] D[a] LT",
                LLLL: "dddd, YYYY[ko] MMMM[ren] D[a] LT",
                l: "YYYY-M-D",
                ll: "YYYY[ko] MMM D[a]",
                lll: "YYYY[ko] MMM D[a] LT",
                llll: "ddd, YYYY[ko] MMM D[a] LT"
            },
            calendar: {
                sameDay: "[gaur] LT[etan]",
                nextDay: "[bihar] LT[etan]",
                nextWeek: "dddd LT[etan]",
                lastDay: "[atzo] LT[etan]",
                lastWeek: "[aurreko] dddd LT[etan]",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s barru",
                past: "duela %s",
                s: "segundo batzuk",
                m: "minutu bat",
                mm: "%d minutu",
                h: "ordu bat",
                hh: "%d ordu",
                d: "egun bat",
                dd: "%d egun",
                M: "hilabete bat",
                MM: "%d hilabete",
                y: "urte bat",
                yy: "%d urte"
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : Persian Language
    // author : Ebrahim Byagowi : https://github.com/ebraminio
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var symbolMap = {
            "1": "۱",
            "2": "۲",
            "3": "۳",
            "4": "۴",
            "5": "۵",
            "6": "۶",
            "7": "۷",
            "8": "۸",
            "9": "۹",
            "0": "۰"
        }, numberMap = {
            "۱": "1",
            "۲": "2",
            "۳": "3",
            "۴": "4",
            "۵": "5",
            "۶": "6",
            "۷": "7",
            "۸": "8",
            "۹": "9",
            "۰": "0"
        };
        return moment.lang("fa", {
            months: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"),
            monthsShort: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"),
            weekdays: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"),
            weekdaysShort: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"),
            weekdaysMin: "ی_د_س_چ_پ_ج_ش".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 12) {
                    return "قبل از ظهر";
                } else {
                    return "بعد از ظهر";
                }
            },
            calendar: {
                sameDay: "[امروز ساعت] LT",
                nextDay: "[فردا ساعت] LT",
                nextWeek: "dddd [ساعت] LT",
                lastDay: "[دیروز ساعت] LT",
                lastWeek: "dddd [پیش] [ساعت] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "در %s",
                past: "%s پیش",
                s: "چندین ثانیه",
                m: "یک دقیقه",
                mm: "%d دقیقه",
                h: "یک ساعت",
                hh: "%d ساعت",
                d: "یک روز",
                dd: "%d روز",
                M: "یک ماه",
                MM: "%d ماه",
                y: "یک سال",
                yy: "%d سال"
            },
            preparse: function(string) {
                return string.replace(/[۰-۹]/g, function(match) {
                    return numberMap[match];
                }).replace(/،/g, ",");
            },
            postformat: function(string) {
                return string.replace(/\d/g, function(match) {
                    return symbolMap[match];
                }).replace(/,/g, "،");
            },
            ordinal: "%dم",
            week: {
                dow: 6,
                // Saturday is the first day of the week.
                doy: 12
            }
        });
    });
    // moment.js language configuration
    // language : finnish (fi)
    // author : Tarmo Aidantausta : https://github.com/bleadof
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var numbers_past = "nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän".split(" "), numbers_future = [ "nolla", "yhden", "kahden", "kolmen", "neljän", "viiden", "kuuden", numbers_past[7], numbers_past[8], numbers_past[9] ];
        function translate(number, withoutSuffix, key, isFuture) {
            var result = "";
            switch (key) {
              case "s":
                return isFuture ? "muutaman sekunnin" : "muutama sekunti";

              case "m":
                return isFuture ? "minuutin" : "minuutti";

              case "mm":
                result = isFuture ? "minuutin" : "minuuttia";
                break;

              case "h":
                return isFuture ? "tunnin" : "tunti";

              case "hh":
                result = isFuture ? "tunnin" : "tuntia";
                break;

              case "d":
                return isFuture ? "päivän" : "päivä";

              case "dd":
                result = isFuture ? "päivän" : "päivää";
                break;

              case "M":
                return isFuture ? "kuukauden" : "kuukausi";

              case "MM":
                result = isFuture ? "kuukauden" : "kuukautta";
                break;

              case "y":
                return isFuture ? "vuoden" : "vuosi";

              case "yy":
                result = isFuture ? "vuoden" : "vuotta";
                break;
            }
            result = verbal_number(number, isFuture) + " " + result;
            return result;
        }
        function verbal_number(number, isFuture) {
            return number < 10 ? isFuture ? numbers_future[number] : numbers_past[number] : number;
        }
        return moment.lang("fi", {
            months: "tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"),
            monthsShort: "tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu".split("_"),
            weekdays: "sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"),
            weekdaysShort: "su_ma_ti_ke_to_pe_la".split("_"),
            weekdaysMin: "su_ma_ti_ke_to_pe_la".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                L: "DD.MM.YYYY",
                LL: "Do MMMM[ta] YYYY",
                LLL: "Do MMMM[ta] YYYY, [klo] LT",
                LLLL: "dddd, Do MMMM[ta] YYYY, [klo] LT",
                l: "D.M.YYYY",
                ll: "Do MMM YYYY",
                lll: "Do MMM YYYY, [klo] LT",
                llll: "ddd, Do MMM YYYY, [klo] LT"
            },
            calendar: {
                sameDay: "[tänään] [klo] LT",
                nextDay: "[huomenna] [klo] LT",
                nextWeek: "dddd [klo] LT",
                lastDay: "[eilen] [klo] LT",
                lastWeek: "[viime] dddd[na] [klo] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s päästä",
                past: "%s sitten",
                s: translate,
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: translate,
                dd: translate,
                M: translate,
                MM: translate,
                y: translate,
                yy: translate
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : faroese (fo)
    // author : Ragnar Johannesen : https://github.com/ragnar123
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("fo", {
            months: "januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember".split("_"),
            monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
            weekdays: "sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur".split("_"),
            weekdaysShort: "sun_mán_týs_mik_hós_frí_ley".split("_"),
            weekdaysMin: "su_má_tý_mi_hó_fr_le".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D. MMMM, YYYY LT"
            },
            calendar: {
                sameDay: "[Í dag kl.] LT",
                nextDay: "[Í morgin kl.] LT",
                nextWeek: "dddd [kl.] LT",
                lastDay: "[Í gjár kl.] LT",
                lastWeek: "[síðstu] dddd [kl] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "um %s",
                past: "%s síðani",
                s: "fá sekund",
                m: "ein minutt",
                mm: "%d minuttir",
                h: "ein tími",
                hh: "%d tímar",
                d: "ein dagur",
                dd: "%d dagar",
                M: "ein mánaði",
                MM: "%d mánaðir",
                y: "eitt ár",
                yy: "%d ár"
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : canadian french (fr-ca)
    // author : Jonathan Abourbih : https://github.com/jonbca
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("fr-ca", {
            months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"),
            monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"),
            weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
            weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
            weekdaysMin: "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "YYYY-MM-DD",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Aujourd'hui à] LT",
                nextDay: "[Demain à] LT",
                nextWeek: "dddd [à] LT",
                lastDay: "[Hier à] LT",
                lastWeek: "dddd [dernier à] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dans %s",
                past: "il y a %s",
                s: "quelques secondes",
                m: "une minute",
                mm: "%d minutes",
                h: "une heure",
                hh: "%d heures",
                d: "un jour",
                dd: "%d jours",
                M: "un mois",
                MM: "%d mois",
                y: "un an",
                yy: "%d ans"
            },
            ordinal: function(number) {
                return number + (number === 1 ? "er" : "");
            }
        });
    });
    // moment.js language configuration
    // language : french (fr)
    // author : John Fischer : https://github.com/jfroffice
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("fr", {
            months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"),
            monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"),
            weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
            weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
            weekdaysMin: "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Aujourd'hui à] LT",
                nextDay: "[Demain à] LT",
                nextWeek: "dddd [à] LT",
                lastDay: "[Hier à] LT",
                lastWeek: "dddd [dernier à] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dans %s",
                past: "il y a %s",
                s: "quelques secondes",
                m: "une minute",
                mm: "%d minutes",
                h: "une heure",
                hh: "%d heures",
                d: "un jour",
                dd: "%d jours",
                M: "un mois",
                MM: "%d mois",
                y: "un an",
                yy: "%d ans"
            },
            ordinal: function(number) {
                return number + (number === 1 ? "er" : "");
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : galician (gl)
    // author : Juan G. Hurtado : https://github.com/juanghurtado
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("gl", {
            months: "Xaneiro_Febreiro_Marzo_Abril_Maio_Xuño_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro".split("_"),
            monthsShort: "Xan._Feb._Mar._Abr._Mai._Xuñ._Xul._Ago._Set._Out._Nov._Dec.".split("_"),
            weekdays: "Domingo_Luns_Martes_Mércores_Xoves_Venres_Sábado".split("_"),
            weekdaysShort: "Dom._Lun._Mar._Mér._Xov._Ven._Sáb.".split("_"),
            weekdaysMin: "Do_Lu_Ma_Mé_Xo_Ve_Sá".split("_"),
            longDateFormat: {
                LT: "H:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: function() {
                    return "[hoxe " + (this.hours() !== 1 ? "ás" : "á") + "] LT";
                },
                nextDay: function() {
                    return "[mañá " + (this.hours() !== 1 ? "ás" : "á") + "] LT";
                },
                nextWeek: function() {
                    return "dddd [" + (this.hours() !== 1 ? "ás" : "a") + "] LT";
                },
                lastDay: function() {
                    return "[onte " + (this.hours() !== 1 ? "á" : "a") + "] LT";
                },
                lastWeek: function() {
                    return "[o] dddd [pasado " + (this.hours() !== 1 ? "ás" : "a") + "] LT";
                },
                sameElse: "L"
            },
            relativeTime: {
                future: function(str) {
                    if (str === "uns segundos") {
                        return "nuns segundos";
                    }
                    return "en " + str;
                },
                past: "hai %s",
                s: "uns segundos",
                m: "un minuto",
                mm: "%d minutos",
                h: "unha hora",
                hh: "%d horas",
                d: "un día",
                dd: "%d días",
                M: "un mes",
                MM: "%d meses",
                y: "un ano",
                yy: "%d anos"
            },
            ordinal: "%dº",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : Hebrew (he)
    // author : Tomer Cohen : https://github.com/tomer
    // author : Moshe Simantov : https://github.com/DevelopmentIL
    // author : Tal Ater : https://github.com/TalAter
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("he", {
            months: "ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר".split("_"),
            monthsShort: "ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳".split("_"),
            weekdays: "ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת".split("_"),
            weekdaysShort: "א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳".split("_"),
            weekdaysMin: "א_ב_ג_ד_ה_ו_ש".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D [ב]MMMM YYYY",
                LLL: "D [ב]MMMM YYYY LT",
                LLLL: "dddd, D [ב]MMMM YYYY LT",
                l: "D/M/YYYY",
                ll: "D MMM YYYY",
                lll: "D MMM YYYY LT",
                llll: "ddd, D MMM YYYY LT"
            },
            calendar: {
                sameDay: "[היום ב־]LT",
                nextDay: "[מחר ב־]LT",
                nextWeek: "dddd [בשעה] LT",
                lastDay: "[אתמול ב־]LT",
                lastWeek: "[ביום] dddd [האחרון בשעה] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "בעוד %s",
                past: "לפני %s",
                s: "מספר שניות",
                m: "דקה",
                mm: "%d דקות",
                h: "שעה",
                hh: function(number) {
                    if (number === 2) {
                        return "שעתיים";
                    }
                    return number + " שעות";
                },
                d: "יום",
                dd: function(number) {
                    if (number === 2) {
                        return "יומיים";
                    }
                    return number + " ימים";
                },
                M: "חודש",
                MM: function(number) {
                    if (number === 2) {
                        return "חודשיים";
                    }
                    return number + " חודשים";
                },
                y: "שנה",
                yy: function(number) {
                    if (number === 2) {
                        return "שנתיים";
                    }
                    return number + " שנים";
                }
            }
        });
    });
    // moment.js language configuration
    // language : hindi (hi)
    // author : Mayank Singhal : https://github.com/mayanksinghal
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var symbolMap = {
            "1": "१",
            "2": "२",
            "3": "३",
            "4": "४",
            "5": "५",
            "6": "६",
            "7": "७",
            "8": "८",
            "9": "९",
            "0": "०"
        }, numberMap = {
            "१": "1",
            "२": "2",
            "३": "3",
            "४": "4",
            "५": "5",
            "६": "6",
            "७": "7",
            "८": "8",
            "९": "9",
            "०": "0"
        };
        return moment.lang("hi", {
            months: "जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर".split("_"),
            monthsShort: "जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.".split("_"),
            weekdays: "रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार".split("_"),
            weekdaysShort: "रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि".split("_"),
            weekdaysMin: "र_सो_मं_बु_गु_शु_श".split("_"),
            longDateFormat: {
                LT: "A h:mm बजे",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, LT",
                LLLL: "dddd, D MMMM YYYY, LT"
            },
            calendar: {
                sameDay: "[आज] LT",
                nextDay: "[कल] LT",
                nextWeek: "dddd, LT",
                lastDay: "[कल] LT",
                lastWeek: "[पिछले] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s में",
                past: "%s पहले",
                s: "कुछ ही क्षण",
                m: "एक मिनट",
                mm: "%d मिनट",
                h: "एक घंटा",
                hh: "%d घंटे",
                d: "एक दिन",
                dd: "%d दिन",
                M: "एक महीने",
                MM: "%d महीने",
                y: "एक वर्ष",
                yy: "%d वर्ष"
            },
            preparse: function(string) {
                return string.replace(/[१२३४५६७८९०]/g, function(match) {
                    return numberMap[match];
                });
            },
            postformat: function(string) {
                return string.replace(/\d/g, function(match) {
                    return symbolMap[match];
                });
            },
            // Hindi notation for meridiems are quite fuzzy in practice. While there exists
            // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
            meridiem: function(hour, minute, isLower) {
                if (hour < 4) {
                    return "रात";
                } else if (hour < 10) {
                    return "सुबह";
                } else if (hour < 17) {
                    return "दोपहर";
                } else if (hour < 20) {
                    return "शाम";
                } else {
                    return "रात";
                }
            },
            week: {
                dow: 0,
                // Sunday is the first day of the week.
                doy: 6
            }
        });
    });
    // moment.js language configuration
    // language : hrvatski (hr)
    // author : Bojan Marković : https://github.com/bmarkovic
    // based on (sl) translation by Robert Sedovšek
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function translate(number, withoutSuffix, key) {
            var result = number + " ";
            switch (key) {
              case "m":
                return withoutSuffix ? "jedna minuta" : "jedne minute";

              case "mm":
                if (number === 1) {
                    result += "minuta";
                } else if (number === 2 || number === 3 || number === 4) {
                    result += "minute";
                } else {
                    result += "minuta";
                }
                return result;

              case "h":
                return withoutSuffix ? "jedan sat" : "jednog sata";

              case "hh":
                if (number === 1) {
                    result += "sat";
                } else if (number === 2 || number === 3 || number === 4) {
                    result += "sata";
                } else {
                    result += "sati";
                }
                return result;

              case "dd":
                if (number === 1) {
                    result += "dan";
                } else {
                    result += "dana";
                }
                return result;

              case "MM":
                if (number === 1) {
                    result += "mjesec";
                } else if (number === 2 || number === 3 || number === 4) {
                    result += "mjeseca";
                } else {
                    result += "mjeseci";
                }
                return result;

              case "yy":
                if (number === 1) {
                    result += "godina";
                } else if (number === 2 || number === 3 || number === 4) {
                    result += "godine";
                } else {
                    result += "godina";
                }
                return result;
            }
        }
        return moment.lang("hr", {
            months: "sječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_"),
            monthsShort: "sje._vel._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"),
            weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"),
            weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"),
            weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"),
            longDateFormat: {
                LT: "H:mm",
                L: "DD. MM. YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd, D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[danas u] LT",
                nextDay: "[sutra u] LT",
                nextWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[u] [nedjelju] [u] LT";

                      case 3:
                        return "[u] [srijedu] [u] LT";

                      case 6:
                        return "[u] [subotu] [u] LT";

                      case 1:
                      case 2:
                      case 4:
                      case 5:
                        return "[u] dddd [u] LT";
                    }
                },
                lastDay: "[jučer u] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                      case 3:
                        return "[prošlu] dddd [u] LT";

                      case 6:
                        return "[prošle] [subote] [u] LT";

                      case 1:
                      case 2:
                      case 4:
                      case 5:
                        return "[prošli] dddd [u] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "prije %s",
                s: "par sekundi",
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: "dan",
                dd: translate,
                M: "mjesec",
                MM: translate,
                y: "godinu",
                yy: translate
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : hungarian (hu)
    // author : Adam Brunner : https://github.com/adambrunner
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var weekEndings = "vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton".split(" ");
        function translate(number, withoutSuffix, key, isFuture) {
            var num = number, suffix;
            switch (key) {
              case "s":
                return isFuture || withoutSuffix ? "néhány másodperc" : "néhány másodperce";

              case "m":
                return "egy" + (isFuture || withoutSuffix ? " perc" : " perce");

              case "mm":
                return num + (isFuture || withoutSuffix ? " perc" : " perce");

              case "h":
                return "egy" + (isFuture || withoutSuffix ? " óra" : " órája");

              case "hh":
                return num + (isFuture || withoutSuffix ? " óra" : " órája");

              case "d":
                return "egy" + (isFuture || withoutSuffix ? " nap" : " napja");

              case "dd":
                return num + (isFuture || withoutSuffix ? " nap" : " napja");

              case "M":
                return "egy" + (isFuture || withoutSuffix ? " hónap" : " hónapja");

              case "MM":
                return num + (isFuture || withoutSuffix ? " hónap" : " hónapja");

              case "y":
                return "egy" + (isFuture || withoutSuffix ? " év" : " éve");

              case "yy":
                return num + (isFuture || withoutSuffix ? " év" : " éve");
            }
            return "";
        }
        function week(isFuture) {
            return (isFuture ? "" : "[múlt] ") + "[" + weekEndings[this.day()] + "] LT[-kor]";
        }
        return moment.lang("hu", {
            months: "január_február_március_április_május_június_július_augusztus_szeptember_október_november_december".split("_"),
            monthsShort: "jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec".split("_"),
            weekdays: "vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat".split("_"),
            weekdaysShort: "vas_hét_kedd_sze_csüt_pén_szo".split("_"),
            weekdaysMin: "v_h_k_sze_cs_p_szo".split("_"),
            longDateFormat: {
                LT: "H:mm",
                L: "YYYY.MM.DD.",
                LL: "YYYY. MMMM D.",
                LLL: "YYYY. MMMM D., LT",
                LLLL: "YYYY. MMMM D., dddd LT"
            },
            calendar: {
                sameDay: "[ma] LT[-kor]",
                nextDay: "[holnap] LT[-kor]",
                nextWeek: function() {
                    return week.call(this, true);
                },
                lastDay: "[tegnap] LT[-kor]",
                lastWeek: function() {
                    return week.call(this, false);
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "%s múlva",
                past: "%s",
                s: translate,
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: translate,
                dd: translate,
                M: translate,
                MM: translate,
                y: translate,
                yy: translate
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : Bahasa Indonesia (id)
    // author : Mohammad Satrio Utomo : https://github.com/tyok
    // reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("id", {
            months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des".split("_"),
            weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"),
            weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"),
            weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY [pukul] LT",
                LLLL: "dddd, D MMMM YYYY [pukul] LT"
            },
            meridiem: function(hours, minutes, isLower) {
                if (hours < 11) {
                    return "pagi";
                } else if (hours < 15) {
                    return "siang";
                } else if (hours < 19) {
                    return "sore";
                } else {
                    return "malam";
                }
            },
            calendar: {
                sameDay: "[Hari ini pukul] LT",
                nextDay: "[Besok pukul] LT",
                nextWeek: "dddd [pukul] LT",
                lastDay: "[Kemarin pukul] LT",
                lastWeek: "dddd [lalu pukul] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dalam %s",
                past: "%s yang lalu",
                s: "beberapa detik",
                m: "semenit",
                mm: "%d menit",
                h: "sejam",
                hh: "%d jam",
                d: "sehari",
                dd: "%d hari",
                M: "sebulan",
                MM: "%d bulan",
                y: "setahun",
                yy: "%d tahun"
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : icelandic (is)
    // author : Hinrik Örn Sigurðsson : https://github.com/hinrik
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function plural(n) {
            if (n % 100 === 11) {
                return true;
            } else if (n % 10 === 1) {
                return false;
            }
            return true;
        }
        function translate(number, withoutSuffix, key, isFuture) {
            var result = number + " ";
            switch (key) {
              case "s":
                return withoutSuffix || isFuture ? "nokkrar sekúndur" : "nokkrum sekúndum";

              case "m":
                return withoutSuffix ? "mínúta" : "mínútu";

              case "mm":
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? "mínútur" : "mínútum");
                } else if (withoutSuffix) {
                    return result + "mínúta";
                }
                return result + "mínútu";

              case "hh":
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? "klukkustundir" : "klukkustundum");
                }
                return result + "klukkustund";

              case "d":
                if (withoutSuffix) {
                    return "dagur";
                }
                return isFuture ? "dag" : "degi";

              case "dd":
                if (plural(number)) {
                    if (withoutSuffix) {
                        return result + "dagar";
                    }
                    return result + (isFuture ? "daga" : "dögum");
                } else if (withoutSuffix) {
                    return result + "dagur";
                }
                return result + (isFuture ? "dag" : "degi");

              case "M":
                if (withoutSuffix) {
                    return "mánuður";
                }
                return isFuture ? "mánuð" : "mánuði";

              case "MM":
                if (plural(number)) {
                    if (withoutSuffix) {
                        return result + "mánuðir";
                    }
                    return result + (isFuture ? "mánuði" : "mánuðum");
                } else if (withoutSuffix) {
                    return result + "mánuður";
                }
                return result + (isFuture ? "mánuð" : "mánuði");

              case "y":
                return withoutSuffix || isFuture ? "ár" : "ári";

              case "yy":
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? "ár" : "árum");
                }
                return result + (withoutSuffix || isFuture ? "ár" : "ári");
            }
        }
        return moment.lang("is", {
            months: "janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember".split("_"),
            monthsShort: "jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des".split("_"),
            weekdays: "sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur".split("_"),
            weekdaysShort: "sun_mán_þri_mið_fim_fös_lau".split("_"),
            weekdaysMin: "Su_Má_Þr_Mi_Fi_Fö_La".split("_"),
            longDateFormat: {
                LT: "H:mm",
                L: "DD/MM/YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY [kl.] LT",
                LLLL: "dddd, D. MMMM YYYY [kl.] LT"
            },
            calendar: {
                sameDay: "[í dag kl.] LT",
                nextDay: "[á morgun kl.] LT",
                nextWeek: "dddd [kl.] LT",
                lastDay: "[í gær kl.] LT",
                lastWeek: "[síðasta] dddd [kl.] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "eftir %s",
                past: "fyrir %s síðan",
                s: translate,
                m: translate,
                mm: translate,
                h: "klukkustund",
                hh: translate,
                d: translate,
                dd: translate,
                M: translate,
                MM: translate,
                y: translate,
                yy: translate
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : italian (it)
    // author : Lorenzo : https://github.com/aliem
    // author: Mattia Larentis: https://github.com/nostalgiaz
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("it", {
            months: "Gennaio_Febbraio_Marzo_Aprile_Maggio_Giugno_Luglio_Agosto_Settembre_Ottobre_Novembre_Dicembre".split("_"),
            monthsShort: "Gen_Feb_Mar_Apr_Mag_Giu_Lug_Ago_Set_Ott_Nov_Dic".split("_"),
            weekdays: "Domenica_Lunedì_Martedì_Mercoledì_Giovedì_Venerdì_Sabato".split("_"),
            weekdaysShort: "Dom_Lun_Mar_Mer_Gio_Ven_Sab".split("_"),
            weekdaysMin: "D_L_Ma_Me_G_V_S".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Oggi alle] LT",
                nextDay: "[Domani alle] LT",
                nextWeek: "dddd [alle] LT",
                lastDay: "[Ieri alle] LT",
                lastWeek: "[lo scorso] dddd [alle] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: function(s) {
                    return (/^[0-9].+$/.test(s) ? "tra" : "in") + " " + s;
                },
                past: "%s fa",
                s: "secondi",
                m: "un minuto",
                mm: "%d minuti",
                h: "un'ora",
                hh: "%d ore",
                d: "un giorno",
                dd: "%d giorni",
                M: "un mese",
                MM: "%d mesi",
                y: "un anno",
                yy: "%d anni"
            },
            ordinal: "%dº",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : japanese (ja)
    // author : LI Long : https://github.com/baryon
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("ja", {
            months: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
            monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
            weekdays: "日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日".split("_"),
            weekdaysShort: "日_月_火_水_木_金_土".split("_"),
            weekdaysMin: "日_月_火_水_木_金_土".split("_"),
            longDateFormat: {
                LT: "Ah時m分",
                L: "YYYY/MM/DD",
                LL: "YYYY年M月D日",
                LLL: "YYYY年M月D日LT",
                LLLL: "YYYY年M月D日LT dddd"
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 12) {
                    return "午前";
                } else {
                    return "午後";
                }
            },
            calendar: {
                sameDay: "[今日] LT",
                nextDay: "[明日] LT",
                nextWeek: "[来週]dddd LT",
                lastDay: "[昨日] LT",
                lastWeek: "[前週]dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s後",
                past: "%s前",
                s: "数秒",
                m: "1分",
                mm: "%d分",
                h: "1時間",
                hh: "%d時間",
                d: "1日",
                dd: "%d日",
                M: "1ヶ月",
                MM: "%dヶ月",
                y: "1年",
                yy: "%d年"
            }
        });
    });
    // moment.js language configuration
    // language : Georgian (ka)
    // author : Irakli Janiashvili : https://github.com/irakli-janiashvili
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function monthsCaseReplace(m, format) {
            var months = {
                nominative: "იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი".split("_"),
                accusative: "იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს".split("_")
            }, nounCase = /D[oD] *MMMM?/.test(format) ? "accusative" : "nominative";
            return months[nounCase][m.month()];
        }
        function weekdaysCaseReplace(m, format) {
            var weekdays = {
                nominative: "კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი".split("_"),
                accusative: "კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს".split("_")
            }, nounCase = /(წინა|შემდეგ)/.test(format) ? "accusative" : "nominative";
            return weekdays[nounCase][m.day()];
        }
        return moment.lang("ka", {
            months: monthsCaseReplace,
            monthsShort: "იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ".split("_"),
            weekdays: weekdaysCaseReplace,
            weekdaysShort: "კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ".split("_"),
            weekdaysMin: "კვ_ორ_სა_ოთ_ხუ_პა_შა".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[დღეს] LT[-ზე]",
                nextDay: "[ხვალ] LT[-ზე]",
                lastDay: "[გუშინ] LT[-ზე]",
                nextWeek: "[შემდეგ] dddd LT[-ზე]",
                lastWeek: "[წინა] dddd LT-ზე",
                sameElse: "L"
            },
            relativeTime: {
                future: function(s) {
                    return /(წამი|წუთი|საათი|წელი)/.test(s) ? s.replace(/ი$/, "ში") : s + "ში";
                },
                past: function(s) {
                    if (/(წამი|წუთი|საათი|დღე|თვე)/.test(s)) {
                        return s.replace(/(ი|ე)$/, "ის წინ");
                    }
                    if (/წელი/.test(s)) {
                        return s.replace(/წელი$/, "წლის წინ");
                    }
                },
                s: "რამდენიმე წამი",
                m: "წუთი",
                mm: "%d წუთი",
                h: "საათი",
                hh: "%d საათი",
                d: "დღე",
                dd: "%d დღე",
                M: "თვე",
                MM: "%d თვე",
                y: "წელი",
                yy: "%d წელი"
            },
            ordinal: function(number) {
                if (number === 0) {
                    return number;
                }
                if (number === 1) {
                    return number + "-ლი";
                }
                if (number < 20 || number <= 100 && number % 20 === 0 || number % 100 === 0) {
                    return "მე-" + number;
                }
                return number + "-ე";
            },
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : korean (ko)
    // author : Kyungwook, Park : https://github.com/kyungw00k
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("ko", {
            months: "1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"),
            monthsShort: "1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"),
            weekdays: "일요일_월요일_화요일_수요일_목요일_금요일_토요일".split("_"),
            weekdaysShort: "일_월_화_수_목_금_토".split("_"),
            weekdaysMin: "일_월_화_수_목_금_토".split("_"),
            longDateFormat: {
                LT: "A h시 mm분",
                L: "YYYY.MM.DD",
                LL: "YYYY년 MMMM D일",
                LLL: "YYYY년 MMMM D일 LT",
                LLLL: "YYYY년 MMMM D일 dddd LT"
            },
            meridiem: function(hour, minute, isUpper) {
                return hour < 12 ? "오전" : "오후";
            },
            calendar: {
                sameDay: "오늘 LT",
                nextDay: "내일 LT",
                nextWeek: "dddd LT",
                lastDay: "어제 LT",
                lastWeek: "지난주 dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s 후",
                past: "%s 전",
                s: "몇초",
                ss: "%d초",
                m: "일분",
                mm: "%d분",
                h: "한시간",
                hh: "%d시간",
                d: "하루",
                dd: "%d일",
                M: "한달",
                MM: "%d달",
                y: "일년",
                yy: "%d년"
            },
            ordinal: "%d일"
        });
    });
    // moment.js language configuration
    // language : Lithuanian (lt)
    // author : Mindaugas Mozūras : https://github.com/mmozuras
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var units = {
            m: "minutė_minutės_minutę",
            mm: "minutės_minučių_minutes",
            h: "valanda_valandos_valandą",
            hh: "valandos_valandų_valandas",
            d: "diena_dienos_dieną",
            dd: "dienos_dienų_dienas",
            M: "mėnuo_mėnesio_mėnesį",
            MM: "mėnesiai_mėnesių_mėnesius",
            y: "metai_metų_metus",
            yy: "metai_metų_metus"
        }, weekDays = "pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis_sekmadienis".split("_");
        function translateSeconds(number, withoutSuffix, key, isFuture) {
            if (withoutSuffix) {
                return "kelios sekundės";
            } else {
                return isFuture ? "kelių sekundžių" : "kelias sekundes";
            }
        }
        function translateSingular(number, withoutSuffix, key, isFuture) {
            return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
        }
        function special(number) {
            return number % 10 === 0 || number > 10 && number < 20;
        }
        function forms(key) {
            return units[key].split("_");
        }
        function translate(number, withoutSuffix, key, isFuture) {
            var result = number + " ";
            if (number === 1) {
                return result + translateSingular(number, withoutSuffix, key[0], isFuture);
            } else if (withoutSuffix) {
                return result + (special(number) ? forms(key)[1] : forms(key)[0]);
            } else {
                if (isFuture) {
                    return result + forms(key)[1];
                } else {
                    return result + (special(number) ? forms(key)[1] : forms(key)[2]);
                }
            }
        }
        function relativeWeekDay(moment, format) {
            var nominative = format.indexOf("dddd LT") === -1, weekDay = weekDays[moment.weekday()];
            return nominative ? weekDay : weekDay.substring(0, weekDay.length - 2) + "į";
        }
        return moment.lang("lt", {
            months: "sausio_vasario_kovo_balandžio_gegužės_biržėlio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio".split("_"),
            monthsShort: "sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"),
            weekdays: relativeWeekDay,
            weekdaysShort: "Sek_Pir_Ant_Tre_Ket_Pen_Šeš".split("_"),
            weekdaysMin: "S_P_A_T_K_Pn_Š".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "YYYY-MM-DD",
                LL: "YYYY [m.] MMMM D [d.]",
                LLL: "YYYY [m.] MMMM D [d.], LT [val.]",
                LLLL: "YYYY [m.] MMMM D [d.], dddd, LT [val.]",
                l: "YYYY-MM-DD",
                ll: "YYYY [m.] MMMM D [d.]",
                lll: "YYYY [m.] MMMM D [d.], LT [val.]",
                llll: "YYYY [m.] MMMM D [d.], ddd, LT [val.]"
            },
            calendar: {
                sameDay: "[Šiandien] LT",
                nextDay: "[Rytoj] LT",
                nextWeek: "dddd LT",
                lastDay: "[Vakar] LT",
                lastWeek: "[Praėjusį] dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "po %s",
                past: "prieš %s",
                s: translateSeconds,
                m: translateSingular,
                mm: translate,
                h: translateSingular,
                hh: translate,
                d: translateSingular,
                dd: translate,
                M: translateSingular,
                MM: translate,
                y: translateSingular,
                yy: translate
            },
            ordinal: function(number) {
                return number + "-oji";
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : latvian (lv)
    // author : Kristaps Karlsons : https://github.com/skakri
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var units = {
            mm: "minūti_minūtes_minūte_minūtes",
            hh: "stundu_stundas_stunda_stundas",
            dd: "dienu_dienas_diena_dienas",
            MM: "mēnesi_mēnešus_mēnesis_mēneši",
            yy: "gadu_gadus_gads_gadi"
        };
        function format(word, number, withoutSuffix) {
            var forms = word.split("_");
            if (withoutSuffix) {
                return number % 10 === 1 && number !== 11 ? forms[2] : forms[3];
            } else {
                return number % 10 === 1 && number !== 11 ? forms[0] : forms[1];
            }
        }
        function relativeTimeWithPlural(number, withoutSuffix, key) {
            return number + " " + format(units[key], number, withoutSuffix);
        }
        return moment.lang("lv", {
            months: "janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris".split("_"),
            monthsShort: "jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec".split("_"),
            weekdays: "svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena".split("_"),
            weekdaysShort: "Sv_P_O_T_C_Pk_S".split("_"),
            weekdaysMin: "Sv_P_O_T_C_Pk_S".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD.MM.YYYY",
                LL: "YYYY. [gada] D. MMMM",
                LLL: "YYYY. [gada] D. MMMM, LT",
                LLLL: "YYYY. [gada] D. MMMM, dddd, LT"
            },
            calendar: {
                sameDay: "[Šodien pulksten] LT",
                nextDay: "[Rīt pulksten] LT",
                nextWeek: "dddd [pulksten] LT",
                lastDay: "[Vakar pulksten] LT",
                lastWeek: "[Pagājušā] dddd [pulksten] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s vēlāk",
                past: "%s agrāk",
                s: "dažas sekundes",
                m: "minūti",
                mm: relativeTimeWithPlural,
                h: "stundu",
                hh: relativeTimeWithPlural,
                d: "dienu",
                dd: relativeTimeWithPlural,
                M: "mēnesi",
                MM: relativeTimeWithPlural,
                y: "gadu",
                yy: relativeTimeWithPlural
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : malayalam (ml)
    // author : Floyd Pink : https://github.com/floydpink
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("ml", {
            months: "ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ".split("_"),
            monthsShort: "ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.".split("_"),
            weekdays: "ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച".split("_"),
            weekdaysShort: "ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി".split("_"),
            weekdaysMin: "ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ".split("_"),
            longDateFormat: {
                LT: "A h:mm -നു",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, LT",
                LLLL: "dddd, D MMMM YYYY, LT"
            },
            calendar: {
                sameDay: "[ഇന്ന്] LT",
                nextDay: "[നാളെ] LT",
                nextWeek: "dddd, LT",
                lastDay: "[ഇന്നലെ] LT",
                lastWeek: "[കഴിഞ്ഞ] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s കഴിഞ്ഞ്",
                past: "%s മുൻപ്",
                s: "അൽപ നിമിഷങ്ങൾ",
                m: "ഒരു മിനിറ്റ്",
                mm: "%d മിനിറ്റ്",
                h: "ഒരു മണിക്കൂർ",
                hh: "%d മണിക്കൂർ",
                d: "ഒരു ദിവസം",
                dd: "%d ദിവസം",
                M: "ഒരു മാസം",
                MM: "%d മാസം",
                y: "ഒരു വർഷം",
                yy: "%d വർഷം"
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 4) {
                    return "രാത്രി";
                } else if (hour < 12) {
                    return "രാവിലെ";
                } else if (hour < 17) {
                    return "ഉച്ച കഴിഞ്ഞ്";
                } else if (hour < 20) {
                    return "വൈകുന്നേരം";
                } else {
                    return "രാത്രി";
                }
            }
        });
    });
    // moment.js language configuration
    // language : Marathi (mr)
    // author : Harshad Kale : https://github.com/kalehv
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var symbolMap = {
            "1": "१",
            "2": "२",
            "3": "३",
            "4": "४",
            "5": "५",
            "6": "६",
            "7": "७",
            "8": "८",
            "9": "९",
            "0": "०"
        }, numberMap = {
            "१": "1",
            "२": "2",
            "३": "3",
            "४": "4",
            "५": "5",
            "६": "6",
            "७": "7",
            "८": "8",
            "९": "9",
            "०": "0"
        };
        return moment.lang("mr", {
            months: "जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर".split("_"),
            monthsShort: "जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.".split("_"),
            weekdays: "रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार".split("_"),
            weekdaysShort: "रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि".split("_"),
            weekdaysMin: "र_सो_मं_बु_गु_शु_श".split("_"),
            longDateFormat: {
                LT: "A h:mm वाजता",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, LT",
                LLLL: "dddd, D MMMM YYYY, LT"
            },
            calendar: {
                sameDay: "[आज] LT",
                nextDay: "[उद्या] LT",
                nextWeek: "dddd, LT",
                lastDay: "[काल] LT",
                lastWeek: "[मागील] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s नंतर",
                past: "%s पूर्वी",
                s: "सेकंद",
                m: "एक मिनिट",
                mm: "%d मिनिटे",
                h: "एक तास",
                hh: "%d तास",
                d: "एक दिवस",
                dd: "%d दिवस",
                M: "एक महिना",
                MM: "%d महिने",
                y: "एक वर्ष",
                yy: "%d वर्षे"
            },
            preparse: function(string) {
                return string.replace(/[१२३४५६७८९०]/g, function(match) {
                    return numberMap[match];
                });
            },
            postformat: function(string) {
                return string.replace(/\d/g, function(match) {
                    return symbolMap[match];
                });
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 4) {
                    return "रात्री";
                } else if (hour < 10) {
                    return "सकाळी";
                } else if (hour < 17) {
                    return "दुपारी";
                } else if (hour < 20) {
                    return "सायंकाळी";
                } else {
                    return "रात्री";
                }
            },
            week: {
                dow: 0,
                // Sunday is the first day of the week.
                doy: 6
            }
        });
    });
    // moment.js language configuration
    // language : Bahasa Malaysia (ms-MY)
    // author : Weldan Jamili : https://github.com/weldan
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("ms-my", {
            months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
            monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
            weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
            weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
            weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY [pukul] LT",
                LLLL: "dddd, D MMMM YYYY [pukul] LT"
            },
            meridiem: function(hours, minutes, isLower) {
                if (hours < 11) {
                    return "pagi";
                } else if (hours < 15) {
                    return "tengahari";
                } else if (hours < 19) {
                    return "petang";
                } else {
                    return "malam";
                }
            },
            calendar: {
                sameDay: "[Hari ini pukul] LT",
                nextDay: "[Esok pukul] LT",
                nextWeek: "dddd [pukul] LT",
                lastDay: "[Kelmarin pukul] LT",
                lastWeek: "dddd [lepas pukul] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dalam %s",
                past: "%s yang lepas",
                s: "beberapa saat",
                m: "seminit",
                mm: "%d minit",
                h: "sejam",
                hh: "%d jam",
                d: "sehari",
                dd: "%d hari",
                M: "sebulan",
                MM: "%d bulan",
                y: "setahun",
                yy: "%d tahun"
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : norwegian bokmål (nb)
    // authors : Espen Hovlandsdal : https://github.com/rexxars
    //           Sigurd Gartmann : https://github.com/sigurdga
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("nb", {
            months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
            monthsShort: "jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
            weekdays: "søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"),
            weekdaysShort: "sø._ma._ti._on._to._fr._lø.".split("_"),
            weekdaysMin: "sø_ma_ti_on_to_fr_lø".split("_"),
            longDateFormat: {
                LT: "H.mm",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY [kl.] LT",
                LLLL: "dddd D. MMMM YYYY [kl.] LT"
            },
            calendar: {
                sameDay: "[i dag kl.] LT",
                nextDay: "[i morgen kl.] LT",
                nextWeek: "dddd [kl.] LT",
                lastDay: "[i går kl.] LT",
                lastWeek: "[forrige] dddd [kl.] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "om %s",
                past: "for %s siden",
                s: "noen sekunder",
                m: "ett minutt",
                mm: "%d minutter",
                h: "en time",
                hh: "%d timer",
                d: "en dag",
                dd: "%d dager",
                M: "en måned",
                MM: "%d måneder",
                y: "ett år",
                yy: "%d år"
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : nepali/nepalese
    // author : suvash : https://github.com/suvash
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var symbolMap = {
            "1": "१",
            "2": "२",
            "3": "३",
            "4": "४",
            "5": "५",
            "6": "६",
            "7": "७",
            "8": "८",
            "9": "९",
            "0": "०"
        }, numberMap = {
            "१": "1",
            "२": "2",
            "३": "3",
            "४": "4",
            "५": "5",
            "६": "6",
            "७": "7",
            "८": "8",
            "९": "9",
            "०": "0"
        };
        return moment.lang("ne", {
            months: "जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर".split("_"),
            monthsShort: "जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.".split("_"),
            weekdays: "आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार".split("_"),
            weekdaysShort: "आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.".split("_"),
            weekdaysMin: "आइ._सो._मङ्_बु._बि._शु._श.".split("_"),
            longDateFormat: {
                LT: "Aको h:mm बजे",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, LT",
                LLLL: "dddd, D MMMM YYYY, LT"
            },
            preparse: function(string) {
                return string.replace(/[१२३४५६७८९०]/g, function(match) {
                    return numberMap[match];
                });
            },
            postformat: function(string) {
                return string.replace(/\d/g, function(match) {
                    return symbolMap[match];
                });
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 3) {
                    return "राती";
                } else if (hour < 10) {
                    return "बिहान";
                } else if (hour < 15) {
                    return "दिउँसो";
                } else if (hour < 18) {
                    return "बेलुका";
                } else if (hour < 20) {
                    return "साँझ";
                } else {
                    return "राती";
                }
            },
            calendar: {
                sameDay: "[आज] LT",
                nextDay: "[भोली] LT",
                nextWeek: "[आउँदो] dddd[,] LT",
                lastDay: "[हिजो] LT",
                lastWeek: "[गएको] dddd[,] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%sमा",
                past: "%s अगाडी",
                s: "केही समय",
                m: "एक मिनेट",
                mm: "%d मिनेट",
                h: "एक घण्टा",
                hh: "%d घण्टा",
                d: "एक दिन",
                dd: "%d दिन",
                M: "एक महिना",
                MM: "%d महिना",
                y: "एक बर्ष",
                yy: "%d बर्ष"
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : dutch (nl)
    // author : Joris Röling : https://github.com/jjupiter
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var monthsShortWithDots = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsShortWithoutDots = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_");
        return moment.lang("nl", {
            months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),
            monthsShort: function(m, format) {
                if (/-MMM-/.test(format)) {
                    return monthsShortWithoutDots[m.month()];
                } else {
                    return monthsShortWithDots[m.month()];
                }
            },
            weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
            weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
            weekdaysMin: "Zo_Ma_Di_Wo_Do_Vr_Za".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD-MM-YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[vandaag om] LT",
                nextDay: "[morgen om] LT",
                nextWeek: "dddd [om] LT",
                lastDay: "[gisteren om] LT",
                lastWeek: "[afgelopen] dddd [om] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "over %s",
                past: "%s geleden",
                s: "een paar seconden",
                m: "één minuut",
                mm: "%d minuten",
                h: "één uur",
                hh: "%d uur",
                d: "één dag",
                dd: "%d dagen",
                M: "één maand",
                MM: "%d maanden",
                y: "één jaar",
                yy: "%d jaar"
            },
            ordinal: function(number) {
                return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : norwegian nynorsk (nn)
    // author : https://github.com/mechuwind
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("nn", {
            months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
            monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
            weekdays: "sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"),
            weekdaysShort: "sun_mån_tys_ons_tor_fre_lau".split("_"),
            weekdaysMin: "su_må_ty_on_to_fr_lø".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[I dag klokka] LT",
                nextDay: "[I morgon klokka] LT",
                nextWeek: "dddd [klokka] LT",
                lastDay: "[I går klokka] LT",
                lastWeek: "[Føregående] dddd [klokka] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "om %s",
                past: "for %s siden",
                s: "noen sekund",
                m: "ett minutt",
                mm: "%d minutt",
                h: "en time",
                hh: "%d timar",
                d: "en dag",
                dd: "%d dagar",
                M: "en månad",
                MM: "%d månader",
                y: "ett år",
                yy: "%d år"
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : polish (pl)
    // author : Rafal Hirsz : https://github.com/evoL
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var monthsNominative = "styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień".split("_"), monthsSubjective = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia".split("_");
        function plural(n) {
            return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) !== 1;
        }
        function translate(number, withoutSuffix, key) {
            var result = number + " ";
            switch (key) {
              case "m":
                return withoutSuffix ? "minuta" : "minutę";

              case "mm":
                return result + (plural(number) ? "minuty" : "minut");

              case "h":
                return withoutSuffix ? "godzina" : "godzinę";

              case "hh":
                return result + (plural(number) ? "godziny" : "godzin");

              case "MM":
                return result + (plural(number) ? "miesiące" : "miesięcy");

              case "yy":
                return result + (plural(number) ? "lata" : "lat");
            }
        }
        return moment.lang("pl", {
            months: function(momentToFormat, format) {
                if (/D MMMM/.test(format)) {
                    return monthsSubjective[momentToFormat.month()];
                } else {
                    return monthsNominative[momentToFormat.month()];
                }
            },
            monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru".split("_"),
            weekdays: "niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota".split("_"),
            weekdaysShort: "nie_pon_wt_śr_czw_pt_sb".split("_"),
            weekdaysMin: "N_Pn_Wt_Śr_Cz_Pt_So".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Dziś o] LT",
                nextDay: "[Jutro o] LT",
                nextWeek: "[W] dddd [o] LT",
                lastDay: "[Wczoraj o] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[W zeszłą niedzielę o] LT";

                      case 3:
                        return "[W zeszłą środę o] LT";

                      case 6:
                        return "[W zeszłą sobotę o] LT";

                      default:
                        return "[W zeszły] dddd [o] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "%s temu",
                s: "kilka sekund",
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: "1 dzień",
                dd: "%d dni",
                M: "miesiąc",
                MM: translate,
                y: "rok",
                yy: translate
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : brazilian portuguese (pt-br)
    // author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("pt-br", {
            months: "Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"),
            monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),
            weekdays: "Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado".split("_"),
            weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sáb".split("_"),
            weekdaysMin: "Dom_2ª_3ª_4ª_5ª_6ª_Sáb".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY LT",
                LLLL: "dddd, D [de] MMMM [de] YYYY LT"
            },
            calendar: {
                sameDay: "[Hoje às] LT",
                nextDay: "[Amanhã às] LT",
                nextWeek: "dddd [às] LT",
                lastDay: "[Ontem às] LT",
                lastWeek: function() {
                    return this.day() === 0 || this.day() === 6 ? "[Último] dddd [às] LT" : // Saturday + Sunday
                    "[Última] dddd [às] LT";
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "em %s",
                past: "%s atrás",
                s: "segundos",
                m: "um minuto",
                mm: "%d minutos",
                h: "uma hora",
                hh: "%d horas",
                d: "um dia",
                dd: "%d dias",
                M: "um mês",
                MM: "%d meses",
                y: "um ano",
                yy: "%d anos"
            },
            ordinal: "%dº"
        });
    });
    // moment.js language configuration
    // language : portuguese (pt)
    // author : Jefferson : https://github.com/jalex79
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("pt", {
            months: "Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"),
            monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),
            weekdays: "Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado".split("_"),
            weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sáb".split("_"),
            weekdaysMin: "Dom_2ª_3ª_4ª_5ª_6ª_Sáb".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY LT",
                LLLL: "dddd, D [de] MMMM [de] YYYY LT"
            },
            calendar: {
                sameDay: "[Hoje às] LT",
                nextDay: "[Amanhã às] LT",
                nextWeek: "dddd [às] LT",
                lastDay: "[Ontem às] LT",
                lastWeek: function() {
                    return this.day() === 0 || this.day() === 6 ? "[Último] dddd [às] LT" : // Saturday + Sunday
                    "[Última] dddd [às] LT";
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "em %s",
                past: "%s atrás",
                s: "segundos",
                m: "um minuto",
                mm: "%d minutos",
                h: "uma hora",
                hh: "%d horas",
                d: "um dia",
                dd: "%d dias",
                M: "um mês",
                MM: "%d meses",
                y: "um ano",
                yy: "%d anos"
            },
            ordinal: "%dº",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : romanian (ro)
    // author : Vlad Gurdiga : https://github.com/gurdiga
    // author : Valentin Agachi : https://github.com/avaly
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("ro", {
            months: "Ianuarie_Februarie_Martie_Aprilie_Mai_Iunie_Iulie_August_Septembrie_Octombrie_Noiembrie_Decembrie".split("_"),
            monthsShort: "Ian_Feb_Mar_Apr_Mai_Iun_Iul_Aug_Sep_Oct_Noi_Dec".split("_"),
            weekdays: "Duminică_Luni_Marţi_Miercuri_Joi_Vineri_Sâmbătă".split("_"),
            weekdaysShort: "Dum_Lun_Mar_Mie_Joi_Vin_Sâm".split("_"),
            weekdaysMin: "Du_Lu_Ma_Mi_Jo_Vi_Sâ".split("_"),
            longDateFormat: {
                LT: "H:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY H:mm",
                LLLL: "dddd, D MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[azi la] LT",
                nextDay: "[mâine la] LT",
                nextWeek: "dddd [la] LT",
                lastDay: "[ieri la] LT",
                lastWeek: "[fosta] dddd [la] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "peste %s",
                past: "%s în urmă",
                s: "câteva secunde",
                m: "un minut",
                mm: "%d minute",
                h: "o oră",
                hh: "%d ore",
                d: "o zi",
                dd: "%d zile",
                M: "o lună",
                MM: "%d luni",
                y: "un an",
                yy: "%d ani"
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : russian (ru)
    // author : Viktorminator : https://github.com/Viktorminator
    // Author : Menelion Elensúle : https://github.com/Oire
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function plural(word, num) {
            var forms = word.split("_");
            return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
        }
        function relativeTimeWithPlural(number, withoutSuffix, key) {
            var format = {
                mm: "минута_минуты_минут",
                hh: "час_часа_часов",
                dd: "день_дня_дней",
                MM: "месяц_месяца_месяцев",
                yy: "год_года_лет"
            };
            if (key === "m") {
                return withoutSuffix ? "минута" : "минуту";
            } else {
                return number + " " + plural(format[key], +number);
            }
        }
        function monthsCaseReplace(m, format) {
            var months = {
                nominative: "январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_"),
                accusative: "января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря".split("_")
            }, nounCase = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/.test(format) ? "accusative" : "nominative";
            return months[nounCase][m.month()];
        }
        function monthsShortCaseReplace(m, format) {
            var monthsShort = {
                nominative: "янв_фев_мар_апр_май_июнь_июль_авг_сен_окт_ноя_дек".split("_"),
                accusative: "янв_фев_мар_апр_мая_июня_июля_авг_сен_окт_ноя_дек".split("_")
            }, nounCase = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/.test(format) ? "accusative" : "nominative";
            return monthsShort[nounCase][m.month()];
        }
        function weekdaysCaseReplace(m, format) {
            var weekdays = {
                nominative: "воскресенье_понедельник_вторник_среда_четверг_пятница_суббота".split("_"),
                accusative: "воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу".split("_")
            }, nounCase = /\[ ?[Вв] ?(?:прошлую|следующую)? ?\] ?dddd/.test(format) ? "accusative" : "nominative";
            return weekdays[nounCase][m.day()];
        }
        return moment.lang("ru", {
            months: monthsCaseReplace,
            monthsShort: monthsShortCaseReplace,
            weekdays: weekdaysCaseReplace,
            weekdaysShort: "вс_пн_вт_ср_чт_пт_сб".split("_"),
            weekdaysMin: "вс_пн_вт_ср_чт_пт_сб".split("_"),
            monthsParse: [ /^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[й|я]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i ],
            longDateFormat: {
                LT: "HH:mm",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY г.",
                LLL: "D MMMM YYYY г., LT",
                LLLL: "dddd, D MMMM YYYY г., LT"
            },
            calendar: {
                sameDay: "[Сегодня в] LT",
                nextDay: "[Завтра в] LT",
                lastDay: "[Вчера в] LT",
                nextWeek: function() {
                    return this.day() === 2 ? "[Во] dddd [в] LT" : "[В] dddd [в] LT";
                },
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[В прошлое] dddd [в] LT";

                      case 1:
                      case 2:
                      case 4:
                        return "[В прошлый] dddd [в] LT";

                      case 3:
                      case 5:
                      case 6:
                        return "[В прошлую] dddd [в] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "через %s",
                past: "%s назад",
                s: "несколько секунд",
                m: relativeTimeWithPlural,
                mm: relativeTimeWithPlural,
                h: "час",
                hh: relativeTimeWithPlural,
                d: "день",
                dd: relativeTimeWithPlural,
                M: "месяц",
                MM: relativeTimeWithPlural,
                y: "год",
                yy: relativeTimeWithPlural
            },
            // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
            meridiem: function(hour, minute, isLower) {
                if (hour < 4) {
                    return "ночи";
                } else if (hour < 12) {
                    return "утра";
                } else if (hour < 17) {
                    return "дня";
                } else {
                    return "вечера";
                }
            },
            ordinal: function(number, period) {
                switch (period) {
                  case "M":
                  case "d":
                  case "DDD":
                    return number + "-й";

                  case "D":
                    return number + "-го";

                  case "w":
                  case "W":
                    return number + "-я";

                  default:
                    return number;
                }
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : slovak (sk)
    // author : Martin Minka : https://github.com/k2s
    // based on work of petrbela : https://github.com/petrbela
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var months = "január_február_marec_apríl_máj_jún_júl_august_september_október_november_december".split("_"), monthsShort = "jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec".split("_");
        function plural(n) {
            return n > 1 && n < 5;
        }
        function translate(number, withoutSuffix, key, isFuture) {
            var result = number + " ";
            switch (key) {
              case "s":
                // a few seconds / in a few seconds / a few seconds ago
                return withoutSuffix || isFuture ? "pár sekúnd" : "pár sekundami";

              case "m":
                // a minute / in a minute / a minute ago
                return withoutSuffix ? "minúta" : isFuture ? "minútu" : "minútou";

              case "mm":
                // 9 minutes / in 9 minutes / 9 minutes ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "minúty" : "minút");
                } else {
                    return result + "minútami";
                }
                break;

              case "h":
                // an hour / in an hour / an hour ago
                return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";

              case "hh":
                // 9 hours / in 9 hours / 9 hours ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "hodiny" : "hodín");
                } else {
                    return result + "hodinami";
                }
                break;

              case "d":
                // a day / in a day / a day ago
                return withoutSuffix || isFuture ? "deň" : "dňom";

              case "dd":
                // 9 days / in 9 days / 9 days ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "dni" : "dní");
                } else {
                    return result + "dňami";
                }
                break;

              case "M":
                // a month / in a month / a month ago
                return withoutSuffix || isFuture ? "mesiac" : "mesiacom";

              case "MM":
                // 9 months / in 9 months / 9 months ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "mesiace" : "mesiacov");
                } else {
                    return result + "mesiacmi";
                }
                break;

              case "y":
                // a year / in a year / a year ago
                return withoutSuffix || isFuture ? "rok" : "rokom";

              case "yy":
                // 9 years / in 9 years / 9 years ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "roky" : "rokov");
                } else {
                    return result + "rokmi";
                }
                break;
            }
        }
        return moment.lang("sk", {
            months: months,
            monthsShort: monthsShort,
            monthsParse: function(months, monthsShort) {
                var i, _monthsParse = [];
                for (i = 0; i < 12; i++) {
                    // use custom parser to solve problem with July (červenec)
                    _monthsParse[i] = new RegExp("^" + months[i] + "$|^" + monthsShort[i] + "$", "i");
                }
                return _monthsParse;
            }(months, monthsShort),
            weekdays: "nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota".split("_"),
            weekdaysShort: "ne_po_ut_st_št_pi_so".split("_"),
            weekdaysMin: "ne_po_ut_st_št_pi_so".split("_"),
            longDateFormat: {
                LT: "H:mm",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[dnes o] LT",
                nextDay: "[zajtra o] LT",
                nextWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[v nedeľu o] LT";

                      case 1:
                      case 2:
                        return "[v] dddd [o] LT";

                      case 3:
                        return "[v stredu o] LT";

                      case 4:
                        return "[vo štvrtok o] LT";

                      case 5:
                        return "[v piatok o] LT";

                      case 6:
                        return "[v sobotu o] LT";
                    }
                },
                lastDay: "[včera o] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[minulú nedeľu o] LT";

                      case 1:
                      case 2:
                        return "[minulý] dddd [o] LT";

                      case 3:
                        return "[minulú stredu o] LT";

                      case 4:
                      case 5:
                        return "[minulý] dddd [o] LT";

                      case 6:
                        return "[minulú sobotu o] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "pred %s",
                s: translate,
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: translate,
                dd: translate,
                M: translate,
                MM: translate,
                y: translate,
                yy: translate
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : slovenian (sl)
    // author : Robert Sedovšek : https://github.com/sedovsek
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function translate(number, withoutSuffix, key) {
            var result = number + " ";
            switch (key) {
              case "m":
                return withoutSuffix ? "ena minuta" : "eno minuto";

              case "mm":
                if (number === 1) {
                    result += "minuta";
                } else if (number === 2) {
                    result += "minuti";
                } else if (number === 3 || number === 4) {
                    result += "minute";
                } else {
                    result += "minut";
                }
                return result;

              case "h":
                return withoutSuffix ? "ena ura" : "eno uro";

              case "hh":
                if (number === 1) {
                    result += "ura";
                } else if (number === 2) {
                    result += "uri";
                } else if (number === 3 || number === 4) {
                    result += "ure";
                } else {
                    result += "ur";
                }
                return result;

              case "dd":
                if (number === 1) {
                    result += "dan";
                } else {
                    result += "dni";
                }
                return result;

              case "MM":
                if (number === 1) {
                    result += "mesec";
                } else if (number === 2) {
                    result += "meseca";
                } else if (number === 3 || number === 4) {
                    result += "mesece";
                } else {
                    result += "mesecev";
                }
                return result;

              case "yy":
                if (number === 1) {
                    result += "leto";
                } else if (number === 2) {
                    result += "leti";
                } else if (number === 3 || number === 4) {
                    result += "leta";
                } else {
                    result += "let";
                }
                return result;
            }
        }
        return moment.lang("sl", {
            months: "januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"),
            monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"),
            weekdays: "nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota".split("_"),
            weekdaysShort: "ned._pon._tor._sre._čet._pet._sob.".split("_"),
            weekdaysMin: "ne_po_to_sr_če_pe_so".split("_"),
            longDateFormat: {
                LT: "H:mm",
                L: "DD. MM. YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd, D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[danes ob] LT",
                nextDay: "[jutri ob] LT",
                nextWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[v] [nedeljo] [ob] LT";

                      case 3:
                        return "[v] [sredo] [ob] LT";

                      case 6:
                        return "[v] [soboto] [ob] LT";

                      case 1:
                      case 2:
                      case 4:
                      case 5:
                        return "[v] dddd [ob] LT";
                    }
                },
                lastDay: "[včeraj ob] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                      case 3:
                      case 6:
                        return "[prejšnja] dddd [ob] LT";

                      case 1:
                      case 2:
                      case 4:
                      case 5:
                        return "[prejšnji] dddd [ob] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "čez %s",
                past: "%s nazaj",
                s: "nekaj sekund",
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: "en dan",
                dd: translate,
                M: "en mesec",
                MM: translate,
                y: "eno leto",
                yy: translate
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : Albanian (sq)
    // author : Flakërim Ismani : https://github.com/flakerimi
    // author: Menelion Elensúle: https://github.com/Oire (tests)
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("sq", {
            months: "Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor".split("_"),
            monthsShort: "Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj".split("_"),
            weekdays: "E Diel_E Hënë_E Marte_E Mërkure_E Enjte_E Premte_E Shtunë".split("_"),
            weekdaysShort: "Die_Hën_Mar_Mër_Enj_Pre_Sht".split("_"),
            weekdaysMin: "D_H_Ma_Më_E_P_Sh".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Sot në] LT",
                nextDay: "[Neser në] LT",
                nextWeek: "dddd [në] LT",
                lastDay: "[Dje në] LT",
                lastWeek: "dddd [e kaluar në] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "në %s",
                past: "%s me parë",
                s: "disa seconda",
                m: "një minut",
                mm: "%d minutea",
                h: "një orë",
                hh: "%d orë",
                d: "një ditë",
                dd: "%d ditë",
                M: "një muaj",
                MM: "%d muaj",
                y: "një vit",
                yy: "%d vite"
            },
            ordinal: "%d.",
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : swedish (sv)
    // author : Jens Alm : https://github.com/ulmus
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("sv", {
            months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"),
            monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
            weekdays: "söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag".split("_"),
            weekdaysShort: "sön_mån_tis_ons_tor_fre_lör".split("_"),
            weekdaysMin: "sö_må_ti_on_to_fr_lö".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "YYYY-MM-DD",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Idag] LT",
                nextDay: "[Imorgon] LT",
                lastDay: "[Igår] LT",
                nextWeek: "dddd LT",
                lastWeek: "[Förra] dddd[en] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "om %s",
                past: "för %s sedan",
                s: "några sekunder",
                m: "en minut",
                mm: "%d minuter",
                h: "en timme",
                hh: "%d timmar",
                d: "en dag",
                dd: "%d dagar",
                M: "en månad",
                MM: "%d månader",
                y: "ett år",
                yy: "%d år"
            },
            ordinal: function(number) {
                var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "e" : b === 1 ? "a" : b === 2 ? "a" : b === 3 ? "e" : "e";
                return number + output;
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : thai (th)
    // author : Kridsada Thanabulpong : https://github.com/sirn
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("th", {
            months: "มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม".split("_"),
            monthsShort: "มกรา_กุมภา_มีนา_เมษา_พฤษภา_มิถุนา_กรกฎา_สิงหา_กันยา_ตุลา_พฤศจิกา_ธันวา".split("_"),
            weekdays: "อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์".split("_"),
            weekdaysShort: "อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์".split("_"),
            // yes, three characters difference
            weekdaysMin: "อา._จ._อ._พ._พฤ._ศ._ส.".split("_"),
            longDateFormat: {
                LT: "H นาฬิกา m นาที",
                L: "YYYY/MM/DD",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY เวลา LT",
                LLLL: "วันddddที่ D MMMM YYYY เวลา LT"
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 12) {
                    return "ก่อนเที่ยง";
                } else {
                    return "หลังเที่ยง";
                }
            },
            calendar: {
                sameDay: "[วันนี้ เวลา] LT",
                nextDay: "[พรุ่งนี้ เวลา] LT",
                nextWeek: "dddd[หน้า เวลา] LT",
                lastDay: "[เมื่อวานนี้ เวลา] LT",
                lastWeek: "[วัน]dddd[ที่แล้ว เวลา] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "อีก %s",
                past: "%sที่แล้ว",
                s: "ไม่กี่วินาที",
                m: "1 นาที",
                mm: "%d นาที",
                h: "1 ชั่วโมง",
                hh: "%d ชั่วโมง",
                d: "1 วัน",
                dd: "%d วัน",
                M: "1 เดือน",
                MM: "%d เดือน",
                y: "1 ปี",
                yy: "%d ปี"
            }
        });
    });
    // moment.js language configuration
    // language : Tagalog/Filipino (tl-ph)
    // author : Dan Hagman
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("tl-ph", {
            months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),
            monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
            weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),
            weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
            weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "MM/D/YYYY",
                LL: "MMMM D, YYYY",
                LLL: "MMMM D, YYYY LT",
                LLLL: "dddd, MMMM DD, YYYY LT"
            },
            calendar: {
                sameDay: "[Ngayon sa] LT",
                nextDay: "[Bukas sa] LT",
                nextWeek: "dddd [sa] LT",
                lastDay: "[Kahapon sa] LT",
                lastWeek: "dddd [huling linggo] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "sa loob ng %s",
                past: "%s ang nakalipas",
                s: "ilang segundo",
                m: "isang minuto",
                mm: "%d minuto",
                h: "isang oras",
                hh: "%d oras",
                d: "isang araw",
                dd: "%d araw",
                M: "isang buwan",
                MM: "%d buwan",
                y: "isang taon",
                yy: "%d taon"
            },
            ordinal: function(number) {
                return number;
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : turkish (tr)
    // authors : Erhan Gundogan : https://github.com/erhangundogan,
    //           Burak Yiğit Kaya: https://github.com/BYK
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var suffixes = {
            1: "'inci",
            5: "'inci",
            8: "'inci",
            70: "'inci",
            80: "'inci",
            2: "'nci",
            7: "'nci",
            20: "'nci",
            50: "'nci",
            3: "'üncü",
            4: "'üncü",
            100: "'üncü",
            6: "'ncı",
            9: "'uncu",
            10: "'uncu",
            30: "'uncu",
            60: "'ıncı",
            90: "'ıncı"
        };
        return moment.lang("tr", {
            months: "Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık".split("_"),
            monthsShort: "Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara".split("_"),
            weekdays: "Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi".split("_"),
            weekdaysShort: "Paz_Pts_Sal_Çar_Per_Cum_Cts".split("_"),
            weekdaysMin: "Pz_Pt_Sa_Ça_Pe_Cu_Ct".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[bugün saat] LT",
                nextDay: "[yarın saat] LT",
                nextWeek: "[haftaya] dddd [saat] LT",
                lastDay: "[dün] LT",
                lastWeek: "[geçen hafta] dddd [saat] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s sonra",
                past: "%s önce",
                s: "birkaç saniye",
                m: "bir dakika",
                mm: "%d dakika",
                h: "bir saat",
                hh: "%d saat",
                d: "bir gün",
                dd: "%d gün",
                M: "bir ay",
                MM: "%d ay",
                y: "bir yıl",
                yy: "%d yıl"
            },
            ordinal: function(number) {
                if (number === 0) {
                    // special case for zero
                    return number + "'ıncı";
                }
                var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
                return number + (suffixes[a] || suffixes[b] || suffixes[c]);
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : Morocco Central Atlas Tamaziɣt in Latin (tzm-la)
    // author : Abdel Said : https://github.com/abdelsaid
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("tzm-la", {
            months: "innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir".split("_"),
            monthsShort: "innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir".split("_"),
            weekdays: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"),
            weekdaysShort: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"),
            weekdaysMin: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[asdkh g] LT",
                nextDay: "[aska g] LT",
                nextWeek: "dddd [g] LT",
                lastDay: "[assant g] LT",
                lastWeek: "dddd [g] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dadkh s yan %s",
                past: "yan %s",
                s: "imik",
                m: "minuḍ",
                mm: "%d minuḍ",
                h: "saɛa",
                hh: "%d tassaɛin",
                d: "ass",
                dd: "%d ossan",
                M: "ayowr",
                MM: "%d iyyirn",
                y: "asgas",
                yy: "%d isgasn"
            },
            week: {
                dow: 6,
                // Saturday is the first day of the week.
                doy: 12
            }
        });
    });
    // moment.js language configuration
    // language : Morocco Central Atlas Tamaziɣt (tzm)
    // author : Abdel Said : https://github.com/abdelsaid
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("tzm", {
            months: "ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ".split("_"),
            monthsShort: "ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ".split("_"),
            weekdays: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"),
            weekdaysShort: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"),
            weekdaysMin: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[ⴰⵙⴷⵅ ⴴ] LT",
                nextDay: "[ⴰⵙⴽⴰ ⴴ] LT",
                nextWeek: "dddd [ⴴ] LT",
                lastDay: "[ⴰⵚⴰⵏⵜ ⴴ] LT",
                lastWeek: "dddd [ⴴ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s",
                past: "ⵢⴰⵏ %s",
                s: "ⵉⵎⵉⴽ",
                m: "ⵎⵉⵏⵓⴺ",
                mm: "%d ⵎⵉⵏⵓⴺ",
                h: "ⵙⴰⵄⴰ",
                hh: "%d ⵜⴰⵙⵙⴰⵄⵉⵏ",
                d: "ⴰⵙⵙ",
                dd: "%d oⵙⵙⴰⵏ",
                M: "ⴰⵢoⵓⵔ",
                MM: "%d ⵉⵢⵢⵉⵔⵏ",
                y: "ⴰⵙⴳⴰⵙ",
                yy: "%d ⵉⵙⴳⴰⵙⵏ"
            },
            week: {
                dow: 6,
                // Saturday is the first day of the week.
                doy: 12
            }
        });
    });
    // moment.js language configuration
    // language : ukrainian (uk)
    // author : zemlanin : https://github.com/zemlanin
    // Author : Menelion Elensúle : https://github.com/Oire
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function plural(word, num) {
            var forms = word.split("_");
            return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
        }
        function relativeTimeWithPlural(number, withoutSuffix, key) {
            var format = {
                mm: "хвилина_хвилини_хвилин",
                hh: "година_години_годин",
                dd: "день_дні_днів",
                MM: "місяць_місяці_місяців",
                yy: "рік_роки_років"
            };
            if (key === "m") {
                return withoutSuffix ? "хвилина" : "хвилину";
            } else if (key === "h") {
                return withoutSuffix ? "година" : "годину";
            } else {
                return number + " " + plural(format[key], +number);
            }
        }
        function monthsCaseReplace(m, format) {
            var months = {
                nominative: "січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень".split("_"),
                accusative: "січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня".split("_")
            }, nounCase = /D[oD]? *MMMM?/.test(format) ? "accusative" : "nominative";
            return months[nounCase][m.month()];
        }
        function weekdaysCaseReplace(m, format) {
            var weekdays = {
                nominative: "неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота".split("_"),
                accusative: "неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу".split("_"),
                genitive: "неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи".split("_")
            }, nounCase = /(\[[ВвУу]\]) ?dddd/.test(format) ? "accusative" : /\[?(?:минулої|наступної)? ?\] ?dddd/.test(format) ? "genitive" : "nominative";
            return weekdays[nounCase][m.day()];
        }
        function processHoursFunction(str) {
            return function() {
                return str + "о" + (this.hours() === 11 ? "б" : "") + "] LT";
            };
        }
        return moment.lang("uk", {
            months: monthsCaseReplace,
            monthsShort: "січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд".split("_"),
            weekdays: weekdaysCaseReplace,
            weekdaysShort: "нд_пн_вт_ср_чт_пт_сб".split("_"),
            weekdaysMin: "нд_пн_вт_ср_чт_пт_сб".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY р.",
                LLL: "D MMMM YYYY р., LT",
                LLLL: "dddd, D MMMM YYYY р., LT"
            },
            calendar: {
                sameDay: processHoursFunction("[Сьогодні "),
                nextDay: processHoursFunction("[Завтра "),
                lastDay: processHoursFunction("[Вчора "),
                nextWeek: processHoursFunction("[У] dddd ["),
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                      case 3:
                      case 5:
                      case 6:
                        return processHoursFunction("[Минулої] dddd [").call(this);

                      case 1:
                      case 2:
                      case 4:
                        return processHoursFunction("[Минулого] dddd [").call(this);
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "за %s",
                past: "%s тому",
                s: "декілька секунд",
                m: relativeTimeWithPlural,
                mm: relativeTimeWithPlural,
                h: "годину",
                hh: relativeTimeWithPlural,
                d: "день",
                dd: relativeTimeWithPlural,
                M: "місяць",
                MM: relativeTimeWithPlural,
                y: "рік",
                yy: relativeTimeWithPlural
            },
            // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
            meridiem: function(hour, minute, isLower) {
                if (hour < 4) {
                    return "ночі";
                } else if (hour < 12) {
                    return "ранку";
                } else if (hour < 17) {
                    return "дня";
                } else {
                    return "вечора";
                }
            },
            ordinal: function(number, period) {
                switch (period) {
                  case "M":
                  case "d":
                  case "DDD":
                  case "w":
                  case "W":
                    return number + "-й";

                  case "D":
                    return number + "-го";

                  default:
                    return number;
                }
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : uzbek
    // author : Sardor Muminov : https://github.com/muminoff
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("uz", {
            months: "январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_"),
            monthsShort: "янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек".split("_"),
            weekdays: "Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба".split("_"),
            weekdaysShort: "Якш_Душ_Сеш_Чор_Пай_Жум_Шан".split("_"),
            weekdaysMin: "Як_Ду_Се_Чо_Па_Жу_Ша".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "D MMMM YYYY, dddd LT"
            },
            calendar: {
                sameDay: "[Бугун соат] LT [да]",
                nextDay: "[Эртага] LT [да]",
                nextWeek: "dddd [куни соат] LT [да]",
                lastDay: "[Кеча соат] LT [да]",
                lastWeek: "[Утган] dddd [куни соат] LT [да]",
                sameElse: "L"
            },
            relativeTime: {
                future: "Якин %s ичида",
                past: "Бир неча %s олдин",
                s: "фурсат",
                m: "бир дакика",
                mm: "%d дакика",
                h: "бир соат",
                hh: "%d соат",
                d: "бир кун",
                dd: "%d кун",
                M: "бир ой",
                MM: "%d ой",
                y: "бир йил",
                yy: "%d йил"
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 7
            }
        });
    });
    // moment.js language configuration
    // language : vietnamese (vn)
    // author : Bang Nguyen : https://github.com/bangnk
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("vn", {
            months: "tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12".split("_"),
            monthsShort: "Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12".split("_"),
            weekdays: "chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy".split("_"),
            weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"),
            weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM [năm] YYYY",
                LLL: "D MMMM [năm] YYYY LT",
                LLLL: "dddd, D MMMM [năm] YYYY LT",
                l: "DD/M/YYYY",
                ll: "D MMM YYYY",
                lll: "D MMM YYYY LT",
                llll: "ddd, D MMM YYYY LT"
            },
            calendar: {
                sameDay: "[Hôm nay lúc] LT",
                nextDay: "[Ngày mai lúc] LT",
                nextWeek: "dddd [tuần tới lúc] LT",
                lastDay: "[Hôm qua lúc] LT",
                lastWeek: "dddd [tuần rồi lúc] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s tới",
                past: "%s trước",
                s: "vài giây",
                m: "một phút",
                mm: "%d phút",
                h: "một giờ",
                hh: "%d giờ",
                d: "một ngày",
                dd: "%d ngày",
                M: "một tháng",
                MM: "%d tháng",
                y: "một năm",
                yy: "%d năm"
            },
            ordinal: function(number) {
                return number;
            },
            week: {
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : chinese
    // author : suupic : https://github.com/suupic
    // author : Zeno Zeng : https://github.com/zenozeng
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("zh-cn", {
            months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
            monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
            weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
            weekdaysShort: "周日_周一_周二_周三_周四_周五_周六".split("_"),
            weekdaysMin: "日_一_二_三_四_五_六".split("_"),
            longDateFormat: {
                LT: "Ah点mm",
                L: "YYYY年MMMD日",
                LL: "YYYY年MMMD日",
                LLL: "YYYY年MMMD日LT",
                LLLL: "YYYY年MMMD日ddddLT",
                l: "YYYY年MMMD日",
                ll: "YYYY年MMMD日",
                lll: "YYYY年MMMD日LT",
                llll: "YYYY年MMMD日ddddLT"
            },
            meridiem: function(hour, minute, isLower) {
                var hm = hour * 100 + minute;
                if (hm < 600) {
                    return "凌晨";
                } else if (hm < 900) {
                    return "早上";
                } else if (hm < 1130) {
                    return "上午";
                } else if (hm < 1230) {
                    return "中午";
                } else if (hm < 1800) {
                    return "下午";
                } else {
                    return "晚上";
                }
            },
            calendar: {
                sameDay: function() {
                    return this.minutes() === 0 ? "[今天]Ah[点整]" : "[今天]LT";
                },
                nextDay: function() {
                    return this.minutes() === 0 ? "[明天]Ah[点整]" : "[明天]LT";
                },
                lastDay: function() {
                    return this.minutes() === 0 ? "[昨天]Ah[点整]" : "[昨天]LT";
                },
                nextWeek: function() {
                    var startOfWeek, prefix;
                    startOfWeek = moment().startOf("week");
                    prefix = this.unix() - startOfWeek.unix() >= 7 * 24 * 3600 ? "[下]" : "[本]";
                    return this.minutes() === 0 ? prefix + "dddAh点整" : prefix + "dddAh点mm";
                },
                lastWeek: function() {
                    var startOfWeek, prefix;
                    startOfWeek = moment().startOf("week");
                    prefix = this.unix() < startOfWeek.unix() ? "[上]" : "[本]";
                    return this.minutes() === 0 ? prefix + "dddAh点整" : prefix + "dddAh点mm";
                },
                sameElse: "L"
            },
            ordinal: function(number, period) {
                switch (period) {
                  case "d":
                  case "D":
                  case "DDD":
                    return number + "日";

                  case "M":
                    return number + "月";

                  case "w":
                  case "W":
                    return number + "周";

                  default:
                    return number;
                }
            },
            relativeTime: {
                future: "%s内",
                past: "%s前",
                s: "几秒",
                m: "1分钟",
                mm: "%d分钟",
                h: "1小时",
                hh: "%d小时",
                d: "1天",
                dd: "%d天",
                M: "1个月",
                MM: "%d个月",
                y: "1年",
                yy: "%d年"
            },
            week: {
                // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
                dow: 1,
                // Monday is the first day of the week.
                doy: 4
            }
        });
    });
    // moment.js language configuration
    // language : traditional chinese (zh-tw)
    // author : Ben : https://github.com/ben-lin
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.lang("zh-tw", {
            months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
            monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
            weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
            weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"),
            weekdaysMin: "日_一_二_三_四_五_六".split("_"),
            longDateFormat: {
                LT: "Ah點mm",
                L: "YYYY年MMMD日",
                LL: "YYYY年MMMD日",
                LLL: "YYYY年MMMD日LT",
                LLLL: "YYYY年MMMD日ddddLT",
                l: "YYYY年MMMD日",
                ll: "YYYY年MMMD日",
                lll: "YYYY年MMMD日LT",
                llll: "YYYY年MMMD日ddddLT"
            },
            meridiem: function(hour, minute, isLower) {
                var hm = hour * 100 + minute;
                if (hm < 900) {
                    return "早上";
                } else if (hm < 1130) {
                    return "上午";
                } else if (hm < 1230) {
                    return "中午";
                } else if (hm < 1800) {
                    return "下午";
                } else {
                    return "晚上";
                }
            },
            calendar: {
                sameDay: "[今天]LT",
                nextDay: "[明天]LT",
                nextWeek: "[下]ddddLT",
                lastDay: "[昨天]LT",
                lastWeek: "[上]ddddLT",
                sameElse: "L"
            },
            ordinal: function(number, period) {
                switch (period) {
                  case "d":
                  case "D":
                  case "DDD":
                    return number + "日";

                  case "M":
                    return number + "月";

                  case "w":
                  case "W":
                    return number + "週";

                  default:
                    return number;
                }
            },
            relativeTime: {
                future: "%s內",
                past: "%s前",
                s: "幾秒",
                m: "一分鐘",
                mm: "%d分鐘",
                h: "一小時",
                hh: "%d小時",
                d: "一天",
                dd: "%d天",
                M: "一個月",
                MM: "%d個月",
                y: "一年",
                yy: "%d年"
            }
        });
    });
    moment.lang("en");
    return moment;
});

// Released under MIT license
// Copyright (c) 2009-2010 Dominic Baggott
// Copyright (c) 2009-2010 Ash Berlin
// Copyright (c) 2011 Christoph Dorn <christoph@christophdorn.com> (http://www.christophdorn.com)
// Date: 2013-09-15T16:12Z
define("sarike/markdown/0.6.0/markdown-debug", [], function(require, exports) {
    var MarkdownHelpers = {};
    // For Spidermonkey based engines
    function mk_block_toSource() {
        return "Markdown.mk_block( " + uneval(this.toString()) + ", " + uneval(this.trailing) + ", " + uneval(this.lineNumber) + " )";
    }
    // node
    //  function mk_block_inspect() {
    //    var util = require("util");
    //    return "Markdown.mk_block( " +
    //            util.inspect(this.toString()) +
    //            ", " +
    //            util.inspect(this.trailing) +
    //            ", " +
    //            util.inspect(this.lineNumber) +
    //            " )";
    //
    //  }
    MarkdownHelpers.mk_block = function(block, trail, line) {
        // Be helpful for default case in tests.
        if (arguments.length === 1) trail = "\n\n";
        // We actually need a String object, not a string primitive
        /* jshint -W053 */
        var s = new String(block);
        s.trailing = trail;
        // To make it clear its not just a string
        //    s.inspect = mk_block_inspect;
        s.toSource = mk_block_toSource;
        if (line !== undefined) s.lineNumber = line;
        return s;
    };
    var isArray = MarkdownHelpers.isArray = Array.isArray || function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
    };
    // Don't mess with Array.prototype. Its not friendly
    if (Array.prototype.forEach) {
        MarkdownHelpers.forEach = function forEach(arr, cb, thisp) {
            return arr.forEach(cb, thisp);
        };
    } else {
        MarkdownHelpers.forEach = function forEach(arr, cb, thisp) {
            for (var i = 0; i < arr.length; i++) cb.call(thisp || arr, arr[i], i, arr);
        };
    }
    MarkdownHelpers.isEmpty = function isEmpty(obj) {
        for (var key in obj) {
            if (hasOwnProperty.call(obj, key)) return false;
        }
        return true;
    };
    MarkdownHelpers.extract_attr = function extract_attr(jsonml) {
        return isArray(jsonml) && jsonml.length > 1 && typeof jsonml[1] === "object" && !isArray(jsonml[1]) ? jsonml[1] : undefined;
    };
    /**
   *  class Markdown
   *
   *  Markdown processing in Javascript done right. We have very particular views
   *  on what constitutes 'right' which include:
   *
   *  - produces well-formed HTML (this means that em and strong nesting is
   *    important)
   *
   *  - has an intermediate representation to allow processing of parsed data (We
   *    in fact have two, both as [JsonML]: a markdown tree and an HTML tree).
   *
   *  - is easily extensible to add new dialects without having to rewrite the
   *    entire parsing mechanics
   *
   *  - has a good test suite
   *
   *  This implementation fulfills all of these (except that the test suite could
   *  do with expanding to automatically run all the fixtures from other Markdown
   *  implementations.)
   *
   *  ##### Intermediate Representation
   *
   *  *TODO* Talk about this :) Its JsonML, but document the node names we use.
   *
   *  [JsonML]: http://jsonml.org/ "JSON Markup Language"
   **/
    var Markdown = function(dialect) {
        switch (typeof dialect) {
          case "undefined":
            this.dialect = Markdown.dialects.Gruber;
            break;

          case "object":
            this.dialect = dialect;
            break;

          default:
            if (dialect in Markdown.dialects) this.dialect = Markdown.dialects[dialect]; else throw new Error("Unknown Markdown dialect '" + String(dialect) + "'");
            break;
        }
        this.em_state = [];
        this.strong_state = [];
        this.debug_indent = "";
    };
    /**
   * Markdown.dialects
   *
   * Namespace of built-in dialects.
   **/
    Markdown.dialects = {};
    // Imported functions
    var mk_block = Markdown.mk_block = MarkdownHelpers.mk_block, isArray = MarkdownHelpers.isArray;
    /**
   *  parse( markdown, [dialect] ) -> JsonML
   *  - markdown (String): markdown string to parse
   *  - dialect (String | Dialect): the dialect to use, defaults to gruber
   *
   *  Parse `markdown` and return a markdown document as a Markdown.JsonML tree.
   **/
    Markdown.parse = function(source, dialect) {
        // dialect will default if undefined
        var md = new Markdown(dialect);
        return md.toTree(source);
    };
    function count_lines(str) {
        var n = 0, i = -1;
        while ((i = str.indexOf("\n", i + 1)) !== -1) n++;
        return n;
    }
    // Internal - split source into rough blocks
    Markdown.prototype.split_blocks = function splitBlocks(input) {
        input = input.replace(/(\r\n|\n|\r)/g, "\n");
        // [\s\S] matches _anything_ (newline or space)
        // [^] is equivalent but doesn't work in IEs.
        var re = /([\s\S]+?)($|\n#|\n(?:\s*\n|$)+)/g, blocks = [], m;
        var line_no = 1;
        if ((m = /^(\s*\n)/.exec(input)) !== null) {
            // skip (but count) leading blank lines
            line_no += count_lines(m[0]);
            re.lastIndex = m[0].length;
        }
        while ((m = re.exec(input)) !== null) {
            if (m[2] === "\n#") {
                m[2] = "\n";
                re.lastIndex--;
            }
            blocks.push(mk_block(m[1], m[2], line_no));
            line_no += count_lines(m[0]);
        }
        return blocks;
    };
    /**
   *  Markdown#processBlock( block, next ) -> undefined | [ JsonML, ... ]
   *  - block (String): the block to process
   *  - next (Array): the following blocks
   *
   * Process `block` and return an array of JsonML nodes representing `block`.
   *
   * It does this by asking each block level function in the dialect to process
   * the block until one can. Succesful handling is indicated by returning an
   * array (with zero or more JsonML nodes), failure by a false value.
   *
   * Blocks handlers are responsible for calling [[Markdown#processInline]]
   * themselves as appropriate.
   *
   * If the blocks were split incorrectly or adjacent blocks need collapsing you
   * can adjust `next` in place using shift/splice etc.
   *
   * If any of this default behaviour is not right for the dialect, you can
   * define a `__call__` method on the dialect that will get invoked to handle
   * the block processing.
   */
    Markdown.prototype.processBlock = function processBlock(block, next) {
        var cbs = this.dialect.block, ord = cbs.__order__;
        if ("__call__" in cbs) return cbs.__call__.call(this, block, next);
        for (var i = 0; i < ord.length; i++) {
            //D:this.debug( "Testing", ord[i] );
            var res = cbs[ord[i]].call(this, block, next);
            if (res) {
                //D:this.debug("  matched");
                if (!isArray(res) || res.length > 0 && !isArray(res[0])) this.debug(ord[i], "didn't return a proper array");
                //D:this.debug( "" );
                return res;
            }
        }
        // Uhoh! no match! Should we throw an error?
        return [];
    };
    Markdown.prototype.processInline = function processInline(block) {
        return this.dialect.inline.__call__.call(this, String(block));
    };
    /**
   *  Markdown#toTree( source ) -> JsonML
   *  - source (String): markdown source to parse
   *
   *  Parse `source` into a JsonML tree representing the markdown document.
   **/
    // custom_tree means set this.tree to `custom_tree` and restore old value on return
    Markdown.prototype.toTree = function toTree(source, custom_root) {
        var blocks = source instanceof Array ? source : this.split_blocks(source);
        // Make tree a member variable so its easier to mess with in extensions
        var old_tree = this.tree;
        try {
            this.tree = custom_root || this.tree || [ "markdown" ];
            blocks_loop: while (blocks.length) {
                var b = this.processBlock(blocks.shift(), blocks);
                // Reference blocks and the like won't return any content
                if (!b.length) continue blocks_loop;
                this.tree.push.apply(this.tree, b);
            }
            return this.tree;
        } finally {
            if (custom_root) this.tree = old_tree;
        }
    };
    // Noop by default
    Markdown.prototype.debug = function() {
        var args = Array.prototype.slice.call(arguments);
        args.unshift(this.debug_indent);
        if (typeof print !== "undefined") print.apply(print, args);
        if (typeof console !== "undefined" && typeof console.log !== "undefined") console.log.apply(null, args);
    };
    Markdown.prototype.loop_re_over_block = function(re, block, cb) {
        // Dont use /g regexps with this
        var m, b = block.valueOf();
        while (b.length && (m = re.exec(b)) !== null) {
            b = b.substr(m[0].length);
            cb.call(this, m);
        }
        return b;
    };
    // Build default order from insertion order.
    Markdown.buildBlockOrder = function(d) {
        var ord = [];
        for (var i in d) {
            if (i === "__order__" || i === "__call__") continue;
            ord.push(i);
        }
        d.__order__ = ord;
    };
    // Build patterns for inline matcher
    Markdown.buildInlinePatterns = function(d) {
        var patterns = [];
        for (var i in d) {
            // __foo__ is reserved and not a pattern
            if (i.match(/^__.*__$/)) continue;
            var l = i.replace(/([\\.*+?|()\[\]{}])/g, "\\$1").replace(/\n/, "\\n");
            patterns.push(i.length === 1 ? l : "(?:" + l + ")");
        }
        patterns = patterns.join("|");
        d.__patterns__ = patterns;
        //print("patterns:", uneval( patterns ) );
        var fn = d.__call__;
        d.__call__ = function(text, pattern) {
            if (pattern !== undefined) return fn.call(this, text, pattern); else return fn.call(this, text, patterns);
        };
    };
    var extract_attr = MarkdownHelpers.extract_attr;
    /**
   *  renderJsonML( jsonml[, options] ) -> String
   *  - jsonml (Array): JsonML array to render to XML
   *  - options (Object): options
   *
   *  Converts the given JsonML into well-formed XML.
   *
   *  The options currently understood are:
   *
   *  - root (Boolean): wether or not the root node should be included in the
   *    output, or just its children. The default `false` is to not include the
   *    root itself.
   */
    Markdown.renderJsonML = function(jsonml, options) {
        options = options || {};
        // include the root element in the rendered output?
        options.root = options.root || false;
        var content = [];
        if (options.root) {
            content.push(render_tree(jsonml));
        } else {
            jsonml.shift();
            // get rid of the tag
            if (jsonml.length && typeof jsonml[0] === "object" && !(jsonml[0] instanceof Array)) jsonml.shift();
            // get rid of the attributes
            while (jsonml.length) content.push(render_tree(jsonml.shift()));
        }
        return content.join("\n\n");
    };
    /**
   *  toHTMLTree( markdown, [dialect] ) -> JsonML
   *  toHTMLTree( md_tree ) -> JsonML
   *  - markdown (String): markdown string to parse
   *  - dialect (String | Dialect): the dialect to use, defaults to gruber
   *  - md_tree (Markdown.JsonML): parsed markdown tree
   *
   *  Turn markdown into HTML, represented as a JsonML tree. If a string is given
   *  to this function, it is first parsed into a markdown tree by calling
   *  [[parse]].
   **/
    Markdown.toHTMLTree = function toHTMLTree(input, dialect, options) {
        // convert string input to an MD tree
        if (typeof input === "string") input = this.parse(input, dialect);
        // Now convert the MD tree to an HTML tree
        // remove references from the tree
        var attrs = extract_attr(input), refs = {};
        if (attrs && attrs.references) refs = attrs.references;
        var html = convert_tree_to_html(input, refs, options);
        merge_text_nodes(html);
        return html;
    };
    /**
   *  toHTML( markdown, [dialect]  ) -> String
   *  toHTML( md_tree ) -> String
   *  - markdown (String): markdown string to parse
   *  - md_tree (Markdown.JsonML): parsed markdown tree
   *
   *  Take markdown (either as a string or as a JsonML tree) and run it through
   *  [[toHTMLTree]] then turn it into a well-formated HTML fragment.
   **/
    Markdown.toHTML = function toHTML(source, dialect, options) {
        var input = this.toHTMLTree(source, dialect, options);
        return this.renderJsonML(input);
    };
    function escapeHTML(text) {
        return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
    }
    function render_tree(jsonml) {
        // basic case
        if (typeof jsonml === "string") return escapeHTML(jsonml);
        var tag = jsonml.shift(), attributes = {}, content = [];
        if (jsonml.length && typeof jsonml[0] === "object" && !(jsonml[0] instanceof Array)) attributes = jsonml.shift();
        while (jsonml.length) content.push(render_tree(jsonml.shift()));
        var tag_attrs = "";
        for (var a in attributes) tag_attrs += " " + a + '="' + escapeHTML(attributes[a]) + '"';
        // be careful about adding whitespace here for inline elements
        if (tag === "img" || tag === "br" || tag === "hr") return "<" + tag + tag_attrs + "/>"; else return "<" + tag + tag_attrs + ">" + content.join("") + "</" + tag + ">";
    }
    function convert_tree_to_html(tree, references, options) {
        var i;
        options = options || {};
        // shallow clone
        var jsonml = tree.slice(0);
        if (typeof options.preprocessTreeNode === "function") jsonml = options.preprocessTreeNode(jsonml, references);
        // Clone attributes if they exist
        var attrs = extract_attr(jsonml);
        if (attrs) {
            jsonml[1] = {};
            for (i in attrs) {
                jsonml[1][i] = attrs[i];
            }
            attrs = jsonml[1];
        }
        // basic case
        if (typeof jsonml === "string") return jsonml;
        // convert this node
        switch (jsonml[0]) {
          case "header":
            jsonml[0] = "h" + jsonml[1].level;
            delete jsonml[1].level;
            break;

          case "bulletlist":
            jsonml[0] = "ul";
            break;

          case "numberlist":
            jsonml[0] = "ol";
            break;

          case "listitem":
            jsonml[0] = "li";
            break;

          case "para":
            jsonml[0] = "p";
            break;

          case "markdown":
            jsonml[0] = "html";
            if (attrs) delete attrs.references;
            break;

          case "code_block":
            jsonml[0] = "pre";
            i = attrs ? 2 : 1;
            var code = [ "code" ];
            code.push.apply(code, jsonml.splice(i, jsonml.length - i));
            jsonml[i] = code;
            break;

          case "inlinecode":
            jsonml[0] = "code";
            break;

          case "img":
            jsonml[1].src = jsonml[1].href;
            delete jsonml[1].href;
            break;

          case "linebreak":
            jsonml[0] = "br";
            break;

          case "link":
            jsonml[0] = "a";
            break;

          case "link_ref":
            jsonml[0] = "a";
            // grab this ref and clean up the attribute node
            var ref = references[attrs.ref];
            // if the reference exists, make the link
            if (ref) {
                delete attrs.ref;
                // add in the href and title, if present
                attrs.href = ref.href;
                if (ref.title) attrs.title = ref.title;
                // get rid of the unneeded original text
                delete attrs.original;
            } else {
                return attrs.original;
            }
            break;

          case "img_ref":
            jsonml[0] = "img";
            // grab this ref and clean up the attribute node
            var ref = references[attrs.ref];
            // if the reference exists, make the link
            if (ref) {
                delete attrs.ref;
                // add in the href and title, if present
                attrs.src = ref.href;
                if (ref.title) attrs.title = ref.title;
                // get rid of the unneeded original text
                delete attrs.original;
            } else {
                return attrs.original;
            }
            break;
        }
        // convert all the children
        i = 1;
        // deal with the attribute node, if it exists
        if (attrs) {
            // if there are keys, skip over it
            for (var key in jsonml[1]) {
                i = 2;
                break;
            }
            // if there aren't, remove it
            if (i === 1) jsonml.splice(i, 1);
        }
        for (;i < jsonml.length; ++i) {
            jsonml[i] = convert_tree_to_html(jsonml[i], references, options);
        }
        return jsonml;
    }
    // merges adjacent text nodes into a single node
    function merge_text_nodes(jsonml) {
        // skip the tag name and attribute hash
        var i = extract_attr(jsonml) ? 2 : 1;
        while (i < jsonml.length) {
            // if it's a string check the next item too
            if (typeof jsonml[i] === "string") {
                if (i + 1 < jsonml.length && typeof jsonml[i + 1] === "string") {
                    // merge the second string into the first and remove it
                    jsonml[i] += jsonml.splice(i + 1, 1)[0];
                } else {
                    ++i;
                }
            } else {
                merge_text_nodes(jsonml[i]);
                ++i;
            }
        }
    }
    var DialectHelpers = {};
    DialectHelpers.inline_until_char = function(text, want) {
        var consumed = 0, nodes = [];
        while (true) {
            if (text.charAt(consumed) === want) {
                // Found the character we were looking for
                consumed++;
                return [ consumed, nodes ];
            }
            if (consumed >= text.length) {
                // No closing char found. Abort.
                return null;
            }
            var res = this.dialect.inline.__oneElement__.call(this, text.substr(consumed));
            consumed += res[0];
            // Add any returned nodes.
            nodes.push.apply(nodes, res.slice(1));
        }
    };
    // Helper function to make sub-classing a dialect easier
    DialectHelpers.subclassDialect = function(d) {
        function Block() {}
        Block.prototype = d.block;
        function Inline() {}
        Inline.prototype = d.inline;
        return {
            block: new Block(),
            inline: new Inline()
        };
    };
    var forEach = MarkdownHelpers.forEach, extract_attr = MarkdownHelpers.extract_attr, mk_block = MarkdownHelpers.mk_block, isEmpty = MarkdownHelpers.isEmpty, inline_until_char = DialectHelpers.inline_until_char;
    /**
   * Gruber dialect
   *
   * The default dialect that follows the rules set out by John Gruber's
   * markdown.pl as closely as possible. Well actually we follow the behaviour of
   * that script which in some places is not exactly what the syntax web page
   * says.
   **/
    var Gruber = {
        block: {
            atxHeader: function atxHeader(block, next) {
                var m = block.match(/^(#{1,6})\s*(.*?)\s*#*\s*(?:\n|$)/);
                if (!m) return undefined;
                var header = [ "header", {
                    level: m[1].length
                } ];
                Array.prototype.push.apply(header, this.processInline(m[2]));
                if (m[0].length < block.length) next.unshift(mk_block(block.substr(m[0].length), block.trailing, block.lineNumber + 2));
                return [ header ];
            },
            setextHeader: function setextHeader(block, next) {
                var m = block.match(/^(.*)\n([-=])\2\2+(?:\n|$)/);
                if (!m) return undefined;
                var level = m[2] === "=" ? 1 : 2, header = [ "header", {
                    level: level
                }, m[1] ];
                if (m[0].length < block.length) next.unshift(mk_block(block.substr(m[0].length), block.trailing, block.lineNumber + 2));
                return [ header ];
            },
            code: function code(block, next) {
                // |    Foo
                // |bar
                // should be a code block followed by a paragraph. Fun
                //
                // There might also be adjacent code block to merge.
                var ret = [], re = /^(?: {0,3}\t| {4})(.*)\n?/;
                // 4 spaces + content
                if (!block.match(re)) return undefined;
                block_search: do {
                    // Now pull out the rest of the lines
                    var b = this.loop_re_over_block(re, block.valueOf(), function(m) {
                        ret.push(m[1]);
                    });
                    if (b.length) {
                        // Case alluded to in first comment. push it back on as a new block
                        next.unshift(mk_block(b, block.trailing));
                        break block_search;
                    } else if (next.length) {
                        // Check the next block - it might be code too
                        if (!next[0].match(re)) break block_search;
                        // Pull how how many blanks lines follow - minus two to account for .join
                        ret.push(block.trailing.replace(/[^\n]/g, "").substring(2));
                        block = next.shift();
                    } else {
                        break block_search;
                    }
                } while (true);
                return [ [ "code_block", ret.join("\n") ] ];
            },
            horizRule: function horizRule(block, next) {
                // this needs to find any hr in the block to handle abutting blocks
                var m = block.match(/^(?:([\s\S]*?)\n)?[ \t]*([-_*])(?:[ \t]*\2){2,}[ \t]*(?:\n([\s\S]*))?$/);
                if (!m) return undefined;
                var jsonml = [ [ "hr" ] ];
                // if there's a leading abutting block, process it
                if (m[1]) {
                    var contained = mk_block(m[1], "", block.lineNumber);
                    jsonml.unshift.apply(jsonml, this.toTree(contained, []));
                }
                // if there's a trailing abutting block, stick it into next
                if (m[3]) next.unshift(mk_block(m[3], block.trailing, block.lineNumber + 1));
                return jsonml;
            },
            // There are two types of lists. Tight and loose. Tight lists have no whitespace
            // between the items (and result in text just in the <li>) and loose lists,
            // which have an empty line between list items, resulting in (one or more)
            // paragraphs inside the <li>.
            //
            // There are all sorts weird edge cases about the original markdown.pl's
            // handling of lists:
            //
            // * Nested lists are supposed to be indented by four chars per level. But
            //   if they aren't, you can get a nested list by indenting by less than
            //   four so long as the indent doesn't match an indent of an existing list
            //   item in the 'nest stack'.
            //
            // * The type of the list (bullet or number) is controlled just by the
            //    first item at the indent. Subsequent changes are ignored unless they
            //    are for nested lists
            //
            lists: function() {
                // Use a closure to hide a few variables.
                var any_list = "[*+-]|\\d+\\.", bullet_list = /[*+-]/, // Capture leading indent as it matters for determining nested lists.
                is_list_re = new RegExp("^( {0,3})(" + any_list + ")[ 	]+"), indent_re = "(?: {0,3}\\t| {4})";
                // TODO: Cache this regexp for certain depths.
                // Create a regexp suitable for matching an li for a given stack depth
                function regex_for_depth(depth) {
                    return new RegExp(// m[1] = indent, m[2] = list_type
                    "(?:^(" + indent_re + "{0," + depth + "} {0,3})(" + any_list + ")\\s+)|" + // m[3] = cont
                    "(^" + indent_re + "{0," + (depth - 1) + "}[ ]{0,4})");
                }
                function expand_tab(input) {
                    return input.replace(/ {0,3}\t/g, "    ");
                }
                // Add inline content `inline` to `li`. inline comes from processInline
                // so is an array of content
                function add(li, loose, inline, nl) {
                    if (loose) {
                        li.push([ "para" ].concat(inline));
                        return;
                    }
                    // Hmmm, should this be any block level element or just paras?
                    var add_to = li[li.length - 1] instanceof Array && li[li.length - 1][0] === "para" ? li[li.length - 1] : li;
                    // If there is already some content in this list, add the new line in
                    if (nl && li.length > 1) inline.unshift(nl);
                    for (var i = 0; i < inline.length; i++) {
                        var what = inline[i], is_str = typeof what === "string";
                        if (is_str && add_to.length > 1 && typeof add_to[add_to.length - 1] === "string") add_to[add_to.length - 1] += what; else add_to.push(what);
                    }
                }
                // contained means have an indent greater than the current one. On
                // *every* line in the block
                function get_contained_blocks(depth, blocks) {
                    var re = new RegExp("^(" + indent_re + "{" + depth + "}.*?\\n?)*$"), replace = new RegExp("^" + indent_re + "{" + depth + "}", "gm"), ret = [];
                    while (blocks.length > 0) {
                        if (re.exec(blocks[0])) {
                            var b = blocks.shift(), // Now remove that indent
                            x = b.replace(replace, "");
                            ret.push(mk_block(x, b.trailing, b.lineNumber));
                        } else break;
                    }
                    return ret;
                }
                // passed to stack.forEach to turn list items up the stack into paras
                function paragraphify(s, i, stack) {
                    var list = s.list;
                    var last_li = list[list.length - 1];
                    if (last_li[1] instanceof Array && last_li[1][0] === "para") return;
                    if (i + 1 === stack.length) {
                        // Last stack frame
                        // Keep the same array, but replace the contents
                        last_li.push([ "para" ].concat(last_li.splice(1, last_li.length - 1)));
                    } else {
                        var sublist = last_li.pop();
                        last_li.push([ "para" ].concat(last_li.splice(1, last_li.length - 1)), sublist);
                    }
                }
                // The matcher function
                return function(block, next) {
                    var m = block.match(is_list_re);
                    if (!m) return undefined;
                    function make_list(m) {
                        var list = bullet_list.exec(m[2]) ? [ "bulletlist" ] : [ "numberlist" ];
                        stack.push({
                            list: list,
                            indent: m[1]
                        });
                        return list;
                    }
                    var stack = [], // Stack of lists for nesting.
                    list = make_list(m), last_li, loose = false, ret = [ stack[0].list ], i;
                    // Loop to search over block looking for inner block elements and loose lists
                    loose_search: while (true) {
                        // Split into lines preserving new lines at end of line
                        var lines = block.split(/(?=\n)/);
                        // We have to grab all lines for a li and call processInline on them
                        // once as there are some inline things that can span lines.
                        var li_accumulate = "", nl = "";
                        // Loop over the lines in this block looking for tight lists.
                        tight_search: for (var line_no = 0; line_no < lines.length; line_no++) {
                            nl = "";
                            var l = lines[line_no].replace(/^\n/, function(n) {
                                nl = n;
                                return "";
                            });
                            // TODO: really should cache this
                            var line_re = regex_for_depth(stack.length);
                            m = l.match(line_re);
                            //print( "line:", uneval(l), "\nline match:", uneval(m) );
                            // We have a list item
                            if (m[1] !== undefined) {
                                // Process the previous list item, if any
                                if (li_accumulate.length) {
                                    add(last_li, loose, this.processInline(li_accumulate), nl);
                                    // Loose mode will have been dealt with. Reset it
                                    loose = false;
                                    li_accumulate = "";
                                }
                                m[1] = expand_tab(m[1]);
                                var wanted_depth = Math.floor(m[1].length / 4) + 1;
                                //print( "want:", wanted_depth, "stack:", stack.length);
                                if (wanted_depth > stack.length) {
                                    // Deep enough for a nested list outright
                                    //print ( "new nested list" );
                                    list = make_list(m);
                                    last_li.push(list);
                                    last_li = list[1] = [ "listitem" ];
                                } else {
                                    // We aren't deep enough to be strictly a new level. This is
                                    // where Md.pl goes nuts. If the indent matches a level in the
                                    // stack, put it there, else put it one deeper then the
                                    // wanted_depth deserves.
                                    var found = false;
                                    for (i = 0; i < stack.length; i++) {
                                        if (stack[i].indent !== m[1]) continue;
                                        list = stack[i].list;
                                        stack.splice(i + 1, stack.length - (i + 1));
                                        found = true;
                                        break;
                                    }
                                    if (!found) {
                                        //print("not found. l:", uneval(l));
                                        wanted_depth++;
                                        if (wanted_depth <= stack.length) {
                                            stack.splice(wanted_depth, stack.length - wanted_depth);
                                            //print("Desired depth now", wanted_depth, "stack:", stack.length);
                                            list = stack[wanted_depth - 1].list;
                                        } else {
                                            //print ("made new stack for messy indent");
                                            list = make_list(m);
                                            last_li.push(list);
                                        }
                                    }
                                    //print( uneval(list), "last", list === stack[stack.length-1].list );
                                    last_li = [ "listitem" ];
                                    list.push(last_li);
                                }
                                // end depth of shenegains
                                nl = "";
                            }
                            // Add content
                            if (l.length > m[0].length) li_accumulate += nl + l.substr(m[0].length);
                        }
                        // tight_search
                        if (li_accumulate.length) {
                            add(last_li, loose, this.processInline(li_accumulate), nl);
                            // Loose mode will have been dealt with. Reset it
                            loose = false;
                            li_accumulate = "";
                        }
                        // Look at the next block - we might have a loose list. Or an extra
                        // paragraph for the current li
                        var contained = get_contained_blocks(stack.length, next);
                        // Deal with code blocks or properly nested lists
                        if (contained.length > 0) {
                            // Make sure all listitems up the stack are paragraphs
                            forEach(stack, paragraphify, this);
                            last_li.push.apply(last_li, this.toTree(contained, []));
                        }
                        var next_block = next[0] && next[0].valueOf() || "";
                        if (next_block.match(is_list_re) || next_block.match(/^ /)) {
                            block = next.shift();
                            // Check for an HR following a list: features/lists/hr_abutting
                            var hr = this.dialect.block.horizRule(block, next);
                            if (hr) {
                                ret.push.apply(ret, hr);
                                break;
                            }
                            // Make sure all listitems up the stack are paragraphs
                            forEach(stack, paragraphify, this);
                            loose = true;
                            continue loose_search;
                        }
                        break;
                    }
                    // loose_search
                    return ret;
                };
            }(),
            blockquote: function blockquote(block, next) {
                if (!block.match(/^>/m)) return undefined;
                var jsonml = [];
                // separate out the leading abutting block, if any. I.e. in this case:
                //
                //  a
                //  > b
                //
                if (block[0] !== ">") {
                    var lines = block.split(/\n/), prev = [], line_no = block.lineNumber;
                    // keep shifting lines until you find a crotchet
                    while (lines.length && lines[0][0] !== ">") {
                        prev.push(lines.shift());
                        line_no++;
                    }
                    var abutting = mk_block(prev.join("\n"), "\n", block.lineNumber);
                    jsonml.push.apply(jsonml, this.processBlock(abutting, []));
                    // reassemble new block of just block quotes!
                    block = mk_block(lines.join("\n"), block.trailing, line_no);
                }
                // if the next block is also a blockquote merge it in
                while (next.length && next[0][0] === ">") {
                    var b = next.shift();
                    block = mk_block(block + block.trailing + b, b.trailing, block.lineNumber);
                }
                // Strip off the leading "> " and re-process as a block.
                var input = block.replace(/^> ?/gm, ""), old_tree = this.tree, processedBlock = this.toTree(input, [ "blockquote" ]), attr = extract_attr(processedBlock);
                // If any link references were found get rid of them
                if (attr && attr.references) {
                    delete attr.references;
                    // And then remove the attribute object if it's empty
                    if (isEmpty(attr)) processedBlock.splice(1, 1);
                }
                jsonml.push(processedBlock);
                return jsonml;
            },
            referenceDefn: function referenceDefn(block, next) {
                var re = /^\s*\[(.*?)\]:\s*(\S+)(?:\s+(?:(['"])(.*?)\3|\((.*?)\)))?\n?/;
                // interesting matches are [ , ref_id, url, , title, title ]
                if (!block.match(re)) return undefined;
                // make an attribute node if it doesn't exist
                if (!extract_attr(this.tree)) this.tree.splice(1, 0, {});
                var attrs = extract_attr(this.tree);
                // make a references hash if it doesn't exist
                if (attrs.references === undefined) attrs.references = {};
                var b = this.loop_re_over_block(re, block, function(m) {
                    if (m[2] && m[2][0] === "<" && m[2][m[2].length - 1] === ">") m[2] = m[2].substring(1, m[2].length - 1);
                    var ref = attrs.references[m[1].toLowerCase()] = {
                        href: m[2]
                    };
                    if (m[4] !== undefined) ref.title = m[4]; else if (m[5] !== undefined) ref.title = m[5];
                });
                if (b.length) next.unshift(mk_block(b, block.trailing));
                return [];
            },
            para: function para(block) {
                // everything's a para!
                return [ [ "para" ].concat(this.processInline(block)) ];
            }
        },
        inline: {
            __oneElement__: function oneElement(text, patterns_or_re, previous_nodes) {
                var m, res;
                patterns_or_re = patterns_or_re || this.dialect.inline.__patterns__;
                var re = new RegExp("([\\s\\S]*?)(" + (patterns_or_re.source || patterns_or_re) + ")");
                m = re.exec(text);
                if (!m) {
                    // Just boring text
                    return [ text.length, text ];
                } else if (m[1]) {
                    // Some un-interesting text matched. Return that first
                    return [ m[1].length, m[1] ];
                }
                var res;
                if (m[2] in this.dialect.inline) {
                    res = this.dialect.inline[m[2]].call(this, text.substr(m.index), m, previous_nodes || []);
                }
                // Default for now to make dev easier. just slurp special and output it.
                res = res || [ m[2].length, m[2] ];
                return res;
            },
            __call__: function inline(text, patterns) {
                var out = [], res;
                function add(x) {
                    //D:self.debug("  adding output", uneval(x));
                    if (typeof x === "string" && typeof out[out.length - 1] === "string") out[out.length - 1] += x; else out.push(x);
                }
                while (text.length > 0) {
                    res = this.dialect.inline.__oneElement__.call(this, text, patterns, out);
                    text = text.substr(res.shift());
                    forEach(res, add);
                }
                return out;
            },
            // These characters are intersting elsewhere, so have rules for them so that
            // chunks of plain text blocks don't include them
            "]": function() {},
            "}": function() {},
            __escape__: /^\\[\\`\*_{}\[\]()#\+.!\-]/,
            "\\": function escaped(text) {
                // [ length of input processed, node/children to add... ]
                // Only esacape: \ ` * _ { } [ ] ( ) # * + - . !
                if (this.dialect.inline.__escape__.exec(text)) return [ 2, text.charAt(1) ]; else // Not an esacpe
                return [ 1, "\\" ];
            },
            "![": function image(text) {
                // Unlike images, alt text is plain text only. no other elements are
                // allowed in there
                // ![Alt text](/path/to/img.jpg "Optional title")
                //      1          2            3       4         <--- captures
                var m = text.match(/^!\[(.*?)\][ \t]*\([ \t]*([^")]*?)(?:[ \t]+(["'])(.*?)\3)?[ \t]*\)/);
                if (m) {
                    if (m[2] && m[2][0] === "<" && m[2][m[2].length - 1] === ">") m[2] = m[2].substring(1, m[2].length - 1);
                    m[2] = this.dialect.inline.__call__.call(this, m[2], /\\/)[0];
                    var attrs = {
                        alt: m[1],
                        href: m[2] || ""
                    };
                    if (m[4] !== undefined) attrs.title = m[4];
                    return [ m[0].length, [ "img", attrs ] ];
                }
                // ![Alt text][id]
                m = text.match(/^!\[(.*?)\][ \t]*\[(.*?)\]/);
                if (m) {
                    // We can't check if the reference is known here as it likely wont be
                    // found till after. Check it in md tree->hmtl tree conversion
                    return [ m[0].length, [ "img_ref", {
                        alt: m[1],
                        ref: m[2].toLowerCase(),
                        original: m[0]
                    } ] ];
                }
                // Just consume the '!['
                return [ 2, "![" ];
            },
            "[": function link(text) {
                var orig = String(text);
                // Inline content is possible inside `link text`
                var res = inline_until_char.call(this, text.substr(1), "]");
                // No closing ']' found. Just consume the [
                if (!res) return [ 1, "[" ];
                var consumed = 1 + res[0], children = res[1], link, attrs;
                // At this point the first [...] has been parsed. See what follows to find
                // out which kind of link we are (reference or direct url)
                text = text.substr(consumed);
                // [link text](/path/to/img.jpg "Optional title")
                //                 1            2       3         <--- captures
                // This will capture up to the last paren in the block. We then pull
                // back based on if there a matching ones in the url
                //    ([here](/url/(test))
                // The parens have to be balanced
                var m = text.match(/^\s*\([ \t]*([^"']*)(?:[ \t]+(["'])(.*?)\2)?[ \t]*\)/);
                if (m) {
                    var url = m[1];
                    consumed += m[0].length;
                    if (url && url[0] === "<" && url[url.length - 1] === ">") url = url.substring(1, url.length - 1);
                    // If there is a title we don't have to worry about parens in the url
                    if (!m[3]) {
                        var open_parens = 1;
                        // One open that isn't in the capture
                        for (var len = 0; len < url.length; len++) {
                            switch (url[len]) {
                              case "(":
                                open_parens++;
                                break;

                              case ")":
                                if (--open_parens === 0) {
                                    consumed -= url.length - len;
                                    url = url.substring(0, len);
                                }
                                break;
                            }
                        }
                    }
                    // Process escapes only
                    url = this.dialect.inline.__call__.call(this, url, /\\/)[0];
                    attrs = {
                        href: url || ""
                    };
                    if (m[3] !== undefined) attrs.title = m[3];
                    link = [ "link", attrs ].concat(children);
                    return [ consumed, link ];
                }
                // [Alt text][id]
                // [Alt text] [id]
                m = text.match(/^\s*\[(.*?)\]/);
                if (m) {
                    consumed += m[0].length;
                    // [links][] uses links as its reference
                    attrs = {
                        ref: (m[1] || String(children)).toLowerCase(),
                        original: orig.substr(0, consumed)
                    };
                    link = [ "link_ref", attrs ].concat(children);
                    // We can't check if the reference is known here as it likely wont be
                    // found till after. Check it in md tree->hmtl tree conversion.
                    // Store the original so that conversion can revert if the ref isn't found.
                    return [ consumed, link ];
                }
                // [id]
                // Only if id is plain (no formatting.)
                if (children.length === 1 && typeof children[0] === "string") {
                    attrs = {
                        ref: children[0].toLowerCase(),
                        original: orig.substr(0, consumed)
                    };
                    link = [ "link_ref", attrs, children[0] ];
                    return [ consumed, link ];
                }
                // Just consume the "["
                return [ 1, "[" ];
            },
            "<": function autoLink(text) {
                var m;
                if ((m = text.match(/^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\.[a-zA-Z]+))>/)) !== null) {
                    if (m[3]) return [ m[0].length, [ "link", {
                        href: "mailto:" + m[3]
                    }, m[3] ] ]; else if (m[2] === "mailto") return [ m[0].length, [ "link", {
                        href: m[1]
                    }, m[1].substr("mailto:".length) ] ]; else return [ m[0].length, [ "link", {
                        href: m[1]
                    }, m[1] ] ];
                }
                return [ 1, "<" ];
            },
            "`": function inlineCode(text) {
                // Inline code block. as many backticks as you like to start it
                // Always skip over the opening ticks.
                var m = text.match(/(`+)(([\s\S]*?)\1)/);
                if (m && m[2]) return [ m[1].length + m[2].length, [ "inlinecode", m[3] ] ]; else {
                    // TODO: No matching end code found - warn!
                    return [ 1, "`" ];
                }
            },
            "  \n": function lineBreak() {
                return [ 3, [ "linebreak" ] ];
            }
        }
    };
    // Meta Helper/generator method for em and strong handling
    function strong_em(tag, md) {
        var state_slot = tag + "_state", other_slot = tag === "strong" ? "em_state" : "strong_state";
        function CloseTag(len) {
            this.len_after = len;
            this.name = "close_" + md;
        }
        return function(text) {
            if (this[state_slot][0] === md) {
                // Most recent em is of this type
                //D:this.debug("closing", md);
                this[state_slot].shift();
                // "Consume" everything to go back to the recrusion in the else-block below
                return [ text.length, new CloseTag(text.length - md.length) ];
            } else {
                // Store a clone of the em/strong states
                var other = this[other_slot].slice(), state = this[state_slot].slice();
                this[state_slot].unshift(md);
                //D:this.debug_indent += "  ";
                // Recurse
                var res = this.processInline(text.substr(md.length));
                //D:this.debug_indent = this.debug_indent.substr(2);
                var last = res[res.length - 1];
                //D:this.debug("processInline from", tag + ": ", uneval( res ) );
                var check = this[state_slot].shift();
                if (last instanceof CloseTag) {
                    res.pop();
                    // We matched! Huzzah.
                    var consumed = text.length - last.len_after;
                    return [ consumed, [ tag ].concat(res) ];
                } else {
                    // Restore the state of the other kind. We might have mistakenly closed it.
                    this[other_slot] = other;
                    this[state_slot] = state;
                    // We can't reuse the processed result as it could have wrong parsing contexts in it.
                    return [ md.length, md ];
                }
            }
        };
    }
    Gruber.inline["**"] = strong_em("strong", "**");
    Gruber.inline["__"] = strong_em("strong", "__");
    Gruber.inline["*"] = strong_em("em", "*");
    Gruber.inline["_"] = strong_em("em", "_");
    Markdown.dialects.Gruber = Gruber;
    Markdown.buildBlockOrder(Markdown.dialects.Gruber.block);
    Markdown.buildInlinePatterns(Markdown.dialects.Gruber.inline);
    var Maruku = DialectHelpers.subclassDialect(Gruber), extract_attr = MarkdownHelpers.extract_attr, forEach = MarkdownHelpers.forEach;
    Maruku.processMetaHash = function processMetaHash(meta_string) {
        var meta = split_meta_hash(meta_string), attr = {};
        for (var i = 0; i < meta.length; ++i) {
            // id: #foo
            if (/^#/.test(meta[i])) attr.id = meta[i].substring(1); else if (/^\./.test(meta[i])) {
                // if class already exists, append the new one
                if (attr["class"]) attr["class"] = attr["class"] + meta[i].replace(/./, " "); else attr["class"] = meta[i].substring(1);
            } else if (/\=/.test(meta[i])) {
                var s = meta[i].split(/\=/);
                attr[s[0]] = s[1];
            }
        }
        return attr;
    };
    function split_meta_hash(meta_string) {
        var meta = meta_string.split(""), parts = [ "" ], in_quotes = false;
        while (meta.length) {
            var letter = meta.shift();
            switch (letter) {
              case " ":
                // if we're in a quoted section, keep it
                if (in_quotes) parts[parts.length - 1] += letter; else parts.push("");
                break;

              case "'":
              case '"':
                // reverse the quotes and move straight on
                in_quotes = !in_quotes;
                break;

              case "\\":
                // shift off the next letter to be used straight away.
                // it was escaped so we'll keep it whatever it is
                letter = meta.shift();

              /* falls through */
                default:
                parts[parts.length - 1] += letter;
                break;
            }
        }
        return parts;
    }
    Maruku.block.document_meta = function document_meta(block) {
        // we're only interested in the first block
        if (block.lineNumber > 1) return undefined;
        // document_meta blocks consist of one or more lines of `Key: Value\n`
        if (!block.match(/^(?:\w+:.*\n)*\w+:.*$/)) return undefined;
        // make an attribute node if it doesn't exist
        if (!extract_attr(this.tree)) this.tree.splice(1, 0, {});
        var pairs = block.split(/\n/);
        for (var p in pairs) {
            var m = pairs[p].match(/(\w+):\s*(.*)$/), key = m[1].toLowerCase(), value = m[2];
            this.tree[1][key] = value;
        }
        // document_meta produces no content!
        return [];
    };
    Maruku.block.block_meta = function block_meta(block) {
        // check if the last line of the block is an meta hash
        var m = block.match(/(^|\n) {0,3}\{:\s*((?:\\\}|[^\}])*)\s*\}$/);
        if (!m) return undefined;
        // process the meta hash
        var attr = this.dialect.processMetaHash(m[2]), hash;
        // if we matched ^ then we need to apply meta to the previous block
        if (m[1] === "") {
            var node = this.tree[this.tree.length - 1];
            hash = extract_attr(node);
            // if the node is a string (rather than JsonML), bail
            if (typeof node === "string") return undefined;
            // create the attribute hash if it doesn't exist
            if (!hash) {
                hash = {};
                node.splice(1, 0, hash);
            }
            // add the attributes in
            for (var a in attr) hash[a] = attr[a];
            // return nothing so the meta hash is removed
            return [];
        }
        // pull the meta hash off the block and process what's left
        var b = block.replace(/\n.*$/, ""), result = this.processBlock(b, []);
        // get or make the attributes hash
        hash = extract_attr(result[0]);
        if (!hash) {
            hash = {};
            result[0].splice(1, 0, hash);
        }
        // attach the attributes to the block
        for (var a in attr) hash[a] = attr[a];
        return result;
    };
    Maruku.block.definition_list = function definition_list(block, next) {
        // one or more terms followed by one or more definitions, in a single block
        var tight = /^((?:[^\s:].*\n)+):\s+([\s\S]+)$/, list = [ "dl" ], i, m;
        // see if we're dealing with a tight or loose block
        if (m = block.match(tight)) {
            // pull subsequent tight DL blocks out of `next`
            var blocks = [ block ];
            while (next.length && tight.exec(next[0])) blocks.push(next.shift());
            for (var b = 0; b < blocks.length; ++b) {
                var m = blocks[b].match(tight), terms = m[1].replace(/\n$/, "").split(/\n/), defns = m[2].split(/\n:\s+/);
                // print( uneval( m ) );
                for (i = 0; i < terms.length; ++i) list.push([ "dt", terms[i] ]);
                for (i = 0; i < defns.length; ++i) {
                    // run inline processing over the definition
                    list.push([ "dd" ].concat(this.processInline(defns[i].replace(/(\n)\s+/, "$1"))));
                }
            }
        } else {
            return undefined;
        }
        return [ list ];
    };
    // splits on unescaped instances of @ch. If @ch is not a character the result
    // can be unpredictable
    Maruku.block.table = function table(block) {
        var _split_on_unescaped = function(s, ch) {
            ch = ch || "\\s";
            if (ch.match(/^[\\|\[\]{}?*.+^$]$/)) ch = "\\" + ch;
            var res = [], r = new RegExp("^((?:\\\\.|[^\\\\" + ch + "])*)" + ch + "(.*)"), m;
            while (m = s.match(r)) {
                res.push(m[1]);
                s = m[2];
            }
            res.push(s);
            return res;
        };
        var leading_pipe = /^ {0,3}\|(.+)\n {0,3}\|\s*([\-:]+[\-| :]*)\n((?:\s*\|.*(?:\n|$))*)(?=\n|$)/, // find at least an unescaped pipe in each line
        no_leading_pipe = /^ {0,3}(\S(?:\\.|[^\\|])*\|.*)\n {0,3}([\-:]+\s*\|[\-| :]*)\n((?:(?:\\.|[^\\|])*\|.*(?:\n|$))*)(?=\n|$)/, i, m;
        if (m = block.match(leading_pipe)) {
            // remove leading pipes in contents
            // (header and horizontal rule already have the leading pipe left out)
            m[3] = m[3].replace(/^\s*\|/gm, "");
        } else if (!(m = block.match(no_leading_pipe))) {
            return undefined;
        }
        var table = [ "table", [ "thead", [ "tr" ] ], [ "tbody" ] ];
        // remove trailing pipes, then split on pipes
        // (no escaped pipes are allowed in horizontal rule)
        m[2] = m[2].replace(/\|\s*$/, "").split("|");
        // process alignment
        var html_attrs = [];
        forEach(m[2], function(s) {
            if (s.match(/^\s*-+:\s*$/)) html_attrs.push({
                align: "right"
            }); else if (s.match(/^\s*:-+\s*$/)) html_attrs.push({
                align: "left"
            }); else if (s.match(/^\s*:-+:\s*$/)) html_attrs.push({
                align: "center"
            }); else html_attrs.push({});
        });
        // now for the header, avoid escaped pipes
        m[1] = _split_on_unescaped(m[1].replace(/\|\s*$/, ""), "|");
        for (i = 0; i < m[1].length; i++) {
            table[1][1].push([ "th", html_attrs[i] || {} ].concat(this.processInline(m[1][i].trim())));
        }
        // now for body contents
        forEach(m[3].replace(/\|\s*$/gm, "").split("\n"), function(row) {
            var html_row = [ "tr" ];
            row = _split_on_unescaped(row, "|");
            for (i = 0; i < row.length; i++) html_row.push([ "td", html_attrs[i] || {} ].concat(this.processInline(row[i].trim())));
            table[2].push(html_row);
        }, this);
        return [ table ];
    };
    Maruku.inline["{:"] = function inline_meta(text, matches, out) {
        if (!out.length) return [ 2, "{:" ];
        // get the preceeding element
        var before = out[out.length - 1];
        if (typeof before === "string") return [ 2, "{:" ];
        // match a meta hash
        var m = text.match(/^\{:\s*((?:\\\}|[^\}])*)\s*\}/);
        // no match, false alarm
        if (!m) return [ 2, "{:" ];
        // attach the attributes to the preceeding element
        var meta = this.dialect.processMetaHash(m[1]), attr = extract_attr(before);
        if (!attr) {
            attr = {};
            before.splice(1, 0, attr);
        }
        for (var k in meta) attr[k] = meta[k];
        // cut out the string and replace it with nothing
        return [ m[0].length, "" ];
    };
    Markdown.dialects.Maruku = Maruku;
    Markdown.dialects.Maruku.inline.__escape__ = /^\\[\\`\*_{}\[\]()#\+.!\-|:]/;
    Markdown.buildBlockOrder(Markdown.dialects.Maruku.block);
    Markdown.buildInlinePatterns(Markdown.dialects.Maruku.inline);
    // Include all our depndencies and;
    exports.Markdown = Markdown;
    exports.parse = Markdown.parse;
    exports.toHTML = Markdown.toHTML;
    exports.toHTMLTree = Markdown.toHTMLTree;
    exports.renderJsonML = Markdown.renderJsonML;
});

/**
 * Created with PyCharm.
 * User: Sarike
 * Date: 13-9-15
 * Time: 下午9:58
 * To change this template use File | Settings | File Templates.
 */
define("sarike/timefly/0.0.1/index/index-debug", [ "$-debug", "gallery/underscore/1.4.4/underscore-debug", "sarike/timefly/0.0.1/libs/libs-debug", "gallery/backbone/1.0.0/backbone-debug", "sarike/jquery-ui/1.10.3/jquery-ui-debug", "sarike/jquery-noty/2.1.0/jquery-noty-debug", "sarike/timefly/0.0.1/common/common-debug", "sarike/timefly/0.0.1/common/base/base-debug", "sarike/timefly/0.0.1/editor/editor-debug", "sarike/jquery-validate/1.11.1/jquery-validate-debug", "sarike/timefly/0.0.1/common/box/box-debug" ], function(require, exports) {
    "use strict";
    var $ = require("$-debug"), _ = require("gallery/underscore/1.4.4/underscore-debug"), libs = require("sarike/timefly/0.0.1/libs/libs-debug"), Common = require("sarike/timefly/0.0.1/common/common-debug");
    var PassionateUserCollection = Common.Collections.BaseCollection.extend({
        url: "account/passionate_users"
    });
    var LatestTodoCollection = Common.Collections.BaseCollection.extend({
        url: "todo/latest_todos"
    });
    var TodoItem = Common.Views.Item.extend({
        className: "media",
        template: _.template(require("sarike/timefly/0.0.1/index/templates/todo_item-debug.tpl")),
        render: function() {
            this.$el.html(this.template(this.model.toJSON()));
            return this;
        }
    });
    var IndexContent = Common.Views.Content.extend({
        title: "最新计划",
        sub_title: "时光飞逝网友们最近发布的最新计划，一起来为他们加油吧",
        template: _.template(require("sarike/timefly/0.0.1/index/templates/index_content-debug.tpl")),
        itemContainer: ".media-list",
        ItemView: TodoItem
    });
    exports.init = function(context) {
        context.router.route("", "index", function() {
            var sideBarBoxes = [ new Common.Box.UserBox({
                collection: new PassionateUserCollection()
            }), new Common.Box.AboutBox() ], content = new IndexContent({
                collection: new LatestTodoCollection()
            });
            context.user.set("self_home", false);
            context.user.set("at_index_page", true);
            Common.init(context, {
                sideBarBoxes: sideBarBoxes,
                content: content
            });
        });
    };
});

define("sarike/timefly/0.0.1/index/templates/todo_item-debug.tpl", [], '  <a class="pull-left" href="./#<%=user.username %>">\n    <img class="media-object img-rounded"\n         src="http://www.gravatar.com/avatar/<%=user.avatar_hash %>?d=identicon">\n  </a>\n  <div class="media-body" style="font-size:14px;line-height: 20px;">\n    <h4 class="media-heading"><%=todo_name %></h4>\n          <div class="todo_info">\n              该计划由 <a href="./#<%=user.username %>"><%=user.nickname || user.username %></a>\n                开始于 <%=todo_start %> ，\n                计划在 <%=todo_end %> 完成！\n          </div>\n        <div class="markdown todo_desc">\n            <%=tf.md.toHTML(todo_description) %>\n        </div>\n  </div>');

define("sarike/timefly/0.0.1/index/templates/index_content-debug.tpl", [], '<ul class="media-list">\n</ul>');

/**
 * Created with PyCharm.
 * User: Sarike
 * Date: 13-9-26
 * Time: 下午20:09
 * To change this template use File | Settings | File Templates.
 */
define("sarike/timefly/0.0.1/home/home-debug", [ "$-debug", "gallery/underscore/1.4.4/underscore-debug", "gallery/backbone/1.0.0/backbone-debug", "sarike/timefly/0.0.1/libs/libs-debug", "sarike/jquery-ui/1.10.3/jquery-ui-debug", "sarike/jquery-noty/2.1.0/jquery-noty-debug", "sarike/timefly/0.0.1/common/common-debug", "sarike/timefly/0.0.1/common/base/base-debug", "sarike/timefly/0.0.1/editor/editor-debug", "sarike/jquery-validate/1.11.1/jquery-validate-debug", "sarike/timefly/0.0.1/common/box/box-debug" ], function(require, exports) {
    "use strict";
    var $ = require("$-debug"), _ = require("gallery/underscore/1.4.4/underscore-debug"), Backbone = require("gallery/backbone/1.0.0/backbone-debug"), libs = require("sarike/timefly/0.0.1/libs/libs-debug"), Common = require("sarike/timefly/0.0.1/common/common-debug"), Editor = require("sarike/timefly/0.0.1/editor/editor-debug");
    var AcContentEditor = Editor.extend({
        text_area_name: "ac_description",
        editor_label: "描述一下你这次又做了哪些努力"
    });
    var settingFormTemplate = require("sarike/timefly/0.0.1/home/templates/setting_form-debug.tpl"), passwordResetTemplate = require("sarike/timefly/0.0.1/home/templates/password_reset_form-debug.tpl");
    var MyFriendsCollection = Common.Collections.BaseCollection.extend({
        url: "account/my_friends"
    });
    var TodoModel = Common.Models.BaseModel.extend({
        url: "todo/get_todo"
    });
    var MyTodoCollection = Common.Collections.BaseCollection.extend({
        url: "todo/my_todos"
    });
    var AddNewAcModal = libs.JQueryUI.Dialog.extend({
        template: _.template(require("sarike/timefly/0.0.1/home/templates/add_complete_modal-debug.tpl")),
        ok: function() {
            this.$("#ac-form").submit();
        },
        extraInitialize: function() {
            this.todoView = this.options.todoView;
            _.extend(this.tpl_data, {
                todo_id: this.todoView.model.get("todo_id")
            });
        },
        extraRender: function() {
            this.$(".editor-field").html(this.options.editor.render().el);
            var ac_form = this.$("#ac-form");
            var self = this;
            ac_form.validate({
                errorClass: "error",
                submitHandler: _.once(function(form) {
                    $(form).ajaxSubmit($.proxy(function(res) {
                        this.close();
                        this.todoView.model.get("achievement_list").push(res.data);
                        this.todoView.render();
                    }, self));
                }),
                ignore: "input[type='checkbox']",
                errorPlacement: function(error, element) {
                    element.prev().hide();
                    element.prev().after(error);
                },
                success: function(label) {
                    label.prev().show();
                    label.remove();
                },
                rules: {
                    ac_name: {
                        required: true,
                        maxlength: 128
                    },
                    ac_description: "required"
                },
                messages: {
                    ac_name: {
                        required: "不响亮不要紧，可不能不填哟",
                        maxlength: jQuery.format("够响亮了，不过不能多于{0}个字符")
                    },
                    ac_description: "你到底是完成了什么呢？"
                }
            });
        }
    });
    exports.init = function(context) {
        var editor = new AcContentEditor();
        var TodoItem = Common.Views.Item.extend({
            template: _.template(require("sarike/timefly/0.0.1/home/templates/todo_item-debug.tpl")),
            className: "todo",
            events: {
                "click a.mark-complete": "markComplete",
                "click a.delete-todo": "deleteTodo",
                "click a.change-visible": "changeVisible",
                "click a.add-new-complete": "addNewComplete",
                "click .down-vote": "downVote",
                "click .up-vote": "upVote",
                "mouseover .todo-wrapper": "toggleOps",
                "mouseout .todo-wrapper": "toggleOps"
            },
            toggleOps: function() {
                this.$(".todo-ops").toggle();
            },
            dealTodo: function(url, callback, notification) {
                var todo_id = this.model.get("todo_id");
                if (!notification) {
                    $.get(url, {
                        todo_id: todo_id
                    }, function(res) {
                        if (!!callback && typeof callback === "function") {
                            callback(res.data);
                        }
                        libs.Noty.NotyWithRes(res);
                    });
                } else {
                    libs.Noty.Confirm({
                        text: notification,
                        ok: function(noty) {
                            noty.close();
                            $.get(url, {
                                todo_id: todo_id
                            }, function(res) {
                                if (!!callback && typeof callback === "function") {
                                    callback(res.data);
                                }
                                libs.Noty.NotyWithRes(res);
                            });
                        }
                    });
                }
            },
            downVote: function() {
                this.dealTodo("/todo/down_vote", $.proxy(function(data) {
                    if (data) {
                        this.model.set("todo_down_vote", data);
                    }
                }, this));
            },
            upVote: function() {
                this.dealTodo("/todo/up_vote", $.proxy(function(data) {
                    if (data) {
                        this.model.set("todo_up_vote", data);
                    }
                }, this));
            },
            markComplete: function() {
                var notification = this.model.get("todo_is_completed") ? "确定要撤销已完成状态吗？" : "确定要标记为完成吗？";
                this.dealTodo("/todo/mark_complete", $.proxy(function(data) {
                    this.model.set("todo_is_completed", data.todo_is_completed);
                }, this), notification);
            },
            deleteTodo: function() {
                this.dealTodo("/todo/delete_todo", $.proxy(function(data) {
                    this.$el.fadeOut();
                }, this), "确定要删除吗？");
            },
            changeVisible: function() {
                var notification = this.model.get("todo_visible") ? "确定要设为私密计划吗？" : "确定要公开该计划吗？";
                this.dealTodo("/todo/change_visible", $.proxy(function(data) {
                    this.model.set("todo_visible", data.todo_visible);
                }, this), notification);
            },
            addNewComplete: function() {
                var addNewAcModal = new AddNewAcModal({
                    editor: editor,
                    todoView: this
                });
                addNewAcModal.open({
                    width: $(window).width() * .6,
                    modal: true,
                    title: "记录新的突破",
                    resizable: false
                });
            },
            render: function() {
                this.$el.html(this.template({
                    todo: this.model.toJSON(),
                    user: context.user.toJSON()
                }));
                return this;
            }
        });
        var HomeContent = Common.Views.Content.extend({
            className: "",
            has_title: false,
            ItemView: TodoItem
        });
        var SettingContent = Common.Views.ObjectContent.extend({
            title: "个人描述",
            sub_title: "写下自己的奋斗宣言",
            template: _.template(settingFormTemplate),
            events: {
                "click #updateProfile": "updateProfile"
            },
            updateProfile: function() {
                var desc = this.$("#id_description").val();
                $.post("/account/update_profile", {
                    desc: desc
                }, function(res) {
                    libs.Noty.NotyWithRes(res);
                });
            }
        });
        var ResetPasswordContent = Common.Views.ObjectContent.extend({
            title: "密码重置",
            sub_title: "修改您的账号密码",
            template: _.template(passwordResetTemplate),
            events: {
                "click #resetPwd": "resetPwd"
            },
            resetPwd: function() {
                var old_password = this.$("#id_old_password").val();
                var new_password = this.$("#id_new_password").val();
                var new_password_confirm = this.$("#id_new_password_confirm").val();
                $.post("/account/reset_password", {
                    old_password: old_password,
                    new_password: new_password,
                    new_password_confirm: new_password_confirm
                }, function(res) {
                    libs.Noty.NotyWithRes(res);
                });
            }
        });
        var HomeSideNavBox = Common.Box.SideNavBox.extend({
            side_nav_list: [ {
                id: "doing",
                caption: "正在努力的计划",
                active: true
            }, {
                id: "completed",
                caption: "已经完成的计划"
            }, {
                id: "failed",
                caption: "半途而废的计划"
            } ],
            action: function(nav) {
                var nav_id = nav.data("id");
                this.options.content.refresh({
                    flag: nav_id
                });
            }
        });
        var SettingSideNavBox = Common.Box.SideNavBox.extend({
            side_nav_list: [ {
                active: true,
                id: "profile",
                caption: "个人资料"
            }, {
                id: "pwd_reset",
                caption: "密码设置"
            } ],
            action: function(nav) {
                var flag = nav.data("id"), settingContent = this.options.content;
                if (flag === "profile") {
                    context.content.html(settingContent.render().el);
                }
                if (flag === "pwd_reset") {
                    context.content.html(new ResetPasswordContent().render().el);
                }
            }
        });
        //        context.router.route(":username", "home", function(username){
        //
        //        });
        context.router.route(":username(/:position)", "home", function(username, position) {
            $.get("/" + username, function(res) {
                var owner = res.data.owner;
                var self_home = context.user.get("username") === owner.username;
                context.user.trigger("update-user-event", {
                    self_home: self_home,
                    at_index_page: false,
                    other_home_owner: owner.username
                });
                var content = null, sideBarBoxes = null;
                if (!!position && position === "setting") {
                    content = new SettingContent({
                        data: {
                            user: context.user.toJSON()
                        }
                    });
                    sideBarBoxes = [ new Common.Box.UserProfileBox({
                        model: new Backbone.Model(owner)
                    }), new SettingSideNavBox({
                        content: content
                    }), new Common.Box.AboutBox() ];
                } else {
                    content = new HomeContent({
                        data: {
                            user: context.user
                        },
                        collection: new MyTodoCollection()
                    });
                    sideBarBoxes = [ new Common.Box.UserProfileBox({
                        model: new Backbone.Model(owner)
                    }), new HomeSideNavBox({
                        content: content
                    }), new Common.Box.UserBox({
                        collection: new MyFriendsCollection()
                    }), new Common.Box.AboutBox() ];
                }
                Common.init(context, {
                    sideBarBoxes: sideBarBoxes,
                    content: content
                });
                $(document).tooltip();
            });
        });
        context.router.route(":username/todo/:todo_id(/:ac_id)", "home_todo", function(username, todo_id, ac_id) {
            $.get("/" + username, function(res) {
                var owner = res.data.owner;
                var self_home = context.user.get("username") === owner.username;
                context.user.trigger("update-user-event", {
                    self_home: self_home,
                    at_index_page: false,
                    other_home_owner: owner.username
                });
                var todoCollection = new MyTodoCollection();
                todoCollection.queryString = {
                    todo_id: todo_id,
                    ac_id: ac_id
                };
                var content = new HomeContent({
                    data: {
                        user: context.user
                    },
                    collection: todoCollection
                });
                var sideBarBoxes = [ new Common.Box.UserProfileBox({
                    model: new Backbone.Model(owner)
                }), new HomeSideNavBox({
                    content: content
                }), new Common.Box.UserBox({
                    collection: new MyFriendsCollection()
                }), new Common.Box.AboutBox() ];
                Common.init(context, {
                    sideBarBoxes: sideBarBoxes,
                    content: content
                });
                $(document).tooltip();
            });
        });
    };
});

define("sarike/timefly/0.0.1/home/templates/setting_form-debug.tpl", [], '    <div class="control-group">\n        <div class="controls">\n            <textarea cols="40" class="input-block-level" id="id_description" rows="5"><%=user.description %></textarea>\n        </div>\n    </div>\n    <div class="control-group">\n        <div class="controls">\n            <button id="updateProfile" class="btn btn-info">保存更改</button>\n        </div>\n    </div>');

define("sarike/timefly/0.0.1/home/templates/password_reset_form-debug.tpl", [], '<div class="form-horizontal text-left" method="post">\n        <div class="control-group">\n            <label class="control-label" for="inputEmail">原始密码</label>\n            <div class="controls">\n                <input id="id_old_password" maxlength="30" name="old_password" size="30" type="password">\n                <span class="inline label label-important"></span>\n                <!-- <span class="help-block"><a href="#">你竟然把密码给忘记了？</a></span> -->\n            </div>\n        </div>\n        <div class="control-group">\n            <label class="control-label" for="inputEmail">新密码</label>\n            <div class="controls">\n            <input id="id_new_password" maxlength="30" name="new_password" size="30" type="password">\n            <span class="inline label label-important"></span>\n            </div>\n        </div>\n        <div class="control-group">\n            <label class="control-label" for="inputEmail">确认密码</label>\n            <div class="controls">\n                <input id="id_new_password_confirm" maxlength="30" name="new_password_confirm" size="30" type="password">\n                <span class="inline label label-important"></span>\n            </div>\n        </div>\n        <div class="control-group">\n            <div class="controls">\n                <button id="resetPwd" class="btn btn-info">保存更改</button>\n            </div>\n        </div>\n    </div>');

define("sarike/timefly/0.0.1/home/templates/add_complete_modal-debug.tpl", [], '<div id="acModal">\n    <div>\n        <form id="ac-form" action="todo/add_ac" method="post">\n            <input type="hidden" name="todo_id" value="<%=todo_id %>"/>\n            <label for="id_ac_name">为你这一重大突破起一个响亮的名字</label>\n            <input id="id_ac_name" maxlength="128" name="ac_name" type="text" class="input-block-level">\n            <div class="editor-field">\n            </div>\n        </form>\n    </div>\n</div>');

define("sarike/timefly/0.0.1/home/templates/todo_item-debug.tpl", [], '<div class="todo-wrapper">\n    <div class="vote-btns">\n        <div class="up-vote" title="看好你哟">\n            <span class="icon-thumbs-up"></span>\n            <span class="up-vote-count"><%= todo.todo_up_vote %></span>\n        </div>\n        <div class="down-vote" title="拉倒吧你">\n            <span class="icon-thumbs-down"></span>\n            <span class="down-vote-count"><%= todo.todo_down_vote %></span>\n        </div>\n    </div>\n    <div class="todo-header">\n        <% if(user.is_authenticated && user.self_home){ %>\n            <span class="pull-right todo-ops hide">\n                <a href="javascript:void(0)"\n                   class="mark-complete"\n                   title="<% if(todo.todo_is_completed){ %>\n                           撤销已完成状态\n                          <% }else{ %>\n                           设置为已完成\n                          <% } %>">\n                    <i class=" icon-ok"></i>\n                </a>\n                <% if(todo.todo_erasable){ %>\n                    <a href="javascript:void(0)"\n                       class="delete-todo"\n                       title="删除该计划">\n                        <i class=" icon-trash"></i>\n                    </a>\n                <% } %>\n                <a href="javascript:void(0)"\n                   class="change-visible"\n                   title="<% if(todo.todo_visible){ %>\n                             设置为仅对自己可见\n                          <% }else{ %>\n                             设置为对所有人可见\n                          <% } %>">\n                    <i class=" icon-eye-open"></i>\n                </a>\n                <% if(!todo.todo_is_completed){ %>\n                    <a href="javascript:void(0)"\n                       class="add-new-complete"\n                       title="添加新的进度">\n                        <i class="icon-plus"></i>\n                    </a>\n                <% } %>\n            </span>\n        <% } %>\n        <h2><%=todo.todo_name %></h2>\n    </div>\n    <div class="todo_meta shadow <% if(!todo.todo_visible){ %>todo_private<% } %>">\n        <div class="todo_info">\n            该计划开始于  <%=todo.todo_start %> ，计划在\n             <%=todo.todo_end %>  完成！\n        </div>\n        <div class="todo_desc markdown"><%=tf.md.toHTML(todo.todo_description) %></div>\n    </div>\n\n    <div class="todo_complete">\n        <div class="accordion" id="todo-completes<%=todo.todo_id %>">\n        <% _.each(todo.achievement_list, function(ac, index, list){ %>\n            <div class="accordion-group">\n                <div class="accordion-heading">\n                    <a class="accordion-toggle" data-toggle="collapse"\n                        data-parent="#todo-completes<%=todo.todo_id %>" href="#collapse<%=ac.id %>">\n                        在<%=tf.mm.utc2local(ac.created_date) %> 记录: <%=ac.ac_name %>\n                    </a>\n                </div>\n                <div id="collapse<%=ac.id %>" class="accordion-body collapse ">\n                    <div class="accordion-inner markdown"><%=tf.md.toHTML(ac.ac_description) %></div>\n                </div>\n            </div>\n        <% }); %>\n        </div>\n    </div>\n</div>');
